<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01matplotlib样式文件</title>
    <url>/codeHub/2020/07/31/2020-08/01matplotlib%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>这篇文章主要讲了如何修改样式，保存样式以及加载样式文件</p>
<blockquote>
<p>样式： 就是定义图形、字体、线条等一切可以美化的元素的公式；说人话就是：你定义好一个公式A，A中定义线条的颜色是红色；现在画图的时候你需要美化一个线条；就直接使用这个公式；线条就变成了红色；这样说的话样式也就相当于一种画图的风格。</p>
</blockquote>
<p>matplot支持两种修改样式的方式：</p>
<ul>
<li>使用样式表</li>
<li>使用rcParams</li>
</ul>
<a id="more"></a>

<h3 id="这两种修改样式的方式有啥区别呢？"><a href="#这两种修改样式的方式有啥区别呢？" class="headerlink" title="这两种修改样式的方式有啥区别呢？"></a>这两种修改样式的方式有啥区别呢？</h3><p>样式表的方式是通过加载样式文件，来修改matplotlib中默认的绘图风格；加载了文件后只在当前环境生效，下次要用还得重新加载。而rcParams则是直接修改matplotlib的默认配置，一劳永逸。</p>
<p>下面就用代码来看看具体的效果吧。</p>
<p>来解读一下具体代码的作用</p>
<p>为了方便比较，我使用了<code>subplot</code>函数生成两个子图，函数内部参数不懂的可以看我之前写的一篇<code>pyplot</code>对象的文章。<br>默认情况下，matplotlib中加载自定义样式时是对全局生效的，如果你只想在某个地方使用这个样式就得像我这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> plt.style.context(<span class="string">'fivethirtyeight'</span>):</span><br><span class="line">    plt.plot(data)</span><br><span class="line">    plt.title(<span class="string">'fivethirtyeight style'</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>通过比较可以发现，再使用了系统中的定义的一个样式后，线条明显变粗了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##使用系统默认的样式</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl   <span class="comment">##因为要修改样式所有matplotlib都得引入</span></span><br><span class="line"><span class="keyword">from</span> cycler <span class="keyword">import</span> cycler</span><br><span class="line">plt.figure() <span class="comment">##生成一块画布</span></span><br><span class="line">data = np.random.randn(<span class="number">50</span>) <span class="comment">##绘图数据</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>) <span class="comment">##绘制系统默认的样式</span></span><br><span class="line"></span><br><span class="line">plt.plot(data)</span><br><span class="line">plt.title(<span class="string">"default style"</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>) <span class="comment">##绘制系统样式</span></span><br><span class="line"><span class="keyword">with</span> plt.style.context(<span class="string">'fivethirtyeight'</span>):</span><br><span class="line">    plt.plot(data)</span><br><span class="line">    plt.title(<span class="string">'fivethirtyeight style'</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/31/aljVK0.png" alt="aljVK0.png"></p>
<h3 id="使用系统定义的样式"><a href="#使用系统定义的样式" class="headerlink" title="使用系统定义的样式"></a>使用系统定义的样式</h3><p>使用这个<code>print(plt.style.available)</code>函数可以打印中吗，matplotlib中预先定义好的一些样式。<br>哇哦惊讶的发现我无敌<code>ggplot</code>样式竟然在里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Solarize_Light2'</span>, <span class="string">'_classic_test_patch'</span>, <span class="string">'bmh'</span>, <span class="string">'classic'</span>, <span class="string">'dark_background'</span>, <span class="string">'fast'</span>, <span class="string">'fivethirtyeight'</span>, <span class="string">'ggplot'</span>, <span class="string">'grayscale'</span>, <span class="string">'seaborn'</span>, <span class="string">'seaborn-bright'</span>, <span class="string">'seaborn-colorblind'</span>, <span class="string">'seaborn-dark'</span>, <span class="string">'seaborn-dark-palette'</span>, <span class="string">'seaborn-darkgrid'</span>, <span class="string">'seaborn-deep'</span>, <span class="string">'seaborn-muted'</span>, <span class="string">'seaborn-notebook'</span>, <span class="string">'seaborn-paper'</span>, <span class="string">'seaborn-pastel'</span>, <span class="string">'seaborn-poster'</span>, <span class="string">'seaborn-talk'</span>, <span class="string">'seaborn-ticks'</span>, <span class="string">'seaborn-white'</span>, <span class="string">'seaborn-whitegrid'</span>, <span class="string">'tableau-colorblind10'</span>]</span><br></pre></td></tr></table></figure>

<h3 id="定义你的样式文件"><a href="#定义你的样式文件" class="headerlink" title="定义你的样式文件"></a>定义你的样式文件</h3><p>知道了如何使用样式文件来批量美化图片后，接下来就是定义你自己的一套审美啦。样式文件的格式采用的是键值对的形式，如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">axes.titlesize : <span class="number">24</span></span><br><span class="line">axes.labelsize : <span class="number">20</span></span><br><span class="line">lines.linewidth : <span class="number">3</span></span><br><span class="line">lines.markersize : <span class="number">10</span></span><br><span class="line">xtick.labelsize : <span class="number">16</span></span><br><span class="line">ytick.labelsize : <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>在定义好之后，只需要加上文件路径就可以使用，这里我还没测试不知道文件是不是必须得用<code>mplstyle</code>为后缀；我觉得应该不需要</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.style.use(<span class="string">'./images/presentation.mplstyle'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="组合多个样式文件"><a href="#组合多个样式文件" class="headerlink" title="组合多个样式文件"></a>组合多个样式文件</h3><p>美化图片也可以变成和搭积木一样，比如把线条的美化存成一个<code>line.mplstyle</code>文件，背景的美化存成<code>background.mplstyle</code>文件；这样当你有多个这个的文件的时候就可以同过组合起来，构成一个独特的样式啦</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> plt.style.context(<span class="string">'dark_background'</span>,<span class="string">'ggplot'</span>):  <span class="comment">##只在局部环境生效</span></span><br><span class="line">    plt.plot(np.sin(np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi)), <span class="string">'r-o'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> plt.style.context(<span class="string">'dark_background'</span>,<span class="string">'ggplot'</span>):</span><br><span class="line">    plt.plot(np.sin(np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi)))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/31/aljZrV.png" alt="aljZrV.png"></p>
<h3 id="rcParams修改系统默认样式"><a href="#rcParams修改系统默认样式" class="headerlink" title="rcParams修改系统默认样式"></a>rcParams修改系统默认样式</h3><p>这个操作时对所有环境都生效的哟，如果你觉得matplotlib的默认样式太丑了，恰巧你想修改它的样式并且想在每次画图都自动的使用你设置好的样式，那就可以考虑用它了</p>
<p>设置的方式也非常的简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mpl.rcParams[<span class="string">'lines.linewidth'</span>] = <span class="number">2</span></span><br><span class="line">mpl.rcParams[<span class="string">'lines.linestyle'</span>] = <span class="string">'--'</span></span><br><span class="line">plt.plot(data)</span><br></pre></td></tr></table></figure>

<p>如果你想重置之前的配置的话，可以使用函数<code>matplotlib.rcdefaults()</code>进行重置。</p>
<h3 id="关于样式文件的位置"><a href="#关于样式文件的位置" class="headerlink" title="关于样式文件的位置"></a>关于样式文件的位置</h3><p>这个东西用的不多，仅仅了解一下就可以了</p>
<p>如果想像使用系统中自定义样式文件那样引入样式文件而不使用路径的话<code>plt.style.context(&#39;ggplot&#39;)</code>，只需要把你的为文件存在这个目录下即可<code>~/.config/matplotlib/stylelib/</code>,文件的命名也有讲究和系统的命令类似即可。<br>系统rcParams中默认的样式文件，存储在<code>~/.config/matplotlib/matplotlibrc</code>这个文件内；喜欢折腾的可以改改这个文件。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://matplotlib.org/tutorials/introductory/customizing.html#sphx-glr-tutorials-introductory-customizing-py" target="_blank" rel="noopener">matplotlib样式</a></p>
]]></content>
  </entry>
  <entry>
    <title>Git系列（三）——文件的修改及提交</title>
    <url>/codeHub/2020/07/28/2020-07/16Git%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E5%8F%8A%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<h1 id="Git系列（三）——文件的修改及提交"><a href="#Git系列（三）——文件的修改及提交" class="headerlink" title="Git系列（三）——文件的修改及提交"></a>Git系列（三）——文件的修改及提交</h1><p>文件的创建以及上传我们已经搞定了，现在我们需要对我们的文档进行修改，这些该如何进行呢，我么这就来学习一下。</p>
<a id="more"></a>

<hr>
<h2 id="文件的修改及查看"><a href="#文件的修改及查看" class="headerlink" title="文件的修改及查看"></a>文件的修改及查看</h2><p>我们先给我们的<code>tmp.txt</code>文件加上一句话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I like Git</span><br><span class="line">Because it is useful</span><br></pre></td></tr></table></figure>

<p>保存之后，我们就可以使用<code>git status</code>命令查看修改结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#	modified:   tmp.txt</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>结果很多，但其实就一句话最有用，就是<code>#    modified:   tmp.txt</code>它告诉我们<code>tmp.txt</code>文件被修改过了，最后一句话告诉我们修改还没有进行提交。</p>
<p>但是如果第一天的修改，我们第二天忘记了，不用慌，我们可以使用<code>git diff</code>指令查看具体的修改内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a&#x2F;tmp.txt b&#x2F;tmp.txt</span><br><span class="line">index ad2ec82..1137052 100644</span><br><span class="line">--- a&#x2F;tmp.txt</span><br><span class="line">+++ b&#x2F;tmp.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> I like Git</span><br><span class="line">+Because it is useful</span><br></pre></td></tr></table></figure>

<p>我们就可以从结果看出，我们加了一行<code>Because it is useful</code></p>
<h2 id="文件修改的查看"><a href="#文件修改的查看" class="headerlink" title="文件修改的查看"></a>文件修改的查看</h2><p>还是之前的两步：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add tmp.txt</span><br></pre></td></tr></table></figure>

<p>之后，我们可以再使用<code>git status</code>来查看当前仓库的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#	modified:   tmp.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>git告诉我们，被提交的修改中包括<code>tmp.txt</code>文件，这时候我们就可以安心的提交了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add Because it is useful&quot;</span><br><span class="line">[master 2c2ad62] add Because it is useful</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>成功之后，我们可以再来看当前仓库的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<hr>
<p>git告诉我们，当前目录是干净的，没有文件被修改过，到此，我们就进行了文件的修改工作，这其实还没有展现出git的强大之处，下次我们会学习版本的回溯，准备好“时光穿梭机”一起感受git的强大之处吧！</p>
<ul>
<li>参考 <a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git系列（二）——Git版本库创建以及文件上传</title>
    <url>/codeHub/2020/07/28/2020-07/15Git%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Git%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="Git系列（二）——Git版本库创建以及文件上传"><a href="#Git系列（二）——Git版本库创建以及文件上传" class="headerlink" title="Git系列（二）——Git版本库创建以及文件上传"></a>Git系列（二）——Git版本库创建以及文件上传</h1><p>费（hao）尽（bu）心（fei）思（li）安装好了Git，那就赶紧跟着小编用用看吧！</p>
<a id="more"></a>

<hr>
<h2 id="Git版本库的创建"><a href="#Git版本库的创建" class="headerlink" title="Git版本库的创建"></a>Git版本库的创建</h2><p>首先，名词解释<code>版本库</code>：又名仓库、英文名<strong>repository</strong>，其实说白了就是一个目录，这个目录下的任何修改都会被Git管理起来，在任何时候都可以追踪历史并且随心所欲“还原”。</p>
<p>OK，弄懂了版本库，那么我们就来创建一个文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br></pre></td></tr></table></figure>

<p>版本库，简单到只有一个指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<p>在一个呼吸之间，Git就把仓库创建好了，本来空白的目录下悄无声息的多了一个文件加<code>.git</code>，这个目录很重要，是用来跟踪管理版本库的，不要随意修改，修改后很有可能把Git仓库给破坏了。</p>
<ul>
<li>如果没有看到<code>.git</code>文件夹，那一定是没有使用 ll -a命令</li>
</ul>
<h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><p>首先，我自这里必须强调一点，Git只能进行对纯文本文件进行文件版本得追踪及还原，对于二进制文件，没有办法追踪文件得变化，所以，要想用Git进行文件得管理，只能使用纯文本方式编写文件</p>
<ul>
<li>强烈建议使用标准的UTF-8编码文本，被所有平台支持的文件</li>
</ul>
<p>好了，我们现在先编写一个文件<code>tmp.txt</code>，文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I like Git</span><br></pre></td></tr></table></figure>

<p>这个文件必须在<code>learngit</code>文件夹下（子目录也可以）</p>
<p>然后我们只需要两步就可以把这个文件添加到版本库里边了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add tmp.txt</span><br></pre></td></tr></table></figure>

<p>执行上面的指令之后，如果什么都没有出现，那就成功了，第一步就是这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;write a tmp file&quot;</span><br><span class="line">[master 1210900] write a tmp file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 tmp.txt</span><br></pre></td></tr></table></figure>

<p>解释一下<code>git commit</code>这个指令，<code>-m</code>后面加的是对于本次改动的一个说明，强烈建议仔细填写，这样追溯版本时会很舒服。<code>git commit</code>之后，git会告诉你<code>1 file changed</code>这就是说有一个文件被改动了，<code>1 insertion(+)</code>这就是说我们插入了一行新的内容。</p>
<p>最后，如果想分批添加三个文件，我们可以这么做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file1</span><br><span class="line">$ git add file2 file3</span><br><span class="line">$ git commit -m &quot;add 3 files&quot;</span><br></pre></td></tr></table></figure>

<p>这也是为什么git上传文件需要两步的原因。</p>
<hr>
<p>好了本次教程到此结束，我们学会了创建新的文件，接下来我们会学习文件的修改相关内容。</p>
<ul>
<li>参考 <a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git系列（一）——Git的简介及安装</title>
    <url>/codeHub/2020/07/28/2020-07/14Git%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Git%E7%9A%84%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Git系列（一）——Git的简介及安装"><a href="#Git系列（一）——Git的简介及安装" class="headerlink" title="Git系列（一）——Git的简介及安装"></a>Git系列（一）——Git的简介及安装</h1><p>众所周知（跟计算机打交道多的），Git是一个很先进的版本控制系统，但其实不瞒你们知道，它是目前世界上最先进的分布式版本控制系统（没有之一）。所以说，还在等着什么，快跟着小编一起来轻松愉快的学习Git吧。</p>
<a id="more"></a>

<hr>
<h2 id="Git的简介"><a href="#Git的简介" class="headerlink" title="Git的简介"></a>Git的简介</h2><p>相信大家在实际工作生活中都会使用word进行长篇大论文章的书写，尤其时当很多人一起进行文档的书写时，一定避免不了的进行文档的修改，这时候你一定会抱怨为什么会有这么多中间版本，接收文件时如果命名重复的话就会出现是否覆盖的选项，这个时候如果Git出现在你的世界，你一定会毫不留情地爱上它的。</p>
<p>Git采用的是分布式控制管理系统（下图），与其相对应的是集中式版本控制系统（上图），分布式控制管理系统没有真正意义上的“中央服务器”，每个人的电脑都有完整的版本库，所以说除非所有的电脑同时坏掉，不然就不用担心数据会丢失这样的数据安全问题。当你和同事同时修改了文件A，那么你们只需要进行文件A修改的交换，就可以看到对方的修改了，但一般都会有一台电脑充当“中央服务器”，这是为了方便交换大家的修改。没有它大家也可以进行正常的工作，只是交换修改不方便而已。</p>
<img data-src="https://s1.ax1x.com/2020/07/28/aVizqg.png" alt="1.png" style="zoom:50%;" />

<img data-src="https://s1.ax1x.com/2020/07/28/aVixsS.png" alt="2.png" style="zoom:50%;" />

<h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>Git的安装很简单，这里主要介绍linux和windows上安装Git</p>
<h3 id="在linux上安装Git"><a href="#在linux上安装Git" class="headerlink" title="在linux上安装Git"></a>在linux上安装Git</h3><p>你可以在系统中输入<code>git</code>，看看系统中有没有安装git，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &#39;git&#39; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>如果没有安装git，linux会贴心的提示你安装的指令<code>sudo apt-get install git</code></p>
<p>或者也可以通过源码进行安装，源码压缩包<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/" target="_blank" rel="noopener">网站</a>，解压之后，依次输入<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令之后</p>
<h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p>直接从Git官网上直接下载并按照默认选项安装即可。安装成功之后，在开始菜单Git文件夹中找到Git Bash，打开以后是一个命令行窗口，那就说明安装成功了。</p>
<p><img data-src="https://s1.ax1x.com/2020/07/28/aVivM8.png" alt="3.png"></p>
<img data-src="https://s1.ax1x.com/2020/07/28/aViXxf.png" alt="4.png" style="zoom:67%;" />

<p>安装成功之后，我们需要简单配置一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name	<span class="comment">#Your Name</span></span><br><span class="line">$ git config --global user.email	<span class="comment">#email@example.com</span></span><br></pre></td></tr></table></figure>

<p><code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config  user.name</span><br><span class="line">$ git config  user.email</span><br><span class="line">$ git config --list <span class="comment">#查看当前配置</span></span><br></pre></td></tr></table></figure>

<hr>
<p>到此为止，我们的Git已经安装并简单配置完毕，下一个教程我们会介绍创建版本库以及简单的上传文件操作，敬请期待！</p>
<ul>
<li>参考 <a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>基于Vue前端网页实现</title>
    <url>/codeHub/2020/07/28/2020-07/13%E5%9F%BA%E5%9B%A0Vue%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在看了一遍<code>vue-element-admin</code>的源代码后，自己试着按照这个项目中的思路去构建前端单页面应用。在构建的过程中学习了<code>vuex</code>进行组件间的状态管理、学习了他项目的目录结构设计以及对应的思路；进一步优化了前端路由的设计。</p>
<p>在写用户登录登出<code>API</code>时，使用到了<code>session/cookie</code>的知识，利用后端服务器保存用户信息在<code>session</code>中。</p>
<blockquote>
<p>项目展示网址 :<a href="http://cotton.hzau.edu.cn/web/#/home" target="_blank" rel="noopener">http://cotton.hzau.edu.cn/web/#/home</a></p>
</blockquote>
<a id="more"></a>

<h2 id="layout布局"><a href="#layout布局" class="headerlink" title="layout布局"></a>layout布局</h2><p>借助与router实现一个layout框架，在框架内部铺设子路由改变局部页面</p>
<p>整个思维图如下：</p>
<img data-src="https://s1.ax1x.com/2020/07/28/akcCrt.png" alt="akcCrt.png" style="zoom:67%;" />

<h3 id="路由的设置"><a href="#路由的设置" class="headerlink" title="路由的设置"></a>路由的设置</h3><p>首先在路由进入到<code>/</code>时，将会渲染layout组件，在layout组件内部包含有一个子路由的视图</p>
<p>因此，在进入到layout后，如果子路由将会渲染<code>App-main</code>内的内容；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  component: HomeLayout,</span><br><span class="line">  redirect: <span class="string">'/home'</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/home'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">'@/views/home'</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      meta: &#123; <span class="attr">title</span>: <span class="string">'cottonWeb'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="Vue中的配置"><a href="#Vue中的配置" class="headerlink" title="Vue中的配置"></a>Vue中的配置</h3><p>程序根组件<code>App.vue</code>中的<code>router-view</code>用于挂载布局组件或者<code>404</code>页面组件，布局发生改变，或者刚开始进入时都会触发页面动画</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;transition enter-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">"animate__animated animate__fadeInUp"</span>&gt;</span><br><span class="line">      &lt;router-view /&gt;</span><br><span class="line">    &lt;<span class="regexp">/transition&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>

<p>layout组件配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;cotton-navbar&gt;&lt;<span class="regexp">/cotton-navbar&gt;</span></span><br><span class="line">    &lt;app-main&gt;&lt;/app-main&gt; ###这里放置一个子路由</span><br><span class="line">    &lt;cotton-footer&gt;&lt;<span class="regexp">/cotton-footer&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>

<p>功能页面组件配置</p>
<p>子路由发生改变时，将会触发动画效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;transition enter-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">"animate__animated animate__fadeInDown"</span>&gt;</span><br><span class="line">      &lt;router-view :key=<span class="string">"key"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/transition&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><h3 id="安装animal-css"><a href="#安装animal-css" class="headerlink" title="安装animal.css"></a>安装animal.css</h3><p>借助第三方的css工具实现动画效果<code>animate.css</code></p>
<blockquote>
<p>注意使用的时候 一定要加上 animate__animate 这个类名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install animate.css --save</span><br><span class="line"><span class="comment">##在需要使用的地方加上类就行</span></span><br><span class="line">&lt;h1 class=<span class="string">"animate__animated animate__bounce"</span>&gt;An animated element&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-路由跳转动画"><a href="#1-路由跳转动画" class="headerlink" title="1.路由跳转动画"></a>1.路由跳转动画</h3><ul>
<li>这里的<code>mode</code>这个参数还没搞明白</li>
</ul>
<blockquote>
<p>具体的参数描述： <a href="https://cn.vuejs.org/v2/api/#transition" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#transition</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition enter-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">"animate__animated animate__fadeInDown"</span> mode=<span class="string">"in-out"</span>&gt;</span><br><span class="line">  &lt;router-view /&gt;</span><br><span class="line">&lt;<span class="regexp">/transition&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="session配置"><a href="#session配置" class="headerlink" title="session配置"></a>session配置</h2><blockquote>
<p>1.5.0后的版本不再需要<code>cookie-parser</code>的支持了；并且session只是单纯的发送一个session ID 给客户端，而真正的session数据是存储在服务端的。并且默认情况下session是保存在内存当中的仅仅适用于开发和调试模式，至于生产模式下可能会导致内存泄露，得想个办法把它存数据库里或者文件中。</p>
</blockquote>
<p>由于我数据库使用的是<code>mysql</code>，因此可以使用对应的mysql将session持久化存起来；我采用文件的方式保存session</p>
<blockquote>
<p><a href="https://www.npmjs.com/package/connect-mssql" target="_blank" rel="noopener">connect-mssql</a> A SQL Server-based session store.</p>
</blockquote>
<h3 id="1-初始化session"><a href="#1-初始化session" class="headerlink" title="1.初始化session"></a>1.初始化session</h3><ul>
<li><code>name</code>参数设置客户端中cookie的key名称</li>
<li><code>secret</code>对session ID进行加盐的字符</li>
<li><code>resave</code>多个客户端并发请求时，保留最后一次请求并且覆盖前面的</li>
<li><code>saveUninitialized</code>初始化的session是否进行保存</li>
<li><code>maxAge</code>和<code>cookie.expires</code>参数都可以设置cookie过期时间，如果都设置了以最后设置的为准，还是设置<code>maxAge</code>好一些，以秒为单位</li>
<li><code>cookie.path</code>设置cookie存储的路径，默认是根域名下；当然可以修改为子域名</li>
<li><code>cookie.secure</code>只适用于https请求，设置为true时，在http请求下cookie失效</li>
</ul>
<blockquote>
<p>我设置只在/login API下才能够得到cookie，而在/people API下得不到；</p>
<p>rolling: true, //每个请求都重新设置一个cookie ；当客户端手动删除cookie时，非常有用，我在这折腾了好久</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>) <span class="comment">//use session</span></span><br><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    secret: <span class="string">'cotton'</span>,</span><br><span class="line">    name: <span class="string">'token'</span>,</span><br><span class="line">    resave: <span class="literal">false</span>,</span><br><span class="line">    saveUninitialized: <span class="literal">true</span>,</span><br><span class="line">    cookie:&#123;</span><br><span class="line">        maxAge:<span class="number">86400000</span>,  <span class="comment">//设置cookie过期时间以毫秒为单位</span></span><br><span class="line">        path:<span class="string">'/login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">      rolling: <span class="literal">true</span>, <span class="comment">//每个请求都重新设置一个cookie</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> rolling: true; 这个参数设置为真时，当用户手动清空掉cookie时，服务端仍旧会重新发送一份cookie；如果不设置的话，客户端是得不到cookie，进而服务端会出错；这里我弄了好久</p>
</blockquote>
<h3 id="2-将用户登录信息保存在session中"><a href="#2-将用户登录信息保存在session中" class="headerlink" title="2.将用户登录信息保存在session中"></a>2.将用户登录信息保存在session中</h3><p>首先根据客户端cookie中的信息判断客户端对应的session中是否包含<code>login</code>字段；如果包含则无需进行数据库query；直接从session中获取用户信息；否则验证用户身份，并将用户信息存在session中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.session.login) &#123;</span><br><span class="line">    res.send(<span class="string">'ok'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req.session.login = <span class="literal">true</span></span><br><span class="line">    res.send(<span class="string">'no'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-将session保存在文件中持久化"><a href="#3-将session保存在文件中持久化" class="headerlink" title="3.将session保存在文件中持久化"></a>3.将session保存在文件中持久化</h3><p>由于express-session将session信息保存在内存当中，因此为了防止node内心泄露，需要对session数据持久化</p>
<blockquote>
<p>参考 <a href="https://www.npmjs.com/package/session-file-store" target="_blank" rel="noopener">https://www.npmjs.com/package/session-file-store</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>) <span class="comment">//use session</span></span><br><span class="line"><span class="keyword">var</span> FileStore = <span class="built_in">require</span>(<span class="string">'session-file-store'</span>)(session) <span class="comment">//use file store session</span></span><br><span class="line"><span class="keyword">var</span> fileStoreOptions = &#123;</span><br><span class="line">  ttl: <span class="number">86400</span>,  <span class="comment">//设置session文件过期时间，以秒为单位</span></span><br><span class="line">  path: path.join(__dirname, <span class="string">'./sessions'</span>), <span class="comment">//设置session保存路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-存信息的时候统一存进一个date对象内"><a href="#4-存信息的时候统一存进一个date对象内" class="headerlink" title="4.存信息的时候统一存进一个date对象内"></a>4.存信息的时候统一存进一个date对象内</h4><p>当客户端第一次访问时，判断session是否存在<code>data</code>属性，如果不存在则进行进行身份验证，验证通过后修改session中data字段数据，并且返回成功代码给客户端；</p>
<p>如果失败则返回错误代码给客户端，进行重新登录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.session.data) &#123;</span><br><span class="line">    res.send(req.session.data) <span class="comment">//处于登录状态了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req.session.data = <span class="literal">true</span></span><br><span class="line">    res.send(<span class="string">'no'</span>) <span class="comment">//非登录状态，进行数据库查询操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>之后需要登录才能得到信息的接口，就直接判断当前session中是否存在数据，不存在就直接返回401，让前端进行登录才能获取到数据</p>
<h3 id="登录验证API"><a href="#登录验证API" class="headerlink" title="登录验证API"></a>登录验证API</h3><p>当用户提交了账号和密码之后，进行验证；如果验证通过则将信息存储在session文件中，cookie中保留session文件ID</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">'zpliu'</span></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">'111'</span></span><br><span class="line">router.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.session.data) &#123;</span><br><span class="line">    res.json(req.session.data)</span><br><span class="line">    <span class="comment">//处于登录状态了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//进行密码验证</span></span><br><span class="line">    <span class="keyword">if</span> (req.body.username === username &amp;&amp; req.body.password === password) &#123;</span><br><span class="line">      req.session.data = &#123;</span><br><span class="line">        name: <span class="string">'zpliu'</span>,</span><br><span class="line">        grade: <span class="string">'master'</span>,</span><br><span class="line">        role: <span class="string">'Administrator'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(req.session)</span><br><span class="line">      res.redirect(<span class="string">'/login'</span>)  <span class="comment">//这里重定向还是会产生一点问题，第一次登录会有404，后面改成发生响应数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        code: <span class="number">6000</span>,</span><br><span class="line">        message: <span class="string">'账号或密码错误'</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终代码，已经加上了sql进行账号和密码的验证，以及MD5加密操作</p>
<blockquote>
<p><a href="https://github.com/zpliu1126/nodeAPI/blob/cfd3201f9b02a8d963a89ea8f5961c03997d3089/API/auth/index.js" target="_blank" rel="noopener">https://github.com/zpliu1126/nodeAPI/blob/cfd3201f9b02a8d963a89ea8f5961c03997d3089/API/auth/index.js</a></p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.cnblogs.com/tugenhua0707/p/9098132.html" target="_blank" rel="noopener">配置session</a></li>
<li><a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">vuex</a></li>
<li><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/" target="_blank" rel="noopener">vue-element-admin</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>手把手教你搭建JBrowse-初始化应用</title>
    <url>/codeHub/2020/07/25/2020-07/12%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BAjbrowse/</url>
    <content><![CDATA[<h2 id="手把手教你搭建JBrowse-初始化应用"><a href="#手把手教你搭建JBrowse-初始化应用" class="headerlink" title="手把手教你搭建JBrowse-初始化应用"></a>手把手教你搭建JBrowse-初始化应用</h2><p>JBrowse是<strong>GMOD</strong>开源项目中的一个基因组浏览器，所谓的基因组浏览器，字面意思就可以理解成一个网页应用。可能每个生物信息分析的同学电脑内都会安装一个<strong>IGV</strong>，用于对高通量测序数据的可视化。其实<strong>JBrowse</strong>也就是相当于把<strong>IGV</strong>，搬到了服务器内，把庞大的测序数据存储在服务器内，借助于快速发展的web技术；使得我们能够通过仅仅发送一个网页链接就能够与他人共享或者讨论课题。</p>
<blockquote>
<p>本文搭建JBrowse应用访问链接： <a href="http://cotton.hzau.edu.cn/tools/jbrowse/" target="_blank" rel="noopener">http://cotton.hzau.edu.cn/tools/jbrowse/</a></p>
</blockquote>
<p><img data-src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/80625/headerpic.svg" alt="吃瓜"></p>
<a id="more"></a>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>JBrowse支持两种配置文件：</p>
<ul>
<li>JSON格式</li>
<li>textual格式</li>
</ul>
<p>其中JBrowse的全局配置文件<code>jbrowse.conf</code>采用textual格式进行配置，具体到特定的数据例如 基因组序列，BAM文件的配置信息时采用textual格式；具体到某种数据的显示时采用JSON进行配置</p>
<blockquote>
<p>入门文章也是使用简化的配置：<a href="https://jbrowse.org/docs/minimal.html" target="_blank" rel="noopener">https://jbrowse.org/docs/minimal.html</a></p>
</blockquote>
<p>主要讲一下<code>tracks.conf</code>这个<code>textual</code>类型的配置文件</p>
<ul>
<li><code>[tracks.refseq]</code>后面的refseq表示轨迹的名称，之后再WEB上的选项上会出现</li>
<li><code>urlTemplate</code>表示轨迹文件在的路径，相对于当前配置文件的路径</li>
<li><code>storeClass</code>轨迹的类型包括<code>fasta</code>、<code>vcf</code>、<code>BAM</code></li>
<li><code>type</code>字段也差不多</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[GENERAL]</span><br><span class="line">refSeqs=Ghirsutum_HZAU_V1.0.fa.fai  <span class="comment">##固定格式便于快速提取基因序列</span></span><br></pre></td></tr></table></figure>

<h3 id="文件建立索引"><a href="#文件建立索引" class="headerlink" title="文件建立索引"></a>文件建立索引</h3><p>建立索引的目的是让JBrowse能够快速的找出目标位置的序列信息</p>
<h4 id="fasta文件建立索引"><a href="#fasta文件建立索引" class="headerlink" title="fasta文件建立索引"></a>fasta文件建立索引</h4><p>使用samtools中的子程序<code>faidx</code>建立基因组索引，这样在JBrowse中就可以快速的导出指定片段的fasta序列信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##使用软连接为了节省空间</span></span><br><span class="line">ln -s /home/genome/Public/genome_Ghir.HAU/Ghirsutum_genome.fasta Ghirsutum_HZAU_V1.0</span><br><span class="line">samtools faidx data/volvox.fa</span><br></pre></td></tr></table></figure>

<p>配置文件<code>tracks.conf</code>，告诉JBrowse；基因组文件在哪里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[GENERAL]</span><br><span class="line">refSeqs=Ghirsutum_HZAU_V1.0.fa.fai</span><br><span class="line">[tracks.refseq]</span><br><span class="line">urlTemplate=Ghirsutum_HZAU_V1.0.fa</span><br><span class="line">storeClass=JBrowse/Store/SeqFeature/IndexedFasta</span><br><span class="line"><span class="built_in">type</span>=Sequence</span><br></pre></td></tr></table></figure>

<h4 id="gff文件索引"><a href="#gff文件索引" class="headerlink" title="gff文件索引"></a>gff文件索引</h4><p>使用GFF3文件构建索引，在建立索引之前需要对GFF3文件进行排序，安装染色体和位置进行排序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##排序</span></span><br><span class="line"> grep -v <span class="string">"^#"</span> /home/genome/Public/genome_Ghir.HAU/Ghirsutum_gene_model.gff3 |sort -k1,1 -k4,4n &gt;Ghirsutum_HZAU_V1.0_gene.gff3</span><br></pre></td></tr></table></figure>

<p>在排序完成后进行压缩和建立索引；使用<code>tabix</code>软件进行；</p>
<blockquote>
<p>tabix安装参考 <a href="https://www.jianshu.com/p/b6f885fc8b5f" target="_blank" rel="noopener">https://www.jianshu.com/p/b6f885fc8b5f</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##压缩文件</span></span><br><span class="line">../../software/tabix-0.2.6/bgzip  Ghirsutum_HZAU_V1.0_gene.gff3</span><br><span class="line"><span class="comment">##建立索引</span></span><br><span class="line">../../software/tabix-0.2.6/tabix -p gff  Ghirsutum_HZAU_V1.0_gene.gff3.gz</span><br></pre></td></tr></table></figure>

<p>在<code>tracks.conf</code>文件中添加配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[tracks.genes]</span><br><span class="line">urlTemplate=Ghirsutum_HZAU_V1.0_gene.gff3.gz</span><br><span class="line">storeClass=JBrowse/Store/SeqFeature/GFF3Tabix</span><br><span class="line"><span class="built_in">type</span>=CanvasFeatures</span><br></pre></td></tr></table></figure>

<h4 id="BAM文件索引"><a href="#BAM文件索引" class="headerlink" title="BAM文件索引"></a>BAM文件索引</h4><p>BAM文件同样需要使用samtools按照染色体位置排好序，再建立索引；再JBrowse更新到<code>v1.15.0</code>版本后支持了CRAM格式文化，这种格式相比于BAM格式更加节省存储空间</p>
<p>JBrowse可以对BAM文件进行两种展示:</p>
<blockquote>
<p>参考 BAM两种展示形式 <a href="https://jbrowse.org/docs/tutorial_classic.html#next-gen-read-track-types" target="_blank" rel="noopener">https://jbrowse.org/docs/tutorial_classic.html#next-gen-read-track-types</a></p>
</blockquote>
<ul>
<li><p>set type = Alignments2  ；显示单个read的比对情况</p>
</li>
<li><p>type = SNPCoverage  ；显示某个区域read的覆盖情况</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##对bam文件排序</span></span><br><span class="line">samtools sort test.bam -O bam -o test_sort.bam</span><br><span class="line"><span class="comment">##构建索引</span></span><br><span class="line">samtools index test_sort.bam</span><br></pre></td></tr></table></figure>

<p>在<code>tracks.conf</code>文件中添加配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[tracks.alignments]</span><br><span class="line">urlTemplate=test_sort.bam</span><br><span class="line">storeClass=JBrowse/Store/SeqFeature/BAM</span><br><span class="line"><span class="built_in">type</span>=Alignments2</span><br></pre></td></tr></table></figure>

<h4 id="配置完成后的目录结构"><a href="#配置完成后的目录结构" class="headerlink" title="配置完成后的目录结构"></a>配置完成后的目录结构</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##当前目录为 @//jbrowse/data</span></span><br><span class="line">.</span><br><span class="line">├── Ghirsutum_HZAU_V1.0.fa -&gt; /home/genome/Public/genome_Ghir.HAU/Ghirsutum_genome.fasta</span><br><span class="line">├── Ghirsutum_HZAU_V1.0.fa.fai</span><br><span class="line">├── Ghirsutum_HZAU_V1.0_gene.gff3.gz</span><br><span class="line">├── Ghirsutum_HZAU_V1.0_gene.gff3.gz.tbi</span><br><span class="line">├── TM1_rmdup.bam</span><br><span class="line">├── TM1_rmdup.bam.bai</span><br><span class="line">└── tracks.conf</span><br></pre></td></tr></table></figure>

<h3 id="定制轨迹"><a href="#定制轨迹" class="headerlink" title="定制轨迹"></a>定制轨迹</h3><h4 id="修改参考序列轨迹"><a href="#修改参考序列轨迹" class="headerlink" title="修改参考序列轨迹"></a>修改参考序列轨迹</h4><blockquote>
<p>参考修改 序列轨迹 <a href="https://jbrowse.org/docs/reference_sequence.html#reference-sequence-display-order" target="_blank" rel="noopener">https://jbrowse.org/docs/reference_sequence.html#reference-sequence-display-order</a></p>
</blockquote>
<p>可以通过修改CSS来改变5种碱基 A T C G N显示的颜色</p>
<h4 id="修改-CanvasFeatures"><a href="#修改-CanvasFeatures" class="headerlink" title="修改 CanvasFeatures"></a>修改 CanvasFeatures</h4><p>使用<code>flatfile-to-json.pl</code>脚本进行转换</p>
<h3 id="信号转发"><a href="#信号转发" class="headerlink" title="信号转发"></a>信号转发</h3><p>现在访问<a href="http://cotton.hzau.edu.cn/tools/jbrowse/" target="_blank" rel="noopener">http://cotton.hzau.edu.cn/tools/jbrowse/</a> 就可以显示出内网中的JBrowse</p>
<p>由于我把JBrowse放在了内网机器上，于是需要使用外网机器的Appache将内网信号转发一下；在转发后客户端找不到对应的CSS和JS文件；于是使用<code>webpack</code>重新打包了一下源代码；查看了一下webpack的配置文件，发现可以通过配置环境变量<code>JBROWSE_PUBLIC_PATH</code>的值来控制打包后的资源检索URL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    publicPath: process.env.JBROWSE_PUBLIC_PATH || <span class="string">'dist/'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>修改打包后的公共资源请求路径，打包后的文件会在<code>jbrowse/dist</code>目录下</p>
<blockquote>
<p>如果没有yarn，使用npm进行全局安装 npm i yarn -g</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JBROWSE_PUBLIC_PATH=http://cotton.hzau.edu.cn/tools/jbrowse/dist/ <span class="comment">##bund.js请求路径</span></span><br><span class="line"><span class="comment">##重新进行编译 在目录@/jbrowse下</span></span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>

<p>修改<code>@/jbrowse/index.html</code>中资源路径；其实就加个转发路径就行</p>
<p><code>sed -i &#39;s/href=\&quot;/href=\&quot;\/tools\/jbrowse\//g&#39; index.html</code></p>
<p><code>sed -i &#39;s/src=\&quot;/src=\&quot;\/tools\/jbrowse\//g&#39; index.html</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"icon"</span> <span class="built_in">type</span>=<span class="string">"image/png"</span> sizes=<span class="string">"16x16"</span> href=<span class="string">"img/favicons/favicon-16x16.png"</span>&gt;</span><br><span class="line"><span class="comment">##修改为转发后的网址</span></span><br><span class="line">&lt;link rel=<span class="string">"icon"</span> <span class="built_in">type</span>=<span class="string">"image/png"</span> sizes=<span class="string">"16x16"</span> href=<span class="string">"/tools/jbrowse/img/favicons/favicon-16x16.png"</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img data-src="https://s1.ax1x.com/2020/07/25/aSWG3q.png" alt="效果图"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.jianshu.com/p/e4a90aafc461" target="_blank" rel="noopener">最全的JBrowse基因浏览器介绍</a></li>
<li><a href="https://jbrowse.org/docs/installation.html" target="_blank" rel="noopener">官方文档</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>matplotlib-柱状图</title>
    <url>/codeHub/2020/07/23/2020-07/11matplotlib-%E6%9F%B1%E7%8A%B6%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="使用matplotlib绘图的完整流程"><a href="#使用matplotlib绘图的完整流程" class="headerlink" title="使用matplotlib绘图的完整流程"></a>使用matplotlib绘图的完整流程</h2><p>在matplotlib中存在两套画图命令：</p>
<ul>
<li>基于面向对象的方式OO</li>
<li>基于pyplot函数接口的方式</li>
</ul>
<blockquote>
<p>作者还是推荐我们使用<code>object-oriented interface</code>的方式绘制图形</p>
</blockquote>
<p>以后绘图中涉及到的一些常见操作，我用锚点标注好；以后查具体的代码也很方便</p>
<ul>
<li><a href="#旋转x轴label">旋转X轴标签</a></li>
<li><a href="#控制图片样式">修改图片样式</a>，如添加网格线等</li>
<li><a href="#给图片添加label">添加label</a></li>
<li><a href="#批量修改坐标轴刻度label">批量修改坐标轴标签</a></li>
<li><a href="#保存图片">保存图片</a></li>
</ul>
<h3 id="绘图数据"><a href="#绘图数据" class="headerlink" title="绘图数据"></a>绘图数据</h3><p>准备绘图数据，包含了几个人的收入信息吧；准备绘制一个柱状图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据字典</span></span><br><span class="line">data = &#123;<span class="string">'Barton LLC'</span>: <span class="number">109438.50</span>,</span><br><span class="line">        <span class="string">'Frami, Hills and Schmidt'</span>: <span class="number">103569.59</span>,</span><br><span class="line">        <span class="string">'Fritsch, Russel and Anderson'</span>: <span class="number">112214.71</span>,</span><br><span class="line">        <span class="string">'Jerde-Hilpert'</span>: <span class="number">112591.43</span>,</span><br><span class="line">        <span class="string">'Keeling LLC'</span>: <span class="number">100934.30</span>,</span><br><span class="line">        <span class="string">'Koepp Ltd'</span>: <span class="number">103660.54</span>,</span><br><span class="line">        <span class="string">'Kulas Inc'</span>: <span class="number">137351.96</span>,</span><br><span class="line">        <span class="string">'Trantow-Barrows'</span>: <span class="number">123381.38</span>,</span><br><span class="line">        <span class="string">'White-Trantow'</span>: <span class="number">135841.99</span>,</span><br><span class="line">        <span class="string">'Will LLC'</span>: <span class="number">104437.60</span>&#125;</span><br><span class="line"></span><br><span class="line">group_data = list(data.values()) <span class="comment">##工资</span></span><br><span class="line">group_names = list(data.keys()) <span class="comment">##人名</span></span><br><span class="line">group_mean = np.mean(group_data)  <span class="comment">## 平均值</span></span><br></pre></td></tr></table></figure>

<h3 id="创建实例对象"><a href="#创建实例对象" class="headerlink" title="创建实例对象"></a>创建实例对象</h3><p>采用面向对象的接口，生成<code>figure.Figure</code>和<code>axes.Axes</code>实例对象</p>
<ul>
<li><code>figure.Figure</code>相当于画布的作用，在上面可以绘制多个图片</li>
<li><code>axes.Axes</code>就是一副完整的图片，多个图片可以绘制在一块画布上</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots() <span class="comment">##生成实例对象</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/22/Ub5jA0.png" alt="Ub5jA0.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.barh(group_names,group_data) <span class="comment">##绘制柱状图</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/22/Ub5vNV.png" alt="Ub5vNV.png"></p>
<h3 id="控制图片样式"><a href="#控制图片样式" class="headerlink" title="控制图片样式"></a>控制图片样式</h3><p>这里相当于ggplot2里的<code>theme</code>，可以使用<code>print(plt.style.available)</code>查看系统自带的样式；使用<code>plt.style.use(&#39;样式名&#39;)</code>使用对应的样式;如下图所示，选择好样式后，就在图中添加了网格线，改变了柱子的颜色</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.style.use(<span class="string">'fivethirtyeight'</span>) <span class="comment">##选择定义好的样式</span></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.barh(group_names,group_data)</span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/22/Ub5O7q.png" alt="Ub5O7q.png"></p>
<h3 id="旋转x轴label"><a href="#旋转x轴label" class="headerlink" title="旋转x轴label"></a>旋转x轴label</h3><p>当坐标轴上的label太长的时候，两个刻度之间可能会发生重叠。因此可以通过旋转label的方法调整label的显示。<br>首先的获取坐标轴上的label对象，使用<code>pyplot.setp()</code>函数设置对应的属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.barh(group_names,group_data)</span><br><span class="line">xlabels=ax.get_xticklabels() <span class="comment">##获取坐标轴label信息</span></span><br><span class="line">plt.setp(xlabels,rotation=<span class="number">45</span>,horizontalalignment=<span class="string">'right'</span>) <span class="comment">##旋转坐标轴</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/22/Ub5qns.png" alt="Ub5qns.png"></p>
<h3 id="给图片添加label"><a href="#给图片添加label" class="headerlink" title="给图片添加label"></a>给图片添加label</h3><p>除了修改刻度线上的label，同样可以给图片的坐标轴label，图片的label，以及坐标轴显示范围。<br>所有的操作都是采用面向对象接口</p>
<ul>
<li>xlim参数修改坐标轴显示范围</li>
<li>xlabel 修改坐标轴label</li>
<li>title 修改图片label</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.barh(group_names, group_data)</span><br><span class="line">labels = ax.get_xticklabels()</span><br><span class="line">plt.setp(labels, rotation=<span class="number">45</span>, horizontalalignment=<span class="string">'right'</span>)</span><br><span class="line">ax.set(xlim=[<span class="number">-10000</span>, <span class="number">140000</span>], xlabel=<span class="string">'Total Revenue'</span>, ylabel=<span class="string">'Company'</span>,</span><br><span class="line">       title=<span class="string">'Company Revenue'</span>)  <span class="comment">#设置label</span></span><br></pre></td></tr></table></figure>




<p><img data-src="https://s1.ax1x.com/2020/07/22/Ub5LBn.png" alt="Ub5LBn.png"></p>
<h3 id="批量修改坐标轴刻度label"><a href="#批量修改坐标轴刻度label" class="headerlink" title="批量修改坐标轴刻度label"></a>批量修改坐标轴刻度label</h3><p>通过定义一个函数来处理传进来的每个label，传递的函数需要使用<code>tick</code>对象进行实例化</p>
<blockquote>
<p>报错 <a href="https://stackoverflow.com/questions/25119193/matplotlib-pyplot-axes-formatter" target="_blank" rel="noopener">https://stackoverflow.com/questions/25119193/matplotlib-pyplot-axes-formatter</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定义处理函数</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> tick</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">currency</span><span class="params">(x, pos)</span>:</span></span><br><span class="line">    <span class="string">"""The two args are the value and tick position"""</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">1e6</span>:</span><br><span class="line">        s = <span class="string">'$&#123;:1.1f&#125;M'</span>.format(x*<span class="number">1e-6</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s = <span class="string">'$&#123;:1.0f&#125;K'</span>.format(x*<span class="number">1e-3</span>)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">ax.barh(group_names, group_data)</span><br><span class="line">labels = ax.get_xticklabels()</span><br><span class="line">plt.setp(labels, rotation=<span class="number">45</span>, horizontalalignment=<span class="string">'right'</span>)</span><br><span class="line"></span><br><span class="line">ax.set(xlim=[<span class="number">-10000</span>, <span class="number">140000</span>], xlabel=<span class="string">'Total Revenue'</span>, ylabel=<span class="string">'Company'</span>,</span><br><span class="line">       title=<span class="string">'Company Revenue'</span>)</span><br><span class="line"><span class="comment">#ax.get_xaxis().get_major_formatter()</span></span><br><span class="line">ax.xaxis.set_major_formatter(tick.FuncFormatter(currency)) <span class="comment">##实例化formater函数</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/22/Ub5HXj.png" alt="Ub5HXj.png"></p>
<h3 id="组合多个axes"><a href="#组合多个axes" class="headerlink" title="组合多个axes"></a>组合多个axes</h3><p>直接操作ax对象，再使用对应的作图函数生成对应的图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax =plt.subplots(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">ax.barh(group_names,group_data)</span><br><span class="line">labels=ax.get_xticklabels()</span><br><span class="line">plt.setp(labels,rotation=<span class="number">45</span>,horizontalalignment=<span class="string">'right'</span>)</span><br><span class="line">ax.axvline(group_mean, ls=<span class="string">'--'</span>,c=<span class="string">'red'</span>) <span class="comment">##</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/22/Ub57cQ.png" alt="Ub57cQ.png"></p>
<h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>调用<code>figure</code>对象的<code>savefig</code>方法保存图片；在保存图片之前可以查看支持保存的图片格式</p>
<ul>
<li><code>transparent</code>图片背景是否透明</li>
<li><code>dpi</code> 图片清晰度</li>
<li><code>format</code> 保存格式</li>
<li><code>bbox_inches=&quot;tight&quot;</code> 图片与画布紧密排布</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(fig.canvas.get_supported_filetypes()) <span class="comment">## 查看支持保存格式</span></span><br><span class="line">fig.savefig(<span class="string">"test.pdf"</span>,format=<span class="string">"pdf"</span>, bbox_inches=<span class="string">"tight"</span>,transparent=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<pre><code>{&apos;ps&apos;: &apos;Postscript&apos;, &apos;eps&apos;: &apos;Encapsulated Postscript&apos;, &apos;pdf&apos;: &apos;Portable Document Format&apos;, &apos;pgf&apos;: &apos;PGF code for LaTeX&apos;, &apos;png&apos;: &apos;Portable Network Graphics&apos;, &apos;raw&apos;: &apos;Raw RGBA bitmap&apos;, &apos;rgba&apos;: &apos;Raw RGBA bitmap&apos;, &apos;svg&apos;: &apos;Scalable Vector Graphics&apos;, &apos;svgz&apos;: &apos;Scalable Vector Graphics&apos;, &apos;jpg&apos;: &apos;Joint Photographic Experts Group&apos;, &apos;jpeg&apos;: &apos;Joint Photographic Experts Group&apos;, &apos;tif&apos;: &apos;Tagged Image File Format&apos;, &apos;tiff&apos;: &apos;Tagged Image File Format&apos;}</code></pre>]]></content>
  </entry>
  <entry>
    <title>D3js-数据可视化神器</title>
    <url>/codeHub/2020/07/21/2020-07/10D3js-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<p>最近准备把一些数据可视化一下，打算使用前端的<code>d3.js</code>库。这个库的全称也被称为<strong>Data-Driven Document</strong>，顾名思义，基于数据驱动文档，这一概念和Vue的设计思想很类似。<code>d3.js</code>下面统称为<strong>D3</strong>；一直以来是神一般的库的存在；尽管已经有许多优秀的库例如百度的<code>echaet</code>等；但是<strong>D3</strong>与其他的库相比在于，提供了无限定制的能力，让你的想象力尽情的发挥；在交互性上做的同样优秀。</p>
<p>~~感受一波</p>
<p><img data-src="https://picb.zhimg.com/v2-bf6c58a9284672cecc16c645e69f85c4_b.webp" alt="d3js案例"></p>
<a id="more"></a>

<h4 id="D3的需要的入门知识："><a href="#D3的需要的入门知识：" class="headerlink" title="D3的需要的入门知识："></a>D3的需要的入门知识：</h4><ol>
<li>SVG</li>
<li>css</li>
<li>JavaScript</li>
</ol>
<p>看完大佬们的博客，感觉<strong>D3</strong>的学习成本还是很高的，不过毕竟是神一样的包，肯定涉及到很多知识点，以后慢慢学习的过程查漏补缺吧。下面这张图就把一个学习的过程总结的很好，我觉得太生动了；还是站在巨人的肩膀上，躺着比较舒服，我也喜欢躺。</p>
<ol>
<li><p><img data-src="https://pic4.zhimg.com/80/v2-200a3d892a637679fdc5239e93f27bbc_720w.jpg" alt="学习过程"></p>
</li>
</ol>
<h2 id="scale-vector-graphics-SVG-学习"><a href="#scale-vector-graphics-SVG-学习" class="headerlink" title="scale vector graphics (SVG)学习"></a>scale vector graphics (SVG)学习</h2><p>可缩放的矢量图，svg标签内的限制条件</p>
<blockquote>
<ul>
<li>图片必须在<code>svg</code>标签内</li>
<li>svg指定高度和宽度，也可以使用百分比；继承父元素宽度</li>
<li>svg中可以绘制多个图片</li>
</ul>
</blockquote>
<p>svg中可使用预先设置好的一系列标签；</p>
<ul>
<li>矩形 <code>rect</code></li>
<li>圆形<code>circle</code></li>
<li>椭圆 <code>ellipse</code></li>
<li>线 <code>line</code></li>
<li>折线 <code>polyline</code></li>
<li>多边形 <code>polygon</code></li>
<li>路径 <code>path</code></li>
</ul>
<h3 id="快速生成一个圆"><a href="#快速生成一个圆" class="headerlink" title="快速生成一个圆"></a>快速生成一个圆</h3><p><svg width="200" height="200"><circle cx="100" cy="100" r="100" stroke="black" stroke-width="2" fill="red" /></svg></p>
<ul>
<li>使用<code>circle</code>标签表示生成圆形</li>
<li><code>cx|cy</code>圆心的位置，不指定则为0,0</li>
<li><code>stroke</code>外圆边框颜色及厚度</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"400"</span> height=<span class="string">"400"</span>&gt;</span><br><span class="line">  &lt;circle cx=<span class="string">"200"</span> cy=<span class="string">"200"</span> r=<span class="string">"100"</span> stroke=<span class="string">"black"</span> stroke-width=<span class="string">"2"</span> fill=<span class="string">"red"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="快速生成一个矩形"><a href="#快速生成一个矩形" class="headerlink" title="快速生成一个矩形"></a>快速生成一个矩形</h3><svg width="100" height="100">
      <rect width="100" height="100" stroke="black" stroke-width="2" style="fill: red" />
    </svg>


<ul>
<li>width 矩形长</li>
<li>height 矩形宽</li>
<li>stroke 矩形边框</li>
<li>stroke-width 矩形边框宽度</li>
<li>style 指定矩形样式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"400"</span> height=<span class="string">"400"</span>&gt;</span><br><span class="line">  &lt;rect width=<span class="string">"100"</span> height=<span class="string">"100"</span> stroke=<span class="string">"black"</span> stroke-width=<span class="string">"2"</span> style=<span class="string">"fill: red"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="快速生成一个椭圆"><a href="#快速生成一个椭圆" class="headerlink" title="快速生成一个椭圆"></a>快速生成一个椭圆</h3><svg width="200" height="200">
      <ellipse
        cx="100"
        cy="100"
        rx="100"
        ry="50"
        stroke="black"
        stroke-width="2"
        style="fill: red"
      />
    </svg>


<ul>
<li>rx 定义水平半径</li>
<li>ry 定义垂直半径</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"400"</span> height=<span class="string">"400"</span>&gt;</span><br><span class="line">  &lt;ellipse</span><br><span class="line">    cx=<span class="string">"150"</span></span><br><span class="line">    cy=<span class="string">"100"</span></span><br><span class="line">    rx=<span class="string">"100"</span></span><br><span class="line">    ry=<span class="string">"50"</span></span><br><span class="line">    stroke=<span class="string">"black"</span></span><br><span class="line">    stroke-width=<span class="string">"2"</span></span><br><span class="line">    style=<span class="string">"fill: red"</span></span><br><span class="line">  /&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="快速生成一个线条"><a href="#快速生成一个线条" class="headerlink" title="快速生成一个线条"></a>快速生成一个线条</h3><svg width="200" height="200">
      <line 
        x1="150"
        y1="100"
        x2="100"
        y2="50"
        stroke="red" 
        stroke-width="2" />
    </svg>


<ul>
<li>x1 和x2 x轴的开始和结束</li>
<li>y1和y2  y轴的开始和结束</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"400"</span> height=<span class="string">"400"</span>&gt;</span><br><span class="line">  &lt;line </span><br><span class="line">    x1=<span class="string">"150"</span></span><br><span class="line">    y1=<span class="string">"100"</span></span><br><span class="line">    x2=<span class="string">"100"</span></span><br><span class="line">    y2=<span class="string">"50"</span></span><br><span class="line">    stroke=<span class="string">"black"</span> </span><br><span class="line">    stroke-width=<span class="string">"2"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="快速生成一个多边形"><a href="#快速生成一个多边形" class="headerlink" title="快速生成一个多边形"></a>快速生成一个多边形</h3>  <svg width="300" height="300">
      <polygon
        points="220,100 300,210 170,250"
        style="fill:#cccccc;
        stroke:#000000;stroke-width:1"
      />
    </svg>



<p>定义了6个角的位置，将会生成一个三角形</p>
<ul>
<li>points 定义了每个角的坐标轴位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    &lt;svg width=<span class="string">"400"</span> height=<span class="string">"400"</span>&gt;</span><br><span class="line">      &lt;polygon</span><br><span class="line">        points=<span class="string">"220,100 300,210 170,250"</span></span><br><span class="line">        style=<span class="string">"fill:#cccccc;</span></span><br><span class="line"><span class="string">stroke:#000000;stroke-width:1"</span></span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="快速生成一个折线图"><a href="#快速生成一个折线图" class="headerlink" title="快速生成一个折线图"></a>快速生成一个折线图</h4><svg width="100" height="100">
      <polyline
        points="0,0 0,20 20,20 20,40 40,40 40,60"
        style="fill:black;stroke:red;stroke-width:2"
      />
 </svg>


<ul>
<li>points同样定义了每个折点的坐标</li>
<li>fill 这个填充区域还有点迷惑</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"400"</span> height=<span class="string">"400"</span>&gt;</span><br><span class="line">  &lt;polyline</span><br><span class="line">    points=<span class="string">"0,0 0,20 20,20 20,40 40,40 40,60"</span></span><br><span class="line">    style=<span class="string">"fill:white;stroke:red;stroke-width:2"</span></span><br><span class="line">  /&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="快速生成一个路径图"><a href="#快速生成一个路径图" class="headerlink" title="快速生成一个路径图"></a>快速生成一个路径图</h3><svg width="400" height="400" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M250 150 L150 350 L350 350 Z" style="fill:white;stroke:red;stroke-width:2" />
    </svg>

<p>从250，150出发，到150,350；再到350,350；最后回到原点，生成了一个三角形。</p>
<blockquote>
<p>推荐使用SVG编辑器来编辑路径图</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"100%"</span> height=<span class="string">"100%"</span> version=<span class="string">"1.1"</span> xmlns=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span><br><span class="line">  &lt;path d=<span class="string">"M250 150 L150 350 L350 350 Z"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.w3school.com.cn/svg/index.asp" target="_blank" rel="noopener">SVG</a></li>
<li><a href="https://juejin.im/post/5d1e074af265da1bca51f8ec" target="_blank" rel="noopener">d3js</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/38001672" target="_blank" rel="noopener">D3学习之路-知乎</a></li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>node搭建后台</title>
    <url>/codeHub/2020/07/20/2020-07/09node%E5%90%8E%E5%8F%B0/</url>
    <content><![CDATA[<p>最近在使用<code>SMTP</code>邮件系统的时候，用的是网易163的账号，结果账号被封了导致服务器在给用户批量发送邮件时失败，而且又没有报错提示，整的我一脸懵逼。出于无奈，我使用之前学习的<code>node</code>、<code>mysql</code>知识搭建了一个后台系统；再使用<code>APPache</code>反向代理将内网中node服务器信息，转发到公网服务器。同时node操作<code>mysql</code>时，使用到了之前学习的<code>Promise</code>知识 ，解决了异步操作的问题。涉及到的知识点主要包含以下方面：</p>
<ol>
<li><code>log4js</code>记录node日志</li>
<li><code>PowerDesigner</code>设计数据表</li>
<li><code>Promise</code>解决mysql异步操作</li>
</ol>
<p><img data-src="https://cdn.dribbble.com/users/285475/screenshots/2083086/dribbble_1.gif" alt="404"></p>
<a id="more"></a>

<h3 id="1-log4js记录日志"><a href="#1-log4js记录日志" class="headerlink" title="1.log4js记录日志"></a>1.log4js记录日志</h3><p>使用npm 下载<code>log4js</code>插件后，配置对应的信息。</p>
<p>这里我使用了两个记录器：</p>
<ul>
<li>按照天数记录node运行日志</li>
<li>同时将日志打印到标准输出</li>
</ul>
<p>最终生成的文件将会以<code>log_date.2020-07-20.log</code>文件的形式进行保存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">'log4js'</span>)</span><br><span class="line">log4js.configure(&#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    dateFile: &#123;</span><br><span class="line">      type: <span class="string">'dateFile'</span>,</span><br><span class="line">      filename: path.join(__dirname, <span class="string">'../logs/log_date'</span>),</span><br><span class="line">      alwaysIncludePattern: <span class="literal">true</span>,</span><br><span class="line">      pattern: <span class="string">'yyyy-MM-dd.log'</span>,</span><br><span class="line">      compress: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    out: &#123;</span><br><span class="line">      type: <span class="string">'stdout'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123; <span class="attr">appenders</span>: [<span class="string">'dateFile'</span>, <span class="string">'out'</span>], <span class="attr">level</span>: <span class="string">'trace'</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="2-PowerDesigner设计数据表"><a href="#2-PowerDesigner设计数据表" class="headerlink" title="2.PowerDesigner设计数据表"></a>2.<code>PowerDesigner</code>设计数据表</h3><p>使用<code>powerDeigner</code>这个神器，省的我自己去写sql代码生成对应的表；整个软件通过图形化的方式，构造表与表之间的关系和字段的数据类型，字段的约束、主键等。</p>
<p>图中构造了两个表，其中学生表中<code>年级</code>字段与级别表存在关联；并且每个字段都标明了对应的数据类型和范围。最终以鼠标的方式就可以生成sql语句。</p>
<p><img data-src="https://s1.ax1x.com/2020/07/20/U4c5zF.png" alt="表设计"></p>
<h3 id="3-Promise解决异步操作"><a href="#3-Promise解决异步操作" class="headerlink" title="3.Promise解决异步操作"></a>3.Promise解决异步操作</h3><p>由于JavaScript单线程的性质，导致异步操作时很难保证sql查询的顺序；而Promise则能够确保查询语句按照固定的顺序执行。首先使用<code>mysql</code>配置mysql账号和密码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sqlconnection = mysql.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  user: <span class="string">'zpliu'</span>,</span><br><span class="line">  password: <span class="string">'123456'</span>,</span><br><span class="line">  port: <span class="number">3306</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  connection: sqlconnection,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装Promise对象</p>
<p>当用户发起请求时，对mysql进行查询；将mysql对象、sql语句以及中间件传递给函数；如果Promise在执行过程中遇到了错误，则调用<code>logger</code>函数将错误写入到日志文件中；如果正常执行时则继续返回一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sqlQueryPromise</span>(<span class="params">sqlConnecion, sql, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, NULL</span>) =&gt;</span> &#123;</span><br><span class="line">    sqlConnecion.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        logger.error(</span><br><span class="line">          <span class="string">'sql language error: errcode:'</span> + err.errno + <span class="string">'\t`'</span> + err.sql + <span class="string">'`'</span></span><br><span class="line">        )</span><br><span class="line">        next(&#123;</span><br><span class="line">          code: err.errno,</span><br><span class="line">        &#125;) <span class="comment">//sql language error</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      resolve(result)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应客户端请求</p>
<p>在响应客户端请求时，涉及到两个sql循环，并且必须等第一个查询成功执行才能够进入到第二个查询语句。</p>
<p>进入第二个查询语句后，再将结果返回给客户端</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/people/update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    sql=<span class="string">'*****'</span></span><br><span class="line">  sqlQueryPromise(mysqlconnection, <span class="string">`use <span class="subst">$&#123;DataBase&#125;</span>;`</span>, next)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sqlQueryPromise(mysqlconnection, sql, next)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      res.json(&#123; <span class="attr">code</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-API测试"><a href="#4-API测试" class="headerlink" title="4.API测试"></a>4.API测试</h3><p>最后我把node后台API，放在了以下地址</p>
<blockquote>
<p><a href="http://cotton.hzau.edu.cn/web/" target="_blank" rel="noopener">http://cotton.hzau.edu.cn/web/</a></p>
</blockquote>
<p>API中包含了简单的<code>增删改查</code></p>
<p>例如请求 <code>http://cotton.hzau.edu.cn/web/people</code>地址时；浏览器将会返回以下数据,感兴趣的话可以试一试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">"id"</span>:<span class="number">10</span>,</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"好好学习"</span>,</span><br><span class="line">  <span class="string">"photo"</span>:<span class="string">"天天向上"</span>,</span><br><span class="line">  <span class="string">"sex"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="string">"introduction"</span>:<span class="literal">null</span>,</span><br><span class="line">  <span class="string">"email"</span>:<span class="string">"19445322210@qq.com"</span>,</span><br><span class="line">  <span class="string">"grade"</span>:<span class="string">"Ph.D"</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>最后再拿到后台给的数据后，接下来的工作就是交给前端进行数据的渲染啦！今天通过整理之前学的一些node知识；把代码和文件夹规范了不少，之后就在这个基础上进行后端的开发。前端的内容等过一段时间再规范一下；准备使用node做后端API接口负责数据的存取；Vue负责前端的数据渲染和路由跳转。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.cnblogs.com/biehongli/p/6025954.html" target="_blank" rel="noopener">powerDesigner使用</a></li>
<li><a href="https://biocottonhub.github.io/codeHub/2020/04/19/2020-06%E4%BB%A5%E5%89%8D/23Promise%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Promise异步</a></li>
<li><a href="https://blog.csdn.net/lxhjh/article/details/50747642" target="_blank" rel="noopener">log4js</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib-image</title>
    <url>/codeHub/2020/07/16/2020-07/07matplotlib-image/</url>
    <content><![CDATA[<p>本教程主要讲，如何使用matplotlib绘制image图片；这里的<code>image</code>不是我们平时见到的RGB编码的图片，matplotlib绘制的<code>image</code>是基于矩阵数据进行绘制的；也可以将RGB的图片转码成numpy矩阵，然后对矩阵进行操作就</p>
<blockquote>
<p>需要注意的是matplotlib中只支持png图片的加载，如果要获得其他类型图片的数据，则需要<code>Pillow</code>包的支持</p>
</blockquote>
<a id="more"></a>

<h3 id="下面让我们来对这张小虫子的图片来一番操作"><a href="#下面让我们来对这张小虫子的图片来一番操作" class="headerlink" title="下面让我们来对这张小虫子的图片来一番操作"></a>下面让我们来对这张小虫子的图片来一番操作</h3><p><img data-src="https://matplotlib.org/_images/stinkbug.png" alt="虫子"></p>
<blockquote>
<p> RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是运用最广的颜色系统之一。&lt;引自百度百科&gt;</p>
</blockquote>
<p>这是一种RGB的PNG图片，它的分辨率为500x375;通俗的讲就是这张PNG的图片数据包含有<code>500X375</code>个点；每个点通过一个RGB代码表示出一种颜色。这张图片的每个点是一个24位的二进制代码,其中每8位二进制代码表示一个颜色的编码；如果是RGB是32位的编码的话，matplotlib会将它缩放到24位，在计算每种颜色的编码，颜色编码范围在<code>0~1</code>之间。</p>
<p>例如通过matplotlib读取png图片后，每个像素的RGB代码表示成一个数组<code>[0.40784314 0.40784314 0.40784314]</code></p>
<p>​                                        </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mping </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">导入Image 所需要的包</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">img=mping.imread(<span class="string">"../stinkbug.png"</span>)</span><br><span class="line"><span class="comment">#print(img.shape)</span></span><br><span class="line"><span class="comment">#(375, 500, 3)</span></span><br><span class="line">print(img)</span><br></pre></td></tr></table></figure>

<pre><code>[[[0.40784314 0.40784314 0.40784314]
  [0.40784314 0.40784314 0.40784314]
  [0.40784314 0.40784314 0.40784314]
  ...
  [0.42745098 0.42745098 0.42745098]
  [0.42745098 0.42745098 0.42745098]
  [0.42745098 0.42745098 0.42745098]]
]]</code></pre><h3 id="打印矩阵数据"><a href="#打印矩阵数据" class="headerlink" title="打印矩阵数据"></a>打印矩阵数据</h3><p>在使用<code>mping.imread</code>获取到PNG图片的编码矩阵后，可以使用<code>plt.imshow()</code>将矩阵数据显示成图片，并且多了两个坐标轴，坐标轴的刻度是以像素为单位的。</p>
<ul>
<li>横坐标是图片原始的宽度</li>
<li>纵坐标是图片高度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.imshow(img) <span class="comment">##显示图片</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/16/UBLaBq.png" alt="UBLaBq.png"></p>
<h3 id="对原始矩阵进行操作"><a href="#对原始矩阵进行操作" class="headerlink" title="对原始矩阵进行操作"></a>对原始矩阵进行操作</h3><ul>
<li>截取部分图片</li>
<li>改变图片原始的RGB代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">##截取200行，400列的矩阵；实际上相当于图片高度变成200，宽度变成400</span></span><br><span class="line">plt.imshow(img[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">600</span>,]) <span class="comment">##矩阵的切片操作</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/16/UBLJ3Q.png" alt="UBLJ3Q.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 改变RGB编码，我这里只截取了RGB数组中的一个维度</span></span><br><span class="line"><span class="comment">## 对于图片大小我没有进行修改</span></span><br><span class="line">plt.imshow(img[:,:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/16/UBLUun.png" alt="UBLUun.png"></p>
<h3 id="将颜色进行映射"><a href="#将颜色进行映射" class="headerlink" title="将颜色进行映射"></a>将颜色进行映射</h3><p>如果你的每个像素点中，只有一个数字代表它是什么颜色，同样可以使用<code>imshow</code>函数中封装好的映射函数将一维的数据映射成3维的数据点</p>
<p>例如我将img矩阵中的RGB编码，压缩到一维空间，再使用<code>cmap=hot</code>，&lt; color maping &gt;的缩写将一维空间重新映射到三维空间后的图片，搞了两种映射。<br>既可以使用函数中的参数进行设置，也可以使用对象的属性进行设置</p>
<ul>
<li><code>Greys</code>这个有点像x光片</li>
<li><code>hot</code> 这个有点像热成像</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.imshow(img[:,:,<span class="number">1</span>],cmap=<span class="string">'Greys'</span>) <span class="comment">##按照灰色进行映射</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/16/UBLtjs.png" alt="UBLtjs.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imgplot=plt.imshow(img[:,:,<span class="number">1</span>]) <span class="comment">##返回一个image对象</span></span><br><span class="line">imgplot.set_cmap(<span class="string">'hot'</span>)  <span class="comment">##调用属性进行设置hot映射</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/16/UBLYcj.png" alt="UBLYcj.png"></p>
<h3 id="添加图例，描述颜色深浅"><a href="#添加图例，描述颜色深浅" class="headerlink" title="添加图例，描述颜色深浅"></a>添加图例，描述颜色深浅</h3><p>直接使用<code>plt.colorbar()</code>函数即可；<br>当然有时候我们可以通过设置颜色映射时的上下限，来增加我们感兴趣的地方的对比度；从而突出重点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imgplot=plt.imshow(img[:,:,<span class="number">1</span>]) <span class="comment">##返回一个image对象</span></span><br><span class="line">imgplot.set_cmap(<span class="string">'nipy_spectral'</span>)  <span class="comment">##调用属性进行设置hot映射</span></span><br><span class="line">plt.colorbar()  <span class="comment">##添加图例</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/16/UBL0EV.png" alt="UBL0EV.png"></p>
<h3 id="改变颜色映射规则"><a href="#改变颜色映射规则" class="headerlink" title="改变颜色映射规则"></a>改变颜色映射规则</h3><p>当然有时候我们可以通过设置颜色映射时的上下限，来增加我们感兴趣的地方的对比度；从而突出重点<br>使用<code>clim</code>函数进行操作，同样可以使用对象的方法<code>set_clim</code></p>
<p>在设置了颜色的映射范围之后，增强你感兴趣的地方的对比度；可以发现在经过调整后，B图中有些peak值出，对比度更亮了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig=plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>)) <span class="comment">##创建一个画板</span></span><br><span class="line">a=plt.subplot2grid((<span class="number">1</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">0</span>),rowspan=<span class="number">1</span>,colspan=<span class="number">1</span>) <span class="comment">##创建一个图层</span></span><br><span class="line">imgplot=plt.imshow(img[:,:,<span class="number">1</span>])</span><br><span class="line">a.set_title(<span class="string">'Before'</span>)</span><br><span class="line">plt.colorbar(ticks=[<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.7</span>], orientation=<span class="string">'horizontal'</span>) <span class="comment">##设置图例位置和刻度线</span></span><br><span class="line">b=plt.subplot2grid((<span class="number">1</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">1</span>),rowspan=<span class="number">1</span>,colspan=<span class="number">1</span>) <span class="comment">## 创建一个图层</span></span><br><span class="line">imgplot=plt.imshow(img[:,:,<span class="number">1</span>])</span><br><span class="line">imgplot.set_clim(<span class="number">0</span>,<span class="number">0.7</span>)</span><br><span class="line">b.set_title(<span class="string">'After'</span>)</span><br><span class="line">plt.colorbar(ticks=[<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.7</span>], orientation=<span class="string">'horizontal'</span>)</span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/16/UBLD4U.png" alt="UBLD4U.png"></p>
<h3 id="打马赛克"><a href="#打马赛克" class="headerlink" title="打马赛克"></a>打马赛克</h3><p>使用<code>Pillow</code>包对图片的RGB数据进行扰动。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install pillow</span><br></pre></td></tr></table></figure>

<p>例如当图片像素发生改变时，必然会有像素点的丢失和新像素点的获得。在保持图片的整体特征不变的情况下，对图片的像素点进行处理方案又有好多种；在图片缩小时，丢弃掉一些像素点；在图片放大时，插入一些像素点。</p>
<p>这里借助<code>pillow</code>包将图片缩小64x48个像素；但是当你以原有的尺寸来看这张图片，就相当于打了一层马赛克；因为有原图中的一些像素被丢弃了。如果图片缩写这看，估计也就是个缩略图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = Image.open(<span class="string">'../stinkbug.png'</span>)</span><br><span class="line">print(img.size)</span><br><span class="line">(<span class="number">500</span>, <span class="number">375</span>)</span><br><span class="line">img.thumbnail((<span class="number">64</span>, <span class="number">64</span>), Image.ANTIALIAS)  <span class="comment"># resizes image in-place</span></span><br><span class="line">print(img.size)</span><br><span class="line"><span class="comment">#(64, 48)</span></span><br><span class="line">imgplot = plt.imshow(img)</span><br><span class="line">fig=plt.figure(figsize=(<span class="number">0.64</span>,<span class="number">0.48</span>))</span><br><span class="line">imgplot = plt.imshow(img)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/07/16/UBLBNT.png" alt="UBLBNT.png"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://matplotlib.org/tutorials/introductory/images.html#sphx-glr-tutorials-introductory-images-py" target="_blank" rel="noopener">matplotlib</a></li>
<li><a href="https://www.cnblogs.com/Sinte-Beuve/p/6573246.html" target="_blank" rel="noopener">数组切片</a></li>
<li><a href="https://blog.csdn.net/MiniCatTwo/article/details/80557109" target="_blank" rel="noopener">pillow</a></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>TAD的鉴定方法（一）——cool格式的转换</title>
    <url>/codeHub/2020/07/13/2020-07/07TAD%E7%9A%84%E9%89%B4%E5%AE%9A%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94cool%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="TAD的鉴定方法（一）——cool格式的转换"><a href="#TAD的鉴定方法（一）——cool格式的转换" class="headerlink" title="TAD的鉴定方法（一）——cool格式的转换"></a>TAD的鉴定方法（一）——cool格式的转换</h1><p>上次我们使用HiC-Pro将HiC数据比对到了参考基因组上，并且得到了bin水平的HiC数据（交互文件），我们这里介绍一下TAD的鉴定方法（使用HiCPeaks和TADLib中的两个程序），大致分为以下两步（我们会分）</p>
<ul>
<li>cool格式的转换</li>
<li>TAD的鉴定</li>
</ul>
<p>注：TAD的相关介绍请看本博客之前的文章：三维基因组之TAD的形成机制以及其特征</p>
<a id="more"></a>

<h2 id="1-cool格式的转化——HiCPeaks"><a href="#1-cool格式的转化——HiCPeaks" class="headerlink" title="1.cool格式的转化——HiCPeaks"></a>1.cool格式的转化——HiCPeaks</h2><p>HiC-Pro所得到的bin水平的HiC数据是TXT/NPZ bin水平的HiC数据，不能直接进行TAD的鉴定，HiCPeaks中的toCooler是将TXT/NPZ bin水平的HiC数据转化成cool格式，以便后续的分析。</p>
<h3 id="1-1-HiCPeaks的安装"><a href="#1-1-HiCPeaks的安装" class="headerlink" title="1.1 HiCPeaks的安装"></a>1.1 HiCPeaks的安装</h3><p>HiCPeaks的安装需要使用conda进行，操作也十分的简单</p>
<ul>
<li>其需要一些python要求 <code>Python 2.7/3.5+、Multiprocess、Numpy、Scipy、Matplotlib、Pandas、Statsmodels、Scikit-Learn、H5py、Cooler</code></li>
<li>还需要<code>ucsc-fetchchromsizes</code></li>
</ul>
<p>具体安装操作如下</p>
<p>首先设置通道，使上面列出的所有包都可访问(注意，顺序很重要，以确保正确的优先级)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channels defaults</span><br><span class="line">conda config --add channels bioconda</span><br><span class="line">conda config --add channels conda-forge</span><br></pre></td></tr></table></figure>

<p>然后就进行依赖的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install numpy scipy matplotlib pandas statsmodels scikit-learn h5py multiprocess cooler ucsc-fetchchromsizes</span><br></pre></td></tr></table></figure>

<p>最后进行hicpeaks的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<h3 id="1-2-HiCPeakst之oCooler的使用"><a href="#1-2-HiCPeakst之oCooler的使用" class="headerlink" title="1.2 HiCPeakst之oCooler的使用"></a>1.2 HiCPeakst之oCooler的使用</h3><h4 id="1-2-1-原始数据的处理"><a href="#1-2-1-原始数据的处理" class="headerlink" title="1.2.1 原始数据的处理"></a>1.2.1 原始数据的处理</h4><p>首先我们依据bin的编号文件<code>Ga_1_40000_abs.bed</code>将交互文件<code>Ga_1_40000.matrix</code>进行处理，提取出来研究中关注的两条染色体的交互数据，这里就以染色体内的交互进行说明（以前五号染色体为例）</p>
<p><code>Ga_1_40000_abs.bed</code>文件内容如下，四列分别是：染色体编号、bin起始、bin终止、bin编号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chr01   0       40000   1</span><br><span class="line">Chr01   40000   80000   2</span><br><span class="line">Chr01   80000   120000  3</span><br><span class="line">Chr01   120000  160000  4</span><br><span class="line">Chr01   160000  200000  5</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里我们需要批量提取所有的染色体起始和终止bin的编号，可以用bash脚本实现，脚本如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5 	<span class="comment">#提取每个染色体的起始和终止bin编号 </span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">grep <span class="string">"Chr0"</span><span class="variable">$i</span><span class="string">""</span> Ga_1_40000_abs.bed|awk <span class="string">'NR==1&#123;printf "'</span><span class="variable">$i</span><span class="string">'" "\t" $4 "\t"&#125;END&#123;print $4&#125;'</span>&gt;&gt;Ga.bed</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>然后我们就根据染色体的起始和终止编号进行染色体内交互的提取</p>
<p><code>Ga_1_40000.matrix</code>文件如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1       1       75</span><br><span class="line">1       2       112</span><br><span class="line">1       3       93</span><br><span class="line">1       4       33</span><br><span class="line">1       5       18</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>交互提取的bash脚本如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=($(cut -f2 Ga.bed))	<span class="comment">#bed文件是每个染色体的起始和终止bin编号</span></span><br><span class="line">b=($(cut -f3 Ga.bed))</span><br><span class="line">mkdir 40K <span class="comment">#交互文件要放进这个文件夹里，文件夹得命名为bin的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 5)	<span class="comment">#生成每个染色体内的交互文件命名为 染色体号_染色体号.txt（染色体号为自然数字1、2、3...），并且让bin编号从0开始（这个很重要）</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">awk -v x=<span class="variable">$&#123;a[i-1]&#125;</span> -v y=<span class="variable">$&#123;b[i-1]&#125;</span> <span class="string">'&#123;if(x&lt;=$1&amp;&amp;$1&lt;=y&amp;&amp;$2&gt;=x&amp;&amp;$2&lt;=y)&#123;print $0&#125;&#125;'</span> Ga_1_40000.matrix |awk -v x=<span class="variable">$&#123;a[i-1]&#125;</span> <span class="string">'&#123;print $1-x "\t" $2-x "\t" $3&#125;'</span>  &gt;./40K/<span class="string">"<span class="variable">$i</span>"</span>_<span class="string">"<span class="variable">$i</span>"</span>.txt</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>至此，原始文件的处理就结束了。</p>
<h4 id="1-2-2染色体大小文件的获取"><a href="#1-2-2染色体大小文件的获取" class="headerlink" title="1.2.2染色体大小文件的获取"></a>1.2.2染色体大小文件的获取</h4><p>我们需要创建一个文档记录交互文件中涉及染色体的大小，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	123408337</span><br><span class="line">2	115147059</span><br><span class="line">3	139243608</span><br><span class="line">4	122505728</span><br><span class="line">5	93157762</span><br></pre></td></tr></table></figure>

<p>染色体大小的获得可以用如下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">samtools faidx &#x2F;Ga.ref&#x2F;Ga.fasta</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3配置文件的书写"><a href="#1-2-3配置文件的书写" class="headerlink" title="1.2.3配置文件的书写"></a>1.2.3配置文件的书写</h4><p>我们还需要创建一个文件，命名为<code>datasets</code>，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res:40000</span><br><span class="line">  .&#x2F;40K</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行是指定分辨率（bin的大小）</li>
<li>第二行是指定交互文件所在的文件夹（绝对路径、相对路径都可以）</li>
</ul>
<p>到现在为止我们的准备工作就正式完成啦，我们得到的文件目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 40K</span><br><span class="line">│   ├── 1_1.txt</span><br><span class="line">│   ├── 2_2.txt</span><br><span class="line">│   ├── 3_3.txt</span><br><span class="line">│   ├── 4_4.txt</span><br><span class="line">│   └── 5_5.txt</span><br><span class="line">├── datasets</span><br><span class="line">└── Ga.fasta.size</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-程序的运行"><a href="#1-2-4-程序的运行" class="headerlink" title="1.2.4 程序的运行"></a>1.2.4 程序的运行</h4><p>命令很简单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">toCooler -O Ga.40000.cool -d datasets --chromsizes-file Ga.fasta.size --nproc 1</span><br><span class="line"><span class="comment"># 主要参数解释如下</span></span><br><span class="line"><span class="comment"># -O cooler文件的输出路径及名称</span></span><br><span class="line"><span class="comment"># -d 指定配置文件datasets</span></span><br><span class="line"><span class="comment"># --chromsizes-file 指定染色体大小文件</span></span><br><span class="line"><span class="comment"># --nproc ICE时使用的进程数</span></span><br><span class="line"><span class="comment"># --no-balance 跳过ICE平衡</span></span><br><span class="line"><span class="comment"># --logFile 指定log文件名</span></span><br></pre></td></tr></table></figure>

<hr>
<p>好了至此我们的cool格式转化就完成了，程序成功运行之后就会生成一个二进制cool文件<code>A2.40000.cool</code>，这个文件就是我们接下来进行TAD鉴定的输入文件，下一篇我们将会详细介绍使用TADLib去进行TAD的鉴定。</p>
<ul>
<li>参考 Github <a href="https://github.com/XiaoTaoWang/HiCPeaks" target="_blank" rel="noopener">https://github.com/XiaoTaoWang/HiCPeaks</a></li>
</ul>
]]></content>
      <categories>
        <category>Hi-C</category>
      </categories>
  </entry>
  <entry>
    <title>TAD的鉴定方法（二）——TAD的鉴定</title>
    <url>/codeHub/2020/07/13/2020-07/08TAD%E7%9A%84%E9%89%B4%E5%AE%9A%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94TAD%E7%9A%84%E9%89%B4%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="TAD的鉴定方法（二）——TAD的鉴定"><a href="#TAD的鉴定方法（二）——TAD的鉴定" class="headerlink" title="TAD的鉴定方法（二）——TAD的鉴定"></a>TAD的鉴定方法（二）——TAD的鉴定</h1><p>上一篇文章我们详细介绍了cool格式的转化，格式的转化是为了更好地进行数据的分析，这次，我们就来详细学习使用TADLib进行TAD的鉴定。</p>
<a id="more"></a>

<h2 id="2-TAD的鉴定——TADLib的使用"><a href="#2-TAD的鉴定——TADLib的使用" class="headerlink" title="2.TAD的鉴定——TADLib的使用"></a>2.TAD的鉴定——TADLib的使用</h2><h3 id="2-1-TADLib的安装"><a href="#2-1-TADLib的安装" class="headerlink" title="2.1 TADLib的安装"></a>2.1 TADLib的安装</h3><p>TADLib的安装可以使用conda进行，操作也十分的简单</p>
<ul>
<li>其需要一些python要求 <code>Python 3.5+、Numpy、Scipy、Matplotlib、Scikit-Learn、H5py、Cooler、pomegranate 0.10.0+、networkx 1.x (not compatible with networkx 2.0 yet)</code></li>
</ul>
<p>具体安装操作如下</p>
<p>首先设置通道，使上面列出的所有包都可访问(注意，顺序很重要，以确保正确的优先级)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channels defaults</span><br><span class="line">conda config --add channels bioconda</span><br><span class="line">conda config --add channels conda-forge</span><br></pre></td></tr></table></figure>

<p>然后就进行依赖的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install setuptools numpy scipy matplotlib scikit-learn cooler pomegranate=0.10.0 networkx=1</span><br></pre></td></tr></table></figure>

<p>最后进行TADLib的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install TADLib</span><br></pre></td></tr></table></figure>

<h3 id="1-2-TADLib之Hierarchical-TAD的使用"><a href="#1-2-TADLib之Hierarchical-TAD的使用" class="headerlink" title="1.2 TADLib之Hierarchical TAD的使用"></a>1.2 TADLib之Hierarchical TAD的使用</h3><h4 id="1-2-1-初始文件的准备"><a href="#1-2-1-初始文件的准备" class="headerlink" title="1.2.1 初始文件的准备"></a>1.2.1 初始文件的准备</h4><p>初始输入文件为cool格式的交互文件，cool文件的获取推荐使用HiC-Pro+HiCPeaks来获得，之前的文章都有介绍。</p>
<h4 id="1-2-2-配置文件的书写"><a href="#1-2-2-配置文件的书写" class="headerlink" title="1.2.2 配置文件的书写"></a>1.2.2 配置文件的书写</h4><p>我们需要一个配置文件去指定分辨率、重复标签和cool URI信息，命名为<code>meta_file</code></p>
<p>文件规范格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res:40000</span><br><span class="line">  rep1:&#x2F;HiC&#x2F;A2&#x2F;TAD&#x2F;rep1&#x2F;A2.40000.cool::&#x2F;40000</span><br><span class="line">  rep2:&#x2F;HiC&#x2F;A2&#x2F;TAD&#x2F;rep2&#x2F;A2.40000.cool::&#x2F;40000</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行指定分辨率</li>
<li>第二行及以后是指定不同的生物学重复对应的cool URI</li>
</ul>
<h4 id="1-2-3-程序的运行"><a href="#1-2-3-程序的运行" class="headerlink" title="1.2.3 程序的运行"></a>1.2.3 程序的运行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hitad -O test.txt -d meta_file --logFile hitad.log</span><br><span class="line"><span class="comment"># -O 指定输出文件名称</span></span><br><span class="line"><span class="comment"># -d 指定配置文件</span></span><br><span class="line"><span class="comment"># --logFile 指定log文件名称</span></span><br><span class="line"><span class="comment"># --maxsize 指定最后的domain大小</span></span><br><span class="line"><span class="comment"># -p 指定线程数</span></span><br><span class="line"><span class="comment"># -W WEIGHT_COL 使用标准化后的矩阵文件（默认）</span></span><br><span class="line"><span class="comment"># -W RAW 使用非标准化的矩阵文件</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-结果文件的解读"><a href="#1-3-结果文件的解读" class="headerlink" title="1.3 结果文件的解读"></a>1.3 结果文件的解读</h3><p>软件运行结束后，会生成一个后缀为.txt的文本文件，文本中记录了不同的domain的信息，如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1       0       1200000 2</span><br><span class="line">1       0       1680000 1</span><br><span class="line">1       0       3960000 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列为染色体编号</li>
<li>第二列为domain的起始位置</li>
<li>第三列为domain的终止位置</li>
<li>第四列为domain的类型，0代表TAD、1代表sub-TAD、2代表subsequent domain</li>
</ul>
<hr>
<p>至此，我们就从原始的HiC数据经过HiC-Pro+HiCPeaks+TADLib成功鉴定出了TAD。</p>
<p>参考：<a href="https://xiaotaowang.github.io/TADLib/hitad.html" target="_blank" rel="noopener">https://xiaotaowang.github.io/TADLib/hitad.html</a></p>
]]></content>
      <categories>
        <category>Hi-C</category>
      </categories>
  </entry>
  <entry>
    <title>一文了解：CPU核、多线程、多进程</title>
    <url>/codeHub/2020/07/12/2020-07/06CPU%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<p>在1945年，美国科学家冯诺依曼，提出了冯诺依曼计算机结构，计算机主要由运算器、控制器、存储器、输入输出设备组成。这一理论一直延续至今，并且构成所有现代电子计算机的模板。简单的将这些术语翻译成我们日常听到的就是：</p>
<ul>
<li>CPU</li>
<li>操作系统</li>
<li>硬盘</li>
<li>鼠标、键盘、显示器等</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/07/12/U8l41K.png" alt="U8l41K.png" style="zoom:80%;" />

<a id="more"></a>

<p>CPU这个中央大脑负责对传进来的数据进行复杂的逻辑判断和运算，当然不是所有的数据都需要经过CPU的，比如DMA（Direct Memory Access，直接存储器访问），可以协调不同硬件对数据的读写，不需要经过CPU计算。这样设计的理由主要是CPU这个老大哥算的非常快，而一般涉及到I/O(输入、输出)时，让CPU等待程序读好数据，就会浪费资源，这时候我们可以把IO操作交给DMA去做，然后让CPU负责其他的计算。其中最经典的两个例子就是：</p>
<ul>
<li>序列比对</li>
<li>网络爬虫</li>
</ul>
<p>序列比对这种程序，一般涉及到的是大量的科学运算，和少量的文件读取；因此占有CPU的时间很长</p>
<p>网络爬虫，这个程序会不断的爬取网上的数据，然后将数据写进磁盘中；涉及到的计算量不是很大；</p>
<p>主要是对页面进行请求后，将数据写入磁盘中，I/O运算占据大量时间</p>
<h3 id="CPU核心"><a href="#CPU核心" class="headerlink" title="CPU核心"></a>CPU核心</h3><p>CPU核的概念有有两个：物理核心、逻辑核心</p>
<h4 id="物理核心"><a href="#物理核心" class="headerlink" title="物理核心"></a>物理核心</h4><p>这个是CPU中集成了多少个核，是真实存在的，在linux中可以通过查看<code>/proc/cpuinfo</code>文件看到你的CPU有多少个核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">processor       : 2</span><br><span class="line">vendor_id       : GenuineIntel</span><br><span class="line">cpu family      : 6</span><br><span class="line">model           : 62</span><br><span class="line">model name      : Intel(R) Xeon(R) CPU E5-2630 v2 @ 2.60GHz</span><br><span class="line">stepping        : 4</span><br><span class="line">microcode       : 0x428</span><br><span class="line">cpu MHz         : 2900.244</span><br><span class="line">cache size      : 15360 KB</span><br><span class="line">physical id     : 0</span><br><span class="line">siblings        : 6</span><br><span class="line">core id         : 2</span><br><span class="line">cpu cores       : 6   <span class="comment">##CPU核心数目</span></span><br></pre></td></tr></table></figure>

<h4 id="逻辑核"><a href="#逻辑核" class="headerlink" title="逻辑核"></a>逻辑核</h4><p>通过使用超线程技术，将物理核虚拟成多个虚拟的处理单元，增加CPU处理多个任务的能力。例如我们在买电脑的时候，一般看i5、i7、i9；其实还可以根据CPU型号看一下它的核心数和运行频率等指标</p>
<h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><h4 id="进程类似的就是两个程序的运行"><a href="#进程类似的就是两个程序的运行" class="headerlink" title="进程类似的就是两个程序的运行"></a>进程类似的就是两个程序的运行</h4><p>这两个程序互相不会干扰；而线程就是进程中进行运算的基本单位。</p>
<p>例如当你打开电脑上的QQ和QQ音乐时，你就创建了两个进程；这时候这两个进程占据了CPU的两个核。当你的CPU是单核的时候，QQ音乐与QQ无法各自占据一个核，这时候操作系统就会想办法，让QQ占据一会核，让QQ音乐占据一会核，这就是所谓的<strong>进程调度</strong>。</p>
<blockquote>
<p>当你CPU的核越多时候，电脑也就能同时远程的程序也就越多。</p>
</blockquote>
<p>例如下面开启了四个进程A、B、C、D；右边的图是在单核的情况下，四个进程交替的占据CPU时间，实现并行的计算</p>
<p><img data-src="https://s1.ax1x.com/2020/07/12/U8QYPx.png" alt="U8QYPx.png"></p>
<h4 id="线程相当于进程中基本运算单位"><a href="#线程相当于进程中基本运算单位" class="headerlink" title="线程相当于进程中基本运算单位"></a>线程相当于进程中基本运算单位</h4><p>例如</p>
<ul>
<li>打开QQ音乐的时候，一边播放歌曲、一边下载歌曲</li>
<li>QQ一边接受别人的消息，一边给其他人发送消息</li>
</ul>
<blockquote>
<p> 其实它是在放一会歌，又跑去下载歌曲；下了一会又跑过来给你放歌，只是你感觉不出来。</p>
</blockquote>
<p>下图是多个线程占据一个进程的示意图，同样在某一时刻，也仅仅只能有一个线程能够使用进程中的资源</p>
<p><img data-src="https://s1.ax1x.com/2020/07/12/U8Q3Z9.png" alt="U8Q3Z9.png"></p>
<p>总的来说进程的切换，是在CPU核水平，把CPU资源分配；线程的切换是在进程内，对资源进行切换</p>
<blockquote>
<p> 一个进程占据一个核，一个核执行多个进程时，涉及进程的切换</p>
<p>一个线程占据一个进程，一个进程内部多个线程时，涉及线程的切换    </p>
</blockquote>
<h3 id="进程、线程状态的切换"><a href="#进程、线程状态的切换" class="headerlink" title="进程、线程状态的切换"></a>进程、线程状态的切换</h3><ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>需要注意的是</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态</li>
</ul>
<h3 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h3><ul>
<li><h4 id="窜行"><a href="#窜行" class="headerlink" title="窜行"></a>窜行</h4><p>多个任务，任务A完成后才开始任务B</p>
</li>
</ul>
<ul>
<li><h4 id="并行，多个进程间切换"><a href="#并行，多个进程间切换" class="headerlink" title="并行，多个进程间切换"></a>并行，多个进程间切换</h4><p>多个任务，任务A与任务B同时进行；A任务对应的进程和B任务占据的进程各占一个核</p>
</li>
<li><h4 id="并发，多个线程间切换"><a href="#并发，多个线程间切换" class="headerlink" title="并发，多个线程间切换"></a>并发，多个线程间切换</h4><p>单个任务A，任务A里面要干很多事情，但是一会干B事情，一会干C事情，两件事情在CPU中来来回回切换，让你感觉这些事情是同时在进行的</p>
</li>
</ul>
<h3 id="LSF集群资源申请"><a href="#LSF集群资源申请" class="headerlink" title="LSF集群资源申请"></a>LSF集群资源申请</h3><p>在大多数时候，软件参数内写的都是<code>--threads</code>，多少个线程的意思；而我们向系统申请资源的时候，申请的是核心数。因为一个核心其实是可以开多个<code>threads</code>的，只是当多个<code>thread</code>占据一个核心的时候，这个核心就要来来回回切换线程，这个核心进行的是并发运算；而核心数和线程数一样的话，进行的就是并行运算啦。</p>
<p>总的来说就是，当系统资源不多，并且涉及到的I/O操作比较多的时候；申请的核心数可以比线程数少；</p>
<p>而当程序主要是科学运算的话，尽量让申请的核心数和程序中线程数一致，因为线程间切换也会消耗一定的时间</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://blog.csdn.net/zhengyshan/article/details/80641770?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">高性能计算</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/110435826" target="_blank" rel="noopener">计算机操作系统</a></li>
<li><a href="https://baike.baidu.com/item/%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="noopener">百度百科</a></li>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86?id=_1-%e8%bf%9b%e7%a8%8b" target="_blank" rel="noopener">CS-Notes</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>HiC-Pro的安装与使用</title>
    <url>/codeHub/2020/07/11/2020-07/05HiC-Pro%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="HiC-Pro安装与使用"><a href="#HiC-Pro安装与使用" class="headerlink" title="HiC-Pro安装与使用"></a>HiC-Pro安装与使用</h1><p>HiC-Pro可以用来处理Hi-C数据，从原始的fastq文件(配对端Illumina数据)到标准化的交互图谱。简单的来说就是将Hi-C数据比对到拼装好的参考基因组上，并形成交互文件去存储Hi-C数据。下面我们就来介绍一下HiC-Pro的安装与使用。</p>
<a id="more"></a>

<h2 id="HiC-Pro的安装"><a href="#HiC-Pro的安装" class="headerlink" title="HiC-Pro的安装"></a>HiC-Pro的安装</h2><hr>
<h3 id="HiC-Pro所需要的这些依赖"><a href="#HiC-Pro所需要的这些依赖" class="headerlink" title="HiC-Pro所需要的这些依赖"></a>HiC-Pro所需要的这些依赖</h3><p><a href="https://imgchr.com/i/UldOCd" target="_blank" rel="noopener"><img data-src="https://s1.ax1x.com/2020/07/11/UldOCd.png" alt="依赖.png"></a></p>
<h3 id="1-使用conda安装依赖"><a href="#1-使用conda安装依赖" class="headerlink" title="1.使用conda安装依赖"></a><strong>1.使用conda安装依赖</strong></h3><p>python版本为<code>2.7</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n hicpro python=2.7	<span class="comment">#强烈推荐安装一个新的环境</span></span><br><span class="line">conda install -y samtools bowtie2 R</span><br><span class="line">conda install -y pysam bx-python numpy scipy</span><br></pre></td></tr></table></figure>

<h3 id="2-安装对应的R包"><a href="#2-安装对应的R包" class="headerlink" title="2.安装对应的R包"></a><strong>2.安装对应的R包</strong></h3><p>在当前conda环境下运行R</p>
<p>也可以绝对路径运行R</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">R</span><br><span class="line">install.packages(c(<span class="string">'ggplot2'</span>,<span class="string">'RColorBrewer'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="3-配置confir-install-txt安装文件"><a href="#3-配置confir-install-txt安装文件" class="headerlink" title="3.配置confir-install.txt安装文件"></a>3.配置confir-install.txt安装文件</h3><p><code>PREFIX</code>软件安装路径，会在该路径创建一个<code>HiC-Pro_2.11.1</code>目录</p>
<p><code>R_PATH</code>指定conda环境下的R</p>
<p><code>PYTHON_PATH</code>指定conda环境下的python</p>
<p><code>CLUSTER_SYSCLUSTER_SYS</code>集群调度系统为<code>TORQUE,SGE,SLURM,LSF</code>四个中的一种</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PREFIX = /public/home/yxlong/yxlong/app/	<span class="comment">#HiC-Pro所在目录</span></span><br><span class="line">BOWTIE2_PATH = /public/home/yxlong/miniconda3/bin/bowtie2	<span class="comment">#bowtie2所在目录</span></span><br><span class="line">SAMTOOLS_PATH = /public/home/yxlong/miniconda3/bin/samtools	<span class="comment">#samtools所在的目录</span></span><br><span class="line">R_PATH = /public/home/yxlong/miniconda3/envs/hicpro/bin/R	<span class="comment">#R包所在目录</span></span><br><span class="line">PYTHON_PATH = /public/home/yxlong/miniconda3/envs/hicpro/bin/python	<span class="comment">#python所在目录</span></span><br><span class="line">CLUSTER_SYS = LSF	<span class="comment">#TORQUE,SGE,SLURM,LSF四个中的一种</span></span><br></pre></td></tr></table></figure>

<p>这些路径可以which+对应的依赖（如: which bowtie2）获得</p>
<h3 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h3><p>配置文件修改完成之后运行下列指令即可完成安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make configure</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>



<h2 id="HiC-Pro的使用"><a href="#HiC-Pro的使用" class="headerlink" title="HiC-Pro的使用"></a>HiC-Pro的使用</h2><hr>
<h3 id="1-文件的处理"><a href="#1-文件的处理" class="headerlink" title="1.文件的处理"></a>1.文件的处理</h3><h4 id="1-1文件夹的创建"><a href="#1-1文件夹的创建" class="headerlink" title="1.1文件夹的创建"></a>1.1文件夹的创建</h4><p>建议创建两个文件夹命名为<code>sample.reads</code>和<code>sample.ref</code>（sample为自己的物种名字即可，下面以亚洲棉Ga为例）</p>
<h4 id="1-2Ga-reads的的目录结构"><a href="#1-2Ga-reads的的目录结构" class="headerlink" title="1.2Ga.reads的的目录结构"></a>1.2<code>Ga.reads</code>的的目录结构</h4><p>目录结构如下（依据自己的研究修改物种名即可，Ga_1、Ga_2…为不同的生物学重复）</p>
<p><img data-src="https://s1.ax1x.com/2020/07/11/UldbUe.png" alt="reads.png"></p>
<h4 id="1-3Ga-ref的相关文件"><a href="#1-3Ga-ref的相关文件" class="headerlink" title="1.3Ga.ref的相关文件"></a>1.3<code>Ga.ref</code>的相关文件</h4><p><img data-src="https://s1.ax1x.com/2020/07/11/Uldq4H.png" alt="ref.png"></p>
<p>Ga.fasta文件是一个link文件，链接的是拼装好的参考基因组</p>
<p>建立索引 （索引的命名为物种名）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/PATH/TO/bowtie2-build --threads 20 /Ga.ref/Ga.fasta /Ga.ref/Ga</span><br></pre></td></tr></table></figure>

<h4 id="1-4酶切信息文件的获得"><a href="#1-4酶切信息文件的获得" class="headerlink" title="1.4酶切信息文件的获得"></a>1.4酶切信息文件的获得</h4><p>采用HiC-Pro自带的digest_genome.py程序酶切位点信息文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/PATH/TO/HiC-Pro_2.11.1/bin/utils/digest_genome.py -r hindiii -o Ga.HindIII.txt /Ga.ref/Ga.fasta</span><br><span class="line"><span class="comment">#-r指定酶的名称或者序列（如下图）</span></span><br><span class="line"><span class="comment">#-o指定酶切信息文件的输出目录</span></span><br><span class="line"><span class="comment">#最后的fasta文件是组装的参考基因组</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/07/11/UldjgI.png" alt="酶切.png"></p>
<h4 id="1-5基因组中序列大小文件"><a href="#1-5基因组中序列大小文件" class="headerlink" title="1.5基因组中序列大小文件"></a>1.5基因组中序列大小文件</h4><p>序列大小文件格式如下 contig1[TAB]contig1_length</p>
<p><img data-src="https://s1.ax1x.com/2020/07/11/UldX8A.png" alt="size.png"></p>
<p>可以用如下指令获得</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">samtools faidx /Ga.ref/Ga.fasta &amp;&amp; awk <span class="string">'&#123;print $1"\t"$2&#125;'</span> /PATH/TO/Ga.fasta.fai &gt; Ga.fasta.size <span class="comment">#注意生成的.fai在.fasta文件所在的目录下面</span></span><br></pre></td></tr></table></figure>

<p>至此，相关文件的准备就结束了。</p>
<h3 id="2-配置文件的书写"><a href="#2-配置文件的书写" class="headerlink" title="2.配置文件的书写"></a>2.配置文件的书写</h3><p>首先将配置文件复制一份到当前目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;PATH&#x2F;TO&#x2F;HiC-Pro_2.11.1&#x2F;config-hicpro.txt .</span><br></pre></td></tr></table></figure>

<p>然后，进行修改（以下为通常需要修改的参数，其他的参数的修改请参考官网）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># N_CPU，例如N_CPU = 24</span></span><br><span class="line"><span class="comment"># JOB_NAME，例如JOB_NAME = Ga</span></span><br><span class="line"><span class="comment"># JOB_WALLTIME，例如JOB_WALLTIME = 11:00:00</span></span><br><span class="line"><span class="comment"># JOB_QUEUE，例如JOB_QUEUE = normal</span></span><br><span class="line"><span class="comment"># JOB_MAIL，例如JOB_MAIL = 1570447120@qq.com</span></span><br><span class="line"><span class="comment"># BOWTIE2_IDX_PATH，填写用bowtie2对reference建立索引的目录，注意是目录，而不是索引路径!如/PATH/to/Ga.ref</span></span><br><span class="line"><span class="comment"># REFERENCE_GENOME，例如Ga 注意：这里REFERENCE_GENOME一定要和bowtie2建立的索引对应上,名字为物种名</span></span><br><span class="line"><span class="comment"># GENOME_SIZE，即生成的文件Ga.fasta.size（最好使用绝对路径）</span></span><br><span class="line"><span class="comment"># GENOME_FRAGMENT，用digest_genome.py程序生成的文件Ga.HindIII.txt</span></span><br><span class="line"><span class="comment"># LIGATION_SITE，酶的序列，例如HindIII，则为AAGCTAGCTT；如果是MboI则序列为GATCGATC。</span></span><br><span class="line"><span class="comment"># MIN_FRAG_SIZE，例如MIN_FRAG_SIZE = 100</span></span><br><span class="line"><span class="comment"># MAX_FRAG_SIZE，例如MAX_FRAG_SIZE = 160000</span></span><br><span class="line"><span class="comment"># MIN_INSERT_SIZE，例如MIN_INSERT_SIZE = 200</span></span><br><span class="line"><span class="comment"># MAX_INSERT_SIZE，例如MAX_INSERT_SIZE = 600</span></span><br><span class="line"><span class="comment"># GET_PROCESS_SAM，例如GET_PROCESS_SAM = 1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-运行HiC-Pro"><a href="#3-运行HiC-Pro" class="headerlink" title="3.运行HiC-Pro"></a>3.运行HiC-Pro</h3><p>HiC-Pro的使用很简单，主要就是三个参数，指令如下（单线程运行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/PATH/TO/HiC-Pro_2.11.1/bin/HiC-Pro --input Ga.reads --output hicpro_output --conf config-hicpro.txt </span><br><span class="line"><span class="comment"># --input reads所在的文件</span></span><br><span class="line"><span class="comment"># --output 输出的文件夹</span></span><br><span class="line"><span class="comment"># --conf 配置文件</span></span><br></pre></td></tr></table></figure>

<p>如果想多线程运行，要加上-p参数，输入指令后会在输出文件中生成两个文件<code>HiCPro_step1.sh</code>、<code>HiCPro_step2.sh</code>。先运行step1，step1执行完成后，再执行step2即可。</p>
]]></content>
      <categories>
        <category>Hi-C</category>
      </categories>
  </entry>
  <entry>
    <title>pyplot对象学习</title>
    <url>/codeHub/2020/07/07/2020-07/05pyplot%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>pyplot对象包含了一系列用于绘图的函数，使得它工作起来就像MATLIB一样。它的功能例如：</p>
<ul>
<li>创建一个figure对象</li>
<li>绘制一片绘图区域</li>
<li>在区域中绘制线条或者点</li>
<li>也可以绘制labels</li>
</ul>
<a id="more"></a>

<h4 id="使用pyplot对象快速的生成一幅图片"><a href="#使用pyplot对象快速的生成一幅图片" class="headerlink" title="使用pyplot对象快速的生成一幅图片"></a>使用pyplot对象快速的生成一幅图片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="literal">None</span>,<span class="number">6</span>,<span class="number">7</span>]) <span class="comment">##看有一段为空了</span></span><br><span class="line">plt.ylabel(<span class="string">"this is y label"</span>)</span><br><span class="line">plt.subplots_adjust(right=<span class="number">1</span>,left=<span class="number">0</span>,wspace=<span class="number">0.3</span>) <span class="comment">##调整一下两幅图的间隔</span></span><br><span class="line">plt.show() <span class="comment">## 显示图片</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/07/UA2C0H.png" alt="UA2C0H.png"></p>
<p><code>pyplot.plot()</code>函数也可以只提供一个一维数组,这时候函数会将数组作为y轴，而x轴的坐标则是从0开始出发,获取与y轴相同个数的点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot([<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure>




<p><img data-src="https://s1.ax1x.com/2020/07/07/UA2P7d.png" alt="UA2P7d.png"></p>
<h4 id="同时还可以自定义一个样式，例如"><a href="#同时还可以自定义一个样式，例如" class="headerlink" title="同时还可以自定义一个样式，例如"></a>同时还可以自定义一个样式，例如</h4><ul>
<li>修改线条的类型，</li>
<li>线条的颜色，</li>
<li>坐标轴的范围等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">2</span>,<span class="number">20</span>)</span><br><span class="line">y=x*x</span><br><span class="line">plt.plot(x,y,<span class="string">'r*'</span>) <span class="comment"># ro 意思是红色的点 r-- 红色的虚线</span></span><br><span class="line">plt.plot(x+<span class="number">1</span>,y<span class="number">-2</span>,<span class="string">'b^'</span>)</span><br><span class="line">plt.plot(x,y<span class="number">-0.5</span>,<span class="string">'yd'</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>]) <span class="comment">#x轴和y轴范围</span></span><br></pre></td></tr></table></figure>




<p><img data-src="https://s1.ax1x.com/2020/07/07/UA2ktI.png" alt="UA2ktI.png"></p>
<h4 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h4><p>pyplot根据data关键字来获取对应的绘图数据</p>
<ul>
<li><code>&#39;a&#39;</code>表示从data中获取作为X轴</li>
<li><code>&#39;b&#39;</code>表示作物y轴的数据</li>
<li><code>c=&#39;c&#39;</code>表示映射为对应的颜色</li>
<li><code>s=&#39;s&#39;</code> 大小的映射</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;<span class="string">'a'</span>: np.arange(<span class="number">50</span>),</span><br><span class="line">        <span class="string">'c'</span>: np.random.randint(<span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>),</span><br><span class="line">        <span class="string">'d'</span>: np.random.randn(<span class="number">50</span>)&#125;</span><br><span class="line">data[<span class="string">'b'</span>] = data[<span class="string">'a'</span>] + <span class="number">10</span> * np.random.randn(<span class="number">50</span>)</span><br><span class="line">data[<span class="string">'d'</span>] = np.abs(data[<span class="string">'d'</span>]) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line">plt.scatter(<span class="string">'a'</span>,<span class="string">'b'</span>,c=<span class="string">'c'</span>,s=<span class="string">'d'</span>,data=data)</span><br><span class="line">plt.xlabel(<span class="string">'entry a'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'entry b'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/07/UA2Aht.png" alt="UA2Aht.png"></p>
<h4 id="绘制分类图"><a href="#绘制分类图" class="headerlink" title="绘制分类图"></a>绘制分类图</h4><ul>
<li><code>subplot</code>函数中包含3个参数，其中前两个参数用于将图片按照行和列进行均等分，而第三个参数则是表示显示在哪个分好的格子中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">name=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">values=[<span class="number">1</span>,<span class="number">100</span>,<span class="number">200</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>) <span class="comment">##将figure均等分为2份</span></span><br><span class="line">plt.bar(name,values)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">##分4份</span></span><br><span class="line">plt.scatter(name,values)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>) <span class="comment">##分4份</span></span><br><span class="line">plt.plot(name,values)</span><br></pre></td></tr></table></figure>




<p><img data-src="https://s1.ax1x.com/2020/07/07/UA2Z1f.png" alt="UA2Z1f.png"></p>
<h4 id="控制线条显示"><a href="#控制线条显示" class="headerlink" title="控制线条显示"></a>控制线条显示</h4><ul>
<li>可以直接在plot对象中对线条进行设置</li>
<li>也可以获取plot返回后的对象，调用plt的setp函数对对象进行操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">20</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">lines=plt.plot(x,x*x,<span class="string">'--'</span>) <span class="comment">##获取lines对象</span></span><br><span class="line">plt.setp(lines,color=<span class="string">"r"</span>,linewidth=<span class="number">10.0</span>,alpha=<span class="number">0.5</span>)  <span class="comment">##调用方法对对象进行操作</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">lines2=plt.plot(x,x*x,<span class="string">'--'</span>) <span class="comment">##获取lines对象</span></span><br><span class="line">plt.setp(lines2,color=<span class="string">'y'</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">lines3=plt.plot(x,x*x,<span class="string">'--'</span>) <span class="comment">##获取lines对象</span></span><br><span class="line">plt.setp(lines3,color=<span class="string">'black'</span>,linewidth=<span class="number">3</span>,animated=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<p><img data-src="https://s1.ax1x.com/2020/07/07/UA2ec8.png" alt="UA2ec8.png"></p>
<h4 id="添加文字描述"><a href="#添加文字描述" class="headerlink" title="添加文字描述"></a>添加文字描述</h4><p> <code>plt.text</code>函数可以在图中指定位置添加文字注释</p>
<ul>
<li>第一个参数是x轴位置新</li>
<li>第二个参数是y轴位置新</li>
<li>第三个参数则是添加的文字，可以使用正则表达式，并且空格也需要转义</li>
</ul>
<p><code>plt.annotate</code>函数则更加的方便，可以添加箭头信息等</p>
<ul>
<li><code>arrowprops</code>字典中arrowstyle可以指定箭头类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mu,sigma=<span class="number">100</span>,<span class="number">15</span></span><br><span class="line">x=mu+sigma*np.random.randn(<span class="number">10000</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">n,bins,patches=plt.hist(x,<span class="number">50</span>,density=<span class="number">1</span>,color=<span class="string">'r'</span>,alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.text(<span class="number">60</span>,<span class="number">0.02</span>,<span class="string">r'$\mu=100,\ \sigma=15$'</span>) <span class="comment">##添加文字，特效符合需要转义</span></span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">n,bins,patches=plt.hist(x,<span class="number">50</span>,density=<span class="number">1</span>,color=<span class="string">'g'</span>,alpha=<span class="number">0.7</span>,orientation=<span class="string">'horizontal'</span>) <span class="comment">##水平放置</span></span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.annotate(<span class="string">r'$Code,\ Hub$'</span>,</span><br><span class="line">             size=<span class="number">20</span>,</span><br><span class="line">             xy=(<span class="number">0.01</span>,<span class="number">120</span>),</span><br><span class="line">             xytext=(<span class="number">0.012</span>,<span class="number">140</span>),</span><br><span class="line">             arrowprops=dict(facecolor=<span class="string">'blue'</span>,arrowstyle=<span class="string">'-&gt;'</span>)) <span class="comment">##添加箭头注释信息</span></span><br></pre></td></tr></table></figure>




<p><img data-src="https://s1.ax1x.com/2020/07/07/UA2V9P.png" alt="UA2V9P.png"></p>
<h4 id="坐标轴对数化"><a href="#坐标轴对数化" class="headerlink" title="坐标轴对数化"></a>坐标轴对数化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##用于绘制相应对数化后的刻度线</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> NullFormatter</span><br><span class="line"><span class="comment">###获取数据</span></span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line">y = np.random.normal(loc=<span class="number">0.5</span>, scale=<span class="number">0.4</span>, size=<span class="number">1000</span>)</span><br><span class="line">y = y[(y &gt; <span class="number">0</span>) &amp; (y &lt; <span class="number">1</span>)]</span><br><span class="line">y.sort()</span><br><span class="line">x = np.arange(len(y)) <span class="comment">##生成步长为1的指定数目的array</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 线性坐标轴</span></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.title(<span class="string">"liner"</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##对数坐标轴</span></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.yscale(<span class="string">'log'</span>)</span><br><span class="line">plt.title(<span class="string">'log'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##对称,log坐标轴</span></span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.plot(x,y-y.mean())</span><br><span class="line">plt.yscale(<span class="string">'symlog'</span>,linthreshy=<span class="number">0.01</span>)</span><br><span class="line">plt.title(<span class="string">'symlog'</span>)</span><br><span class="line">plt.grid()</span><br><span class="line"></span><br><span class="line"><span class="comment">##logit</span></span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.yscale(<span class="string">'logit'</span>)</span><br><span class="line">plt.title(<span class="string">'logit'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">1</span>, bottom=<span class="number">0</span>, left=<span class="number">0.10</span>, </span><br><span class="line">                    right=<span class="number">0.95</span>, </span><br><span class="line">                    hspace=<span class="number">0.25</span>,</span><br><span class="line">                    wspace=<span class="number">0.35</span> )<span class="comment">##调整子图间的间隔</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/07/UA2FAA.png" alt="UA2FAA.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib入门</title>
    <url>/codeHub/2020/07/05/2020-07/04matplotlib%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong>matplotlib</strong> 做基于python的一款可视化神器，类似于 <code>ggplot2</code>，它基本能涵盖常见的一些图形。同时得益于强大的python社区支持，这个包的功能也在不断增加。有时候写多了python，再写R，一时半会还想不起代码咋写。同时python中用于统计的包也比较全面，自己对python了解的还是多一些，准备在数据可视化方面用<code>matplotlib</code>。</p>
<p><strong>matplotlib支持一些常见的图形例如:</strong></p>
<ul>
<li>线图;</li>
<li>散点图;</li>
<li>等高线图;</li>
<li>条形图;</li>
<li>柱状图;</li>
<li>3D 图形,</li>
<li>甚至是图形动画等等.</li>
</ul>
<a id="more"></a>

<p><strong>官网网页</strong><br><a href="https://matplotlib.org/" target="_blank" rel="noopener">https://matplotlib.org/</a></p>
<p><strong>学习视频教程:</strong> 莫烦的</p>
<p><a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/</a></p>
<p>话不多说，先上几张漂亮的图片，压压场</p>
<p><img data-src="https://morvanzhou.github.io/static/results/plt/1_1_3.png" alt="3D"></p>
<p><img data-src="https://matplotlib.org/_images/sphx_glr_span_regions_001.png" alt=""></p>
<p><img data-src="https://matplotlib.org/_images/sphx_glr_hexbin_demo_001.png" alt=""></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>使用<code>pip</code>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip install -U pip</span><br><span class="line">python -m pip install -U matplotlib</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pip install matplotlib --user</span></span><br><span class="line"><span class="comment">#引入matplotlib包</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots()  <span class="comment"># Create a figure containing a single axes.</span></span><br><span class="line">ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># Plot some data on the axes.</span></span><br></pre></td></tr></table></figure>




<pre><code>[&lt;matplotlib.lines.Line2D at 0x7f34ca8c95e0&gt;]</code></pre><p><img data-src="https://s1.ax1x.com/2020/07/05/U91mJe.png" alt="U91mJe.png"></p>
<p><code>plt.subplots()</code>函数返回两个对象</p>
<ul>
<li>fig 图形对象</li>
<li>ax 坐标轴对象<br>当然如果不需要操作坐标轴的话，也可以直接使用<code>plot</code>函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot([<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">plt.plot([<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="comment">#直接使用plot函数</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="更加深入的理解图片的构造"><a href="#更加深入的理解图片的构造" class="headerlink" title="更加深入的理解图片的构造"></a>更加深入的理解图片的构造</h4><p><img data-src="https://matplotlib.org/_images/anatomy.png" alt="figure图片构造"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">figure=plt.figure() <span class="comment">##没有坐标轴的空白图片,啥也看不到</span></span><br><span class="line">fig,ax=plt.subplots() <span class="comment">##带坐标轴的空白图片,只有单个坐标轴</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/05/U91uzd.png" alt="U91uzd.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,axs=plt.subplots(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">##2x2的四坐标轴图片</span></span><br></pre></td></tr></table></figure>


<p><img data-src="https://s1.ax1x.com/2020/07/05/U91nRH.png" alt="U91nRH.png"></p>
<h2 id="Axes对象"><a href="#Axes对象" class="headerlink" title="Axes对象"></a>Axes对象</h2><ul>
<li>通常Axes就是包含data的一个图片</li>
<li>一张figure可以有多个Axes</li>
<li>而一个Axes只属于某一个figure</li>
<li>Axes包含有两个或者3个Axis（坐标轴）</li>
<li>Axes类似于ggplot分面中的一个分面</li>
</ul>
<p>对坐标轴中显示数据范围的控制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">axes.Axes.set_xlim() <span class="comment">##控制X轴显示范围</span></span><br><span class="line">axes.Axes.set_ylim() <span class="comment">##控制y轴显示范围</span></span><br></pre></td></tr></table></figure>
<p>控制坐标轴标签与图形标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">axes.Axes.set_title() <span class="comment">##图片标签</span></span><br><span class="line">axes.Axes.set_xlabel() <span class="comment">##x轴标签</span></span><br><span class="line">axes.Axes.set_ylabel() <span class="comment">##y轴标签</span></span><br></pre></td></tr></table></figure>
<p>控制图例名称和显示图例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">axes.plot(data,label=<span class="string">"图例名"</span>)</span><br><span class="line">axes.legend()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">matplotlib.use(<span class="string">'qt5agg'</span>)</span><br><span class="line">fig,axs=plt.subplots(<span class="number">2</span>,<span class="number">1</span>) <span class="comment">## 绘制2X1 图片</span></span><br><span class="line">axs[<span class="number">0</span>].plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],label=<span class="string">"liner1"</span>) <span class="comment">#第一张图，以及图例</span></span><br><span class="line">axs[<span class="number">0</span>].plot([<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],label=<span class="string">"liner2"</span>) <span class="comment">#第一张图，以及图例</span></span><br><span class="line">axs[<span class="number">1</span>].plot([<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],label=<span class="string">"test"</span>) <span class="comment"># 第二张图 以及图例</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> axs:   <span class="comment">#批量设置标题 和图例</span></span><br><span class="line">    item.set_xlim(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">    item.set_xlabel(<span class="string">'x label'</span>)</span><br><span class="line">    item.set_ylabel(<span class="string">'y label'</span>)</span><br><span class="line">    item.set_title(<span class="string">'test'</span>)</span><br><span class="line">    item.legend()</span><br><span class="line">plt.savefig(<span class="string">"test.png"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Axis对象"><a href="#Axis对象" class="headerlink" title="Axis对象"></a>Axis对象</h1><ul>
<li>用于设置坐标轴范围</li>
<li>控制坐标轴上显示的标记，<code>Locator</code>对象</li>
<li>控制坐标轴上显示的字符 <code>Formatter</code>对象</li>
</ul>
<h1 id="Artist"><a href="#Artist" class="headerlink" title="Artist"></a>Artist</h1><p>基本上所有的figure都会用到Artist对象，并且Artist是与Axes对象绑定在一起使用的。Artist对象就包含以下几个对象</p>
<ul>
<li>Text</li>
<li>Line2D</li>
<li>collection</li>
<li>Patch</li>
</ul>
<h1 id="输入数据格式"><a href="#输入数据格式" class="headerlink" title="输入数据格式"></a>输入数据格式</h1><p>所有的绘图数据都是基于<code>numpy.array</code>类型进行的，当然有些类似array的数据类型，例如<code>pandas</code>中的dataFrame,<code>numpy</code>中的matrix;这些数据类型作为输入数据时，可能不能够正常的工作，所有还是将它们转换成<code>numpy.array</code>之后再绘制图片吧</p>
<ul>
<li><h4 id="将panda-数据框转换"><a href="#将panda-数据框转换" class="headerlink" title="将panda 数据框转换"></a>将panda 数据框转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line">a=pandas.DataFrame(np.random.rand(<span class="number">4</span>,<span class="number">5</span>), columns = list(<span class="string">'abcde'</span>)) <span class="comment">##获取4x5的随机数据框</span></span><br><span class="line">print(a)</span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">0</span>  <span class="number">0.505938</span>  <span class="number">0.742418</span>  <span class="number">0.732312</span>  <span class="number">0.008823</span>  <span class="number">0.559201</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.834437</span>  <span class="number">0.657429</span>  <span class="number">0.136503</span>  <span class="number">0.654495</span>  <span class="number">0.841873</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.725788</span>  <span class="number">0.746307</span>  <span class="number">0.240214</span>  <span class="number">0.732954</span>  <span class="number">0.119796</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0.452142</span>  <span class="number">0.172521</span>  <span class="number">0.103506</span>  <span class="number">0.472862</span>  <span class="number">0.744575</span></span><br><span class="line">a_array=a.values</span><br><span class="line">print(a) <span class="comment">##看起来没变化，实质上一个是数据框，一个是数组</span></span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">0</span>  <span class="number">0.505938</span>  <span class="number">0.742418</span>  <span class="number">0.732312</span>  <span class="number">0.008823</span>  <span class="number">0.559201</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.834437</span>  <span class="number">0.657429</span>  <span class="number">0.136503</span>  <span class="number">0.654495</span>  <span class="number">0.841873</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.725788</span>  <span class="number">0.746307</span>  <span class="number">0.240214</span>  <span class="number">0.732954</span>  <span class="number">0.119796</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0.452142</span>  <span class="number">0.172521</span>  <span class="number">0.103506</span>  <span class="number">0.472862</span>  <span class="number">0.744575</span></span><br></pre></td></tr></table></figure></li>
<li><h4 id="将numpy-matrix转换"><a href="#将numpy-matrix转换" class="headerlink" title="将numpy.matrix转换"></a>将numpy.matrix转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b = np.matrix([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">print(b)</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line">b_asarray = np.asarray(b)</span><br><span class="line">print(b)</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="pyplot两种绘图方式"><a href="#pyplot两种绘图方式" class="headerlink" title="pyplot两种绘图方式"></a>pyplot两种绘图方式</h1><ul>
<li><h4 id="面向对象的方式"><a href="#面向对象的方式" class="headerlink" title="面向对象的方式"></a>面向对象的方式</h4>这种在写脚本的时候，可以封装成函数，在不修改代码的情况下，仅仅改变数据就可以获得不同的图片。用的比较多；不涉及与用户的交互</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x=np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line">ax.plot(x,x,label=<span class="string">'liner'</span>)</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="直接调用pyplot方法"><a href="#直接调用pyplot方法" class="headerlink" title="直接调用pyplot方法"></a>直接调用pyplot方法</h4>这个有点类似ggplot2，在jupyter中用的频繁。不过个人还是比较喜欢用第一种面向对象的方式，毕竟对象嘛..</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x=np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">plt.plot(x,x,label=<span class="string">"liner"</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="还有第三种，之后遇到在看吧"><a href="#还有第三种，之后遇到在看吧" class="headerlink" title="还有第三种，之后遇到在看吧"></a>还有<a href="https://matplotlib.org/tutorials/introductory/usage.html#the-object-oriented-interface-and-the-pyplot-interface" target="_blank" rel="noopener">第三种</a>，之后遇到在看吧</h4></li>
</ul>
<h1 id="如何导出图片"><a href="#如何导出图片" class="headerlink" title="如何导出图片"></a>如何导出图片</h1><p>文档里用了一个词<code>BacKends</code>，意思就是针对不同的需求，导出不同类型的图片</p>
<ul>
<li><h4 id="AGG-支持png"><a href="#AGG-支持png" class="headerlink" title="AGG 支持png"></a>AGG 支持png</h4></li>
<li><h4 id="PS-支持ps、eps"><a href="#PS-支持ps、eps" class="headerlink" title="PS 支持ps、eps"></a>PS 支持ps、eps</h4></li>
<li><h4 id="PDF-支持pdf"><a href="#PDF-支持pdf" class="headerlink" title="PDF 支持pdf"></a>PDF 支持pdf</h4></li>
<li><h4 id="SVG-支持svg"><a href="#SVG-支持svg" class="headerlink" title="SVG 支持svg"></a>SVG 支持svg</h4></li>
<li><h4 id="Cairo-支持png-ps-pdf-svg"><a href="#Cairo-支持png-ps-pdf-svg" class="headerlink" title="Cairo 支持png ps pdf svg"></a>Cairo 支持png ps pdf svg</h4></li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>一般来说不用配置，能够根据系统自动检测，<br>linux中配置一下环境变量即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> MPLBACKEND=qt5agg</span><br><span class="line">$ python simple_plot.py</span><br><span class="line"><span class="comment">##或者</span></span><br><span class="line">$ MPLBACKEND=qt5agg python simple_plot.py</span><br></pre></td></tr></table></figure>
<p>在脚本内部配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">'qt5agg'</span>)</span><br><span class="line"><span class="comment">##导出图片</span></span><br><span class="line">matplotlib.pyplot.savefig(<span class="string">'filename'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>经典Hi-C文献</title>
    <url>/codeHub/2020/07/05/2020-07/03%E7%BB%8F%E5%85%B8Hic/</url>
    <content><![CDATA[<blockquote>
<p> A 3D Map of the Human Genome at Kilobase Resolution Reveals Principles of Chromatin Looping  </p>
</blockquote>
<h3 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h3><p>这篇文章通过改进了Hi-C的实验后，提高了分辨率，并且得到了以下结果:</p>
<ol>
<li>将genome中 交互contact domains 的大小定位到185kb左右</li>
<li>根据组蛋白修饰将compartment细分成6个subcompartment</li>
<li>在不同组织中鉴定到了~10000个染色质 loops</li>
<li>loops与基因启动子、增强子有关，并且能够促进基因的表达</li>
<li>在不同细胞和不同物种间，loops有着比较高的保守性</li>
<li>发现大部分loops与compartment的边界重合现象</li>
</ol>
<a id="more"></a>

<h3 id="根据highlight思考"><a href="#根据highlight思考" class="headerlink" title="根据highlight思考"></a>根据highlight思考</h3><ol>
<li>首先相比于之前的Hi-C，suit Hi-C做了哪些改进</li>
<li>Hi-C分析中，怎么计算domain的分辨率</li>
<li>如何划分subcompartment</li>
<li>怎么鉴定loops</li>
</ol>
<h3 id="Hi-C实验的改进"><a href="#Hi-C实验的改进" class="headerlink" title="Hi-C实验的改进"></a>Hi-C实验的改进</h3><p><img data-src="https://s1.ax1x.com/2020/07/05/Uptrbn.png" alt="Uptrbn.png"></p>
<p>一代Hi-C技术 <code>dilution Hi-C</code>:</p>
<ul>
<li>通过将细胞核打碎后，在溶液中进行胶联</li>
<li>使用6碱基的HindIII内切酶</li>
<li>胶联时间比较长</li>
</ul>
<p><code>suit Hi-C</code>技术:</p>
<ul>
<li>在细胞核内进行胶联，减少一定的假阳性</li>
<li>使用4碱基DNA内切酶，酶切效率更高</li>
<li>胶联时间缩短，由7d变为3d</li>
</ul>
<h3 id="Hi-C中的一些概念和图片"><a href="#Hi-C中的一些概念和图片" class="headerlink" title="Hi-C中的一些概念和图片"></a>Hi-C中的一些概念和图片</h3><p><img data-src="https://s1.ax1x.com/2020/07/05/UpdCI1.png" alt="UpdCI1.png"></p>
<p><code>matrix resolution</code>： 在Hi-C热图中人为定义的窗口的大小</p>
<p><code>map resolution</code>：在基因组中的片段中，80%的位置存在至少1000次交互，这些片段中最小的那个片段长度；一般也就代表了Hi-C实验的最高分辨率了</p>
<p>通过将染色体拆分成固定大小（10K，100K，1M）的连续片段，通过统计两两片段间交互的频率就可以得到一个二维矩阵M<del>i,j</del>，i和j当然代表染色体不同的两个位置</p>
<p><code>interva</code>：是一窜连续的位置，如果两个interva发生了交互，那么在热图中就显示成一个矩形或者正方形</p>
<p>例如图中 第一行是在500KB 的matrix resolution精度下，第二行是在50kb的精度下；其中数字21表示的就是interva的数目</p>
<h3 id="得到contact-domain的大小"><a href="#得到contact-domain的大小" class="headerlink" title="得到contact domain的大小"></a>得到contact domain的大小</h3><p><img data-src="https://s1.ax1x.com/2020/07/05/UpdLTA.png" alt="UpdLTA.png"></p>
<p>大致就是根据Hi-C构建的交互矩阵结果，通过分析interva，在图中也可以看出热图可以被区分成一个一个小方块。使用<code>Arrowhead algorithm</code>算法，得到这些方块的大小在40Kb~3M之间，中位数大致185kb</p>
<h3 id="根据组蛋白修饰分成6个sub-compartment"><a href="#根据组蛋白修饰分成6个sub-compartment" class="headerlink" title="根据组蛋白修饰分成6个sub compartment"></a>根据组蛋白修饰分成6个sub compartment</h3><p><img data-src="https://s1.ax1x.com/2020/07/05/Upww0H.png" alt="Upww0H.png"></p>
<p>通过使用随机聚类的算法，将concat Domains分成6个subcompartment，其中A1、A2亚组有更多高表达的基因，活跃型组蛋白修饰H3K36me3, H3K79me2 也很多。</p>
<h3 id="鉴定染色质loops"><a href="#鉴定染色质loops" class="headerlink" title="鉴定染色质loops"></a>鉴定染色质loops</h3><p><img data-src="https://s1.ax1x.com/2020/07/05/Up06a9.png" alt="Up06a9.png"></p>
<blockquote>
<p>Such pairs correspond to pixels with higher contact frequency than typical pixels in their neighborhood  </p>
</blockquote>
<p>通过比较与局部比对的read进行比较，发现显著性的peak,这里的pixels也就对应了一个<code>matrix resolution</code>的大小，与此同时作者开发了一套鉴定染色体loop的流程<code>juicer-tools</code>。</p>
<p>试了一下，感觉软件挺好用。</p>
<p>juicer-tools 教程：<a href="https://github.com/BiocottonHub/BioSoftware/wiki/juicer-tools" target="_blank" rel="noopener">https://github.com/BiocottonHub/BioSoftware/wiki/juicer-tools</a></p>
<h3 id="Loops保守性分析"><a href="#Loops保守性分析" class="headerlink" title="Loops保守性分析"></a>Loops保守性分析</h3><p>分析了不同细胞类型和不同物种中保守的loops后，发现在不同细胞中loops大多数是保守的，在老鼠和人中大约有50%的loops是保守的</p>
<h3 id="loops与启动子、增强子"><a href="#loops与启动子、增强子" class="headerlink" title="loops与启动子、增强子"></a>loops与启动子、增强子</h3><p>通过对基因启动子进行分类，分层在loop区域和不在loop区域。发现启动子在loop区域的表达水平比没有loop的高出6倍之多</p>
<p>同时分析了人类和老鼠中的一个基因SELL，在人类中SELL存在loop（左图，蓝圈）；而老鼠中不存在loop；人类中SELL是表达的，而老鼠中不表达。</p>
<ul>
<li>loops可能在3维空间上使得启动子和增强子靠近促进基因表达</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/07/05/UpDm1P.png" alt="UpDm1P.png"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>A 3D Map of the Human Genome at Kilobase Resolution Reveals Principles of Chromatin Looping  </li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>多进程2.0</title>
    <url>/codeHub/2020/07/05/2020-07/02%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>在使用多线程并没有实质性的提速后，果断放弃了多线程；最后还是使用多进程的方式处理这个50G的大文件</p>
<h3 id="多线程和多进程区别"><a href="#多线程和多进程区别" class="headerlink" title="多线程和多进程区别"></a>多线程和多进程区别</h3><ol>
<li>进程是分配资源的基本单位；</li>
<li>线程是系统调度和分派的基本单位。</li>
<li>属于同一进程的线程，堆是共享的，栈是私有的。</li>
<li>属于同一进程的所有线程都具有相同的地址空间。</li>
</ol>
<a id="more"></a>

<h4 id="多进程的优点："><a href="#多进程的优点：" class="headerlink" title="多进程的优点："></a>多进程的优点：</h4><p>①编程相对容易；通常不需要考虑锁和同步资源的问题。<br>②更强的容错性：比起多线程的一个好处是一个进程崩溃了不会影响其他进程。<br>③有内核保证的隔离：数据和错误隔离。 对于使用如C/C++这些语言编写的本地代码，错误隔离是非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）。</p>
<h4 id="多线程的优点："><a href="#多线程的优点：" class="headerlink" title="多线程的优点："></a>多线程的优点：</h4><p>①创建速度快，方便高效的数据共享<br>共享数据：多线程间可以共享同一虚拟地址空间；多进程间的数据共享就需要用到共享内存、信号量等IPC技术。<br>②较轻的上下文切换开销 - 不用切换地址空间，不用更改寄存器，不用刷新TLB。<br>③提供非均质的服务。如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。</p>
<h3 id="1-文件分块类"><a href="#1-文件分块类" class="headerlink" title="1.文件分块类"></a>1.文件分块类</h3><p>通过初始化一个文件分块类，并调用<code>partion</code>函数，获得每个进程所需要读取的区间</p>
<p><code>pos_list = PartitionFile(fileName, ProcessNum).partion() # *存放所有文件指针坐标*</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionFile</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fileName, jobsNum)</span>:</span></span><br><span class="line">        self.fileName = fileName</span><br><span class="line">        self.blockNum = jobsNum</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partion</span><span class="params">(self)</span>:</span></span><br><span class="line">        fd = open(self.fileName, <span class="string">'r'</span>)</span><br><span class="line">        fd.seek(<span class="number">0</span>, <span class="number">2</span>)  <span class="comment"># 移动文件指针到文件尾,用于获取文件大小</span></span><br><span class="line">        fileSize = fd.tell()  <span class="comment"># 获取文件字符数</span></span><br><span class="line">        Pos_list = []  <span class="comment"># 指针坐标，数组</span></span><br><span class="line">        blockSize = int(fileSize/self.blockNum)</span><br><span class="line">        start_Pos = <span class="number">0</span>  <span class="comment"># 文件初始指针</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.blockNum):</span><br><span class="line">            <span class="keyword">if</span> i == self.blockNum<span class="number">-1</span>:</span><br><span class="line">                end_Pos = fileSize<span class="number">-1</span>  <span class="comment"># 最后一个文件区块为文件结尾</span></span><br><span class="line">                Pos_list.append((start_Pos, end_Pos))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            end_Pos = start_Pos+blockSize<span class="number">-1</span>  <span class="comment"># 均匀分配每个区块</span></span><br><span class="line">            Pos_list.append((start_Pos, end_Pos))</span><br><span class="line">            start_Pos = end_Pos+<span class="number">1</span>  <span class="comment"># 下一个区块的开始坐标</span></span><br><span class="line">        fd.close()</span><br><span class="line">        <span class="keyword">return</span> Pos_list</span><br></pre></td></tr></table></figure>

<h3 id="2-读取进程"><a href="#2-读取进程" class="headerlink" title="2.读取进程"></a>2.读取进程</h3><p>因为python中字典和列表都是引用类型数据，所以使用函数对其直接操作，可以改变原字典；这里只有文件的读取，不涉及子进程间的通信，所以不使用<code>Queue</code></p>
<ul>
<li>进程类中定义一个<code>self.outData</code>用于存储每行结果</li>
<li><code>processFunction</code>函数会对每行结果进行处理后存进<code>self.outData</code>内</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def reader(self):</span><br><span class="line">    fd = open(self.fileName, <span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">if</span> self.start_Pos != 0:</span><br><span class="line">        fd.seek(self.start_Pos-1)</span><br><span class="line">        <span class="keyword">if</span> fd.read(1) != <span class="string">'\n'</span>:  <span class="comment"># 当前初始位置不是行首,移动到下一行行首</span></span><br><span class="line">            fd.readline()</span><br><span class="line">            self.start_Pos = fd.tell()</span><br><span class="line">    fd.seek(self.start_Pos)  <span class="comment"># 将文件指针定位到区块的行首</span></span><br><span class="line">    <span class="keyword">while</span> self.start_Pos &lt;= self.end_Pos:  <span class="comment"># 开始按行读取文件并且进行操作</span></span><br><span class="line">        tmp = fd.readline()</span><br><span class="line">        processFunction(tmp, self.outData)  <span class="comment"># 将每行结果存进字典内</span></span><br><span class="line">        self.start_Pos = fd.tell()  <span class="comment"># 读完一行后，自动调整开始位置</span></span><br><span class="line">    fd.close()</span><br><span class="line">    <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>子进程写入文件</p>
<p>这里没有直接使用<code>生产者-消费者</code>模型，是因为基本没有子进程间的通信；只有主进程和子进程的通信；我当时还直接将所有的子进程读到的文件数据写入<code>Queue</code>，然后再从主进程中读取，结果最后子进程一直被挂起了。原因可能是，队列容量达到系统上限，生成者太多了，消费者只有主进程一个</p>
<p>参考：<a href="https://www.zhihu.com/question/63265466" target="_blank" rel="noopener">https://www.zhihu.com/question/63265466</a></p>
<ul>
<li>遍历<code>self.outData</code>数据，将结果写入文件</li>
<li>由于涉及到多个进程对文件的写，这里使用了文件锁</li>
<li>将写入的文件名通过<code>Queue</code>传递给主进程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"Process: "</span> + self.name+<span class="string">": reading file..."</span>)</span><br><span class="line">    self.reader()</span><br><span class="line">    print(<span class="string">"Process: "</span> + self.name+<span class="string">": begin to write temporary data to file..."</span>)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> self.outData.keys():</span><br><span class="line">        self.queue.put(key, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">with</span> open(path+<span class="string">"/"</span>+key, <span class="string">'a'</span>) <span class="keyword">as</span> File:</span><br><span class="line">            fcntl.flock(File.fileno(), fcntl.LOCK_EX)</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> self.outData[key]:</span><br><span class="line">                File.write(item[<span class="number">0</span>]+<span class="string">" "</span>+key+<span class="string">" "</span>+<span class="string">" "</span>.join(item[<span class="number">1</span>:])+<span class="string">"\n"</span>)</span><br><span class="line">    print(<span class="string">"Process: "</span> + self.name+<span class="string">": completed write..."</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-排序进程"><a href="#3-排序进程" class="headerlink" title="3.排序进程"></a>3.排序进程</h3><ul>
<li>排序进程的文件名是，主进程从队列中获取得到的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def sortFile(self):</span><br><span class="line">    with open(path+<span class="string">"/"</span>+self.fileName, <span class="string">'r'</span>) as File:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> File.readlines():</span><br><span class="line">            line = line.split(<span class="string">" "</span>)</span><br><span class="line">            try:</span><br><span class="line">                <span class="comment"># [tmpDict[line[3]], line[1],line[2], '0', tmpDict[line[6]], line[4], line[5], '0']</span></span><br><span class="line">                <span class="comment"># 都是同一条染色体对应的Chr1-Chr2 Chr1-Chr3</span></span><br><span class="line">                self.outData[line[5]].append(</span><br><span class="line">                    [line[0], line[2], line[3], line[4], line[6], line[7]])</span><br><span class="line">            except KeyError:</span><br><span class="line">                self.outData[line[5]] = [</span><br><span class="line">                    [line[0], line[2], line[3], line[4], line[6], line[7]]]</span><br><span class="line">    with open(path+<span class="string">"/"</span>+self.fileName+<span class="string">"_sorted"</span>, <span class="string">'w'</span>) as File:</span><br><span class="line">        sortKey = sorted(self.outData)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> sortKey:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> self.outData[key]:</span><br><span class="line">                File.write(item[0]+<span class="string">" "</span>+self.fileName+<span class="string">" "</span> +</span><br><span class="line">                           <span class="string">" "</span>.join(item[1:4])+<span class="string">" "</span>+key+<span class="string">" "</span>+item[-2]+<span class="string">" "</span>+item[-1])</span><br></pre></td></tr></table></figure>

<h3 id="4-封装后的函数"><a href="#4-封装后的函数" class="headerlink" title="4.封装后的函数"></a>4.封装后的函数</h3><ul>
<li>主进程通过队列的方式从子进程中获取染色体编号</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">'tmp'</span>+str(int(time.time()))</span><br><span class="line">mkdir(path)</span><br><span class="line">workQueue = Queue()  <span class="comment"># 用于存放子进程文件数据</span></span><br><span class="line">read_jobs = []</span><br><span class="line">sort_jobs = []</span><br><span class="line">chrosomes = []</span><br><span class="line">pos_list = PartitionFile(fileName, ProcessNum).partion()  <span class="comment"># 存放所有文件指针坐标</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(ProcessNum):</span><br><span class="line">    position = pos_list[i]</span><br><span class="line">    myprocess = readProcess(</span><br><span class="line">        str(i), fileName, workQueue, position[<span class="number">0</span>], position[<span class="number">1</span>], processFunction)</span><br><span class="line">    myprocess.start()</span><br><span class="line">    read_jobs.append(myprocess)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> read_jobs:</span><br><span class="line">    i.join()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        chrosomes.append(workQueue.get(block=<span class="literal">True</span>, timeout=<span class="number">1</span>))  <span class="comment"># 获取子进程数据</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list(set(chrosomes)):</span><br><span class="line">    myprocess = sortProcess(str(i), i)  <span class="comment"># 排序进程</span></span><br><span class="line">    myprocess.start()</span><br><span class="line">    sort_jobs.append(myprocess)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sort_jobs:</span><br><span class="line">    i.join()</span><br></pre></td></tr></table></figure>

<h3 id="5-性能测试"><a href="#5-性能测试" class="headerlink" title="5.性能测试"></a>5.性能测试</h3><ul>
<li>单进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Process: 0: reading file...</span><br><span class="line">Process: 0: begin to write temporary data to file...</span><br><span class="line">Process: 0: completed write...</span><br><span class="line">sorting chrosome: Gbar_A01...</span><br><span class="line">chrosome: Gbar_A01ok...</span><br><span class="line">merge chrosomes to a single file...</span><br><span class="line">completed!</span><br><span class="line">there are some temporary file <span class="keyword">in</span> directory: &lt;./tmp1593916264&gt;</span><br><span class="line"><span class="keyword">if</span> you can remove it by yourself!</span><br><span class="line">Cost Time is 46.96</span><br></pre></td></tr></table></figure>

<ul>
<li>四个进程·</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Process: 1: reading file...</span><br><span class="line">Process: 0: reading file...</span><br><span class="line">Process: 3: reading file...</span><br><span class="line">Process: 2: reading file...</span><br><span class="line">Process: 3: begin to write temporary data to file...</span><br><span class="line">Process: 1: begin to write temporary data to file...</span><br><span class="line">Process: 3: completed write...</span><br><span class="line">Process: 2: begin to write temporary data to file...</span><br><span class="line">Process: 0: begin to write temporary data to file...</span><br><span class="line">Process: 1: completed write...</span><br><span class="line">Process: 2: completed write...</span><br><span class="line">Process: 0: completed write...</span><br><span class="line">sorting chrosome: Gbar_A01...</span><br><span class="line">chrosome: Gbar_A01  ok...</span><br><span class="line">merge chrosomes to a single file...</span><br><span class="line">completed!</span><br><span class="line">there are some temporary file <span class="keyword">in</span> directory: &lt;./tmp1593916319&gt;</span><br><span class="line"><span class="keyword">if</span> you can remove it by yourself!</span><br><span class="line">Cost Time is 18.70</span><br></pre></td></tr></table></figure>

<h3 id="6-源代码"><a href="#6-源代码" class="headerlink" title="6.源代码"></a>6.源代码</h3><p><a href="https://github.com/BiocottonHub/zpliuCode/blob/master/Hi-c/HiCProTojuicer.py" target="_blank" rel="noopener">https://github.com/BiocottonHub/zpliuCode/blob/master/Hi-c/HiCProTojuicer.py</a></p>
<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h3><ol>
<li><a href="https://www.zhihu.com/question/63265466" target="_blank" rel="noopener">子进程挂起</a></li>
<li><a href="https://www.cnblogs.com/qiangyuge/p/7460852.html" target="_blank" rel="noopener">并发队列</a></li>
<li><a href="https://blog.csdn.net/onlyforr/article/details/52094581?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">文件分块</a></li>
<li><a href="https://www.cnblogs.com/guguobao/p/9398653.html" target="_blank" rel="noopener">进程通信</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/64702600" target="_blank" rel="noopener">多进程</a></li>
<li><a href="https://www.cnblogs.com/now-fighting/p/3534185.html" target="_blank" rel="noopener">OS模块</a></li>
<li><a href="https://blog.csdn.net/lucyxu107/article/details/82837282" target="_blank" rel="noopener">文件锁</a></li>
<li><a href="https://blog.csdn.net/weixin_39731083/article/details/82015830" target="_blank" rel="noopener">线程与进程区别</a></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>多线程读取文件</title>
    <url>/codeHub/2020/07/05/2020-07/01%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>血崩!! 今天写完一个多线程读取文件，发现多线程反而比但线程慢多了；最后还是改成了多进程版本。多线程向多进程的转换也非常的方便，</p>
<blockquote>
<h4 id="为什么Python多线程反而更慢了？"><a href="#为什么Python多线程反而更慢了？" class="headerlink" title="为什么Python多线程反而更慢了？"></a>为什么Python多线程反而更慢了？</h4><p>原因就在于 GIL ，在 Cpython 解释器（Python语言的主流解释器）中，有一把全局解释锁（Global Interpreter Lock），在解释器解释执行 Python 代码时，先要得到这把锁，意味着，任何时候只可能有一个线程在执行代码，其它线程要想获得 CPU 执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。</p>
<p>​    因此，这也就是为什么两个线程一起执行反而更加慢的原因，因为同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上下文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。</p>
</blockquote>
<a id="more"></a>

<h3 id="1-文件分块类"><a href="#1-文件分块类" class="headerlink" title="1.文件分块类"></a>1.文件分块类</h3><ul>
<li>定义一个分块类</li>
<li>根据线程数对文件进行分块</li>
<li>获取每个线程需要读取的坐标</li>
</ul>
<p>定义类的时候<code>class PartitionFile(object)</code>这种方式表示<code>PartitionFile</code>继承自<code>Object</code>类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定义分块类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionFile</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fileName, threadNum)</span>:</span></span><br><span class="line">        self.fileName = fileName</span><br><span class="line">        self.blockNum = threadNum</span><br></pre></td></tr></table></figure>

<p>定义对应的文件分块方法<code>partion</code>，最后返回每个区块文件的指针数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def partion(self):</span><br><span class="line">     fd = open(self.fileName, <span class="string">'r'</span>)</span><br><span class="line">     fd.seek(0, 2)  <span class="comment"># 移动文件指针到文件尾,用于获取文件大小</span></span><br><span class="line">     fileSize = fd.tell()  <span class="comment"># 获取文件字符数</span></span><br><span class="line">     Pos_list = []  <span class="comment"># 指针坐标，数组</span></span><br><span class="line">     blockSize = int(fileSize/self.blockNum)</span><br><span class="line">     start_Pos = 0  <span class="comment"># 文件初始指针</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(self.blockNum):</span><br><span class="line">         <span class="keyword">if</span> i == self.blockNum-1:</span><br><span class="line">             end_Pos = fileSize-1  <span class="comment"># 最后一个文件区块为文件结尾</span></span><br><span class="line">             Pos_list.append((start_Pos, end_Pos))</span><br><span class="line">             <span class="built_in">break</span></span><br><span class="line">         end_Pos = start_Pos+blockSize-1  <span class="comment"># 均匀分配每个区块</span></span><br><span class="line">         <span class="comment"># if end_Pos &gt;= fileSize:</span></span><br><span class="line">         <span class="comment">#   end_Pos=fileSize-1</span></span><br><span class="line">         <span class="comment"># if start_Pos &gt;= fileSize:</span></span><br><span class="line">         <span class="comment">#   break</span></span><br><span class="line">         Pos_list.append((start_Pos, end_Pos))</span><br><span class="line">         start_Pos = end_Pos+1  <span class="comment"># 下一个区块，开始坐标</span></span><br><span class="line">     fd.close()</span><br><span class="line">     <span class="built_in">return</span> Pos_list</span><br></pre></td></tr></table></figure>

<h3 id="2-读取文件线程类"><a href="#2-读取文件线程类" class="headerlink" title="2.读取文件线程类"></a>2.读取文件线程类</h3><p>类初始化需要传递6个参数</p>
<ul>
<li>线程编号</li>
<li>线程所属队列</li>
<li>文件名</li>
<li>文件区块其实指针</li>
<li>文件区块结束指针</li>
<li>自定义处理函数</li>
</ul>
<p>读取文件线程也可以称作<strong>生产者</strong>，继承自Thread类，在初始化是调用，初始化一个线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">readThread</span><span class="params">(Thread)</span>:</span>  <span class="comment"># 这个括号表示继承threading.Thread类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, thread_name, thread_queue, fileName, start_Pos, end_Pos, processFunction)</span>:</span></span><br><span class="line">        super(readThread, self).__init__()  <span class="comment"># 初始化一个线程</span></span><br><span class="line">        self.name = thread_name</span><br><span class="line">        self.queue = thread_queue</span><br><span class="line">        self.start_Pos = start_Pos</span><br><span class="line">        self.end_Pos = end_Pos</span><br><span class="line">        self.fileName = fileName</span><br><span class="line">        self.processFunction = processFunction</span><br></pre></td></tr></table></figure>

<p>类中读取数据的函数<code>reader</code></p>
<ul>
<li>根据文件区块指针，进行一行一行读取</li>
<li>将读取的数据交给<code>processFunction</code>自定义函数处理，过滤掉一些行或者转化一下格式</li>
<li>将过滤后的结果存进队列中</li>
</ul>
<p><code>self.queue.put(tmp, block=True)</code>主要是当队列中数据已经满了，还来不及取出时，阻塞当前线程，等待队列闲置空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(self)</span>:</span></span><br><span class="line">    fd = open(self.fileName, <span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">if</span> self.start_Pos != <span class="number">0</span>:</span><br><span class="line">        fd.seek(self.start_Pos<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> fd.read(<span class="number">1</span>) != <span class="string">'\n'</span>:  <span class="comment"># 当前初始位置不是行首,移动到下一行行首</span></span><br><span class="line">            fd.readline()</span><br><span class="line">            self.start_Pos = fd.tell()</span><br><span class="line">    fd.seek(self.start_Pos)  <span class="comment"># 将文件指针定位到区块的行首</span></span><br><span class="line">    <span class="keyword">while</span> self.start_Pos &lt;= self.end_Pos:  <span class="comment"># 开始按行读取文件并且进行操作</span></span><br><span class="line">        line = fd.readline()</span><br><span class="line">        tmp = self.processFunction(line)</span><br><span class="line">        <span class="keyword">if</span> tmp:  <span class="comment"># 判断数据是否需要放进队列</span></span><br><span class="line">            self.queue.put(tmp, block=<span class="literal">True</span>)  <span class="comment"># 阻塞队列等待有位置时就插入</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     self.start_Pos = fd.tell()</span></span><br><span class="line">        <span class="comment">#     continue</span></span><br><span class="line">        self.start_Pos = fd.tell()  <span class="comment"># 读完一行后，自动调整开始位置</span></span><br><span class="line">    fd.close()</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>启动线程函数</p>
<p>当线程启动是调用读取函数进行文件读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"线程"</span> + self.name+<span class="string">": 开始读取文件..."</span>)</span><br><span class="line">    self.reader()</span><br><span class="line">    print(<span class="string">"线程"</span> + self.name+<span class="string">": 读取完成..."</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="3-获取队列数据线程类"><a href="#3-获取队列数据线程类" class="headerlink" title="3.获取队列数据线程类"></a>3.获取队列数据线程类</h3><p>也被称为<strong>消费者</strong>线程，</p>
<p>初始化</p>
<ul>
<li>包含线程名</li>
<li>所属队列</li>
<li>以及初始化一个用于存放队列数据的数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">getThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, queue)</span>:</span></span><br><span class="line">        super(getThread, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        self.queue = queue</span><br><span class="line">        self.out = []</span><br></pre></td></tr></table></figure>

<p>获取队列数据<code>run</code>方法</p>
<ul>
<li>当线程启动时，就开始向队列取数据</li>
<li>如果在向队列取数据时，等待时间过长，之间关闭当前进程</li>
</ul>
<p><code>Queue.get</code>函数默认有一个<code>block=True</code>，的参数；当线程取不到数据时，就一直会进入等待</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.out.append(self.queue.get(timeout=<span class="number">2</span>))  <span class="comment"># 等待2s，读不到数据直接退出</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h3 id="4-函数封装"><a href="#4-函数封装" class="headerlink" title="4.函数封装"></a>4.函数封装</h3><p>为了实现代码的可重复利用，可以将这几个模块一起封装成一个函数</p>
<ul>
<li><code>defaultProcessFunction</code>默认自定义函数，不会对文件中行进行处理</li>
<li>定义生成者线程池</li>
<li>定义消费者生成池</li>
<li>等待所有线程池结束后，调用消费者线程的<code>getData</code>方法，获取所有数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">defaultProcessFunction</span><span class="params">(line)</span>:</span>  <span class="comment"># 对行数据不做处理的默认函数</span></span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readFileByThread</span><span class="params">(fileName, ThreadNum, processFunction=defaultProcessFunction)</span>:</span></span><br><span class="line">    out = []</span><br><span class="line">    <span class="comment"># 设置队列</span></span><br><span class="line">    workQueue = Queue()</span><br><span class="line">    <span class="comment"># 线程池</span></span><br><span class="line">    readThreads = []</span><br><span class="line">    getThreads = []</span><br><span class="line">    pos_list = PartitionFile(fileName, ThreadNum).partion()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pos_list)):</span><br><span class="line">        postion = pos_list[i]</span><br><span class="line">        mythread = readThread(str(i), workQueue, fileName,</span><br><span class="line">                              postion[<span class="number">0</span>], postion[<span class="number">1</span>], processFunction)  <span class="comment"># 初始化线程,设置预处理函数</span></span><br><span class="line">        mythread.start()  <span class="comment"># 启动线程</span></span><br><span class="line">        getdataThread = getThread(str(i), workQueue)</span><br><span class="line">        getdataThread.start()</span><br><span class="line">        readThreads.append(mythread)  <span class="comment"># 添加到线程池</span></span><br><span class="line">        getThreads.append(getdataThread)  <span class="comment"># 添加到线程池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> readThreads:</span><br><span class="line">        i.join()  <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> getThreads:</span><br><span class="line">        i.join()  <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> getThreads:</span><br><span class="line">        out += i.getData()</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<h3 id="5-性能测试"><a href="#5-性能测试" class="headerlink" title="5.性能测试"></a>5.性能测试</h3><p>由于测试文件只有20万行，进程间的调度也会消耗时间，所有有可能出现多进程比单进程慢一丢丢的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.clock()</span><br><span class="line">    readFileByThread(sys.argv[<span class="number">1</span>], int(sys.argv[<span class="number">2</span>]))</span><br><span class="line">    end_time = time.clock()</span><br><span class="line">    print(<span class="string">'Cost Time is &#123;:.2f&#125;'</span>.format(end_time-start_time))</span><br></pre></td></tr></table></figure>

<ul>
<li>多线程模式下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##单个线程情况</span></span><br><span class="line">线程0: 开始读取文件...</span><br><span class="line">线程0: 读取完成...</span><br><span class="line">Cost Time is 2.61</span><br><span class="line"><span class="comment">## 4个线程情况</span></span><br><span class="line">线程0: 开始读取文件...</span><br><span class="line">线程1: 开始读取文件...</span><br><span class="line">线程2: 开始读取文件...</span><br><span class="line">线程3: 开始读取文件...</span><br><span class="line">线程2: 读取完成...</span><br><span class="line">线程1: 读取完成...</span><br><span class="line">线程0: 读取完成...</span><br><span class="line">线程3: 读取完成...</span><br><span class="line">Gbar_A01</span><br><span class="line">Cost Time is 17.77</span><br></pre></td></tr></table></figure>

<h3 id="6-源代码"><a href="#6-源代码" class="headerlink" title="6.源代码"></a>6.源代码</h3><p><a href="https://github.com/BiocottonHub/zpliuCode/blob/master/Hi-c/readFileByThread.py" target="_blank" rel="noopener">https://github.com/BiocottonHub/zpliuCode/blob/master/Hi-c/readFileByThread.py</a></p>
<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h3><ol>
<li><a href="https://blog.csdn.net/GeekLeee/article/details/77883252" target="_blank" rel="noopener">Queue队列</a></li>
<li><a href="https://blog.csdn.net/aa57255621/article/details/88965975" target="_blank" rel="noopener">多线程爬取数据</a></li>
<li><a href="https://www.runoob.com/python/python-func-super.html" target="_blank" rel="noopener">super父类</a></li>
<li><a href="https://www.runoob.com/python/file-seek.html" target="_blank" rel="noopener">文件指针</a></li>
<li><a href="https://blog.csdn.net/onlyforr/article/details/52094581?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">文件分块</a></li>
<li><a href="https://fishc.com.cn/thread-115047-1-1.html" target="_blank" rel="noopener">python继承类</a></li>
<li><a href="https://www.cnblogs.com/xiangsikai/p/8185031.html" target="_blank" rel="noopener">Queue</a></li>
<li><a href="https://www.cnblogs.com/wt11/p/5952500.html" target="_blank" rel="noopener">Queue取数据</a></li>
<li><a href="https://www.zhihu.com/question/63265466" target="_blank" rel="noopener">子进程不结束</a></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>数据备份!</title>
    <url>/codeHub/2020/06/23/2020-06/07%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p>俗话说：不怕万一就怕一万一，数据备份真的很重要，经历了一次数据库数据的丢失，现在每次我都小心翼翼！</p>
<p>数据库备份</p>
<p>通常大家都是使用phpmyadmin直接图形化的界面进行数据的导入和导出，在数据库导入的时候要注意，mysql中要含有和你备份的数据库一样的名字，不然会报错</p>
<h3 id="命令行下的mysql备份："><a href="#命令行下的mysql备份：" class="headerlink" title="命令行下的mysql备份："></a>命令行下的mysql备份：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p 数据库名 &gt;dump.sql（备份文件以sql为后缀）</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="wordpress文件的备份"><a href="#wordpress文件的备份" class="headerlink" title="wordpress文件的备份"></a>wordpress文件的备份</h3><p>这个比较简单粗暴，直接tar就行</p>
<p><code>tar -cvzf 20190329wordpressbk.tar.gz ./*wordpress</code></p>
<p>安装目录下的所有文件</p>
<p>这里有一个小技巧，就是tar命令如何排除一些你不需要打包的目录</p>
<p><code>tar -cvzf 20190329wordpressbk.tar.gz --exclude=./log ./*wordpress</code></p>
<p>安装目录下的所有文件</p>
<p>log为日志目录，就不备份了，注意这里的log后面的/</p>
<h3 id="多个地方存放"><a href="#多个地方存放" class="headerlink" title="多个地方存放"></a>多个地方存放</h3><p>数据备份好了，那也不放心啊！俗话说狡兔三窟，我就备份在了三个地方</p>
<p>1.服务器</p>
<p>2.本地电脑</p>
<p>3.github</p>
<p>其他的备份方式我就不做介绍了，主要介绍github的备份方式</p>
<h4 id="github备份"><a href="#github备份" class="headerlink" title="github备份"></a>github备份</h4><p>1.首先使用私匙与github账号关联</p>
<p>2.创建仓库repositories</p>
<p>3.命令行上传</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add ./back up file </span><br><span class="line">git commit -m <span class="string">"date"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>我进行备份是文件大小超过了50M，github不给上传</p>
<blockquote>
<p>remote: warning: File sources/wordpress_bk20190330.tar.gz is 51.15 MB;<br>this is larger than GitHub’s recommended maximum file size of 50.00 MB</p>
</blockquote>
<p>看来还是得换个办法，就勉强用用我们不务正业的百度网盘进行备份，就是速度有点慢</p>
<h4 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h4><p>1.克隆仓库代码</p>
<p>2.将百度账户与服务器进行关联： <a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=https://openapi.baidu.com/device" target="_blank" rel="noopener">设置链接</a></p>
<p>3.使用上传脚本进行文件上传</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/oott123/bpcs_uploader.git</span><br><span class="line">chmod +x bpcs_uploader.php </span><br><span class="line">./bpcs_uploader.php quickinit</span><br><span class="line"><span class="comment">#脚本执行后，会告诉验证码</span></span><br><span class="line"><span class="comment">#Uploader initialization will be begin. If you have already configured the uploader before, your old settings will be overwritten.</span></span><br><span class="line">Continue? [y/N] y</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   344  100   264  100    80    332    100 --:--:-- --:--:-- --:--:--   332</span><br><span class="line">Launch your favorite web browser and visit https://openapi.baidu.com/device</span><br><span class="line">Input 验证码在这 as the user code <span class="keyword">if</span> asked.</span><br><span class="line">After granting access to the application, come back here and press Enter to <span class="built_in">continue</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行文件上传</span></span><br><span class="line">./bpcs_uploader.php upload ../../Bioinformatic/sources/wordpressbk20190330.sql  wordpressbk20190330.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行文件下载</span></span><br><span class="line">./bpcs_uploader.php download [path_local] [path_remote]</span><br><span class="line"></span><br><span class="line"><span class="comment">#云端文件的删除</span></span><br><span class="line"></span><br><span class="line">./bpcs_uploader/bpcs_uploader.php delete [remote path]</span><br></pre></td></tr></table></figure>

<p>备份后数数据默认是存在 <code>百度云/我的应用数据/bpcs_uploader/</code> 目录下；而且这个目录好像还不能修改</p>
<h3 id="自动备份脚本"><a href="#自动备份脚本" class="headerlink" title="自动备份脚本"></a>自动备份脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment">#author:zpliu</span></span><br><span class="line"><span class="comment">#date:20190331</span></span><br><span class="line"><span class="comment">#application for backup data to Baidu cloud</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">yesterday=`date -d <span class="string">"1 day ago"</span> +<span class="string">"%Y%m%d"</span>`</span><br><span class="line">today=`date +<span class="string">"%Y%m%d"</span>`</span><br><span class="line">mysqluser=登录数据库账户</span><br><span class="line">mysqlpassword=密码</span><br><span class="line"><span class="comment">#备份数据库文件</span></span><br><span class="line">/usr/bin/mysqldump -u <span class="variable">$mysqluser</span>  -p<span class="variable">$mysqlpassword</span>  wordpress &gt;/var/www/clound/wordpress<span class="variable">$&#123;today&#125;</span>_bk.sql 2&gt;/dev/null</span><br><span class="line"><span class="comment">#备份wordpress文件</span></span><br><span class="line"><span class="built_in">echo</span> 文件权限的问题提供的root密码|sudo -S /usr/bin/tar -cPzf /var/www/clound/wordpress<span class="variable">$&#123;today&#125;</span>_bk.tar.gz /var/www/html/*</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行文件上传</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"/var/www/clound/wordpress<span class="variable">$&#123;today&#125;</span>_bk.sql"</span> -a -f <span class="string">"/var/www/clound/wordpress<span class="variable">$&#123;today&#125;</span>_bk.tar.gz"</span> ];<span class="keyword">then</span></span><br><span class="line">/var/www/clound/bpcs_uploader/bpcs_uploader.php upload /var/www/clound/wordpress<span class="variable">$&#123;today&#125;</span>_bk.sql wordpress<span class="variable">$&#123;today&#125;</span>_bk.sql 1&gt;&gt;/var/www/clound/upload.log 2&gt;/dev/null &amp;&amp;rm -rf wordpress<span class="variable">$&#123;yesterday&#125;</span>_bk.sql</span><br><span class="line">/var/www/clound/bpcs_uploader/bpcs_uploader.php upload /var/www/clound/wordpress<span class="variable">$&#123;today&#125;</span>_bk.tar.gz wordpress<span class="variable">$&#123;today&#125;</span>_bk.tar.gz 1&gt;&gt;/var/www/clound/upload.log 2&gt;/dev/null &amp;&amp;rm -rf wordpress<span class="variable">$&#123;yesterday&#125;</span>_bk.tar.gz</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>脚本其实很简单就是，导出数据库以及对wordpress进行打包，最后对当前目录进行判断，同时删除以前的备份，节省空间</p>
<p>而百度云盘是上的文件倒是可以想删就删，自己动动手一块删一个时间段的就行了</p>
<h3 id="crontab-执行定时任务"><a href="#crontab-执行定时任务" class="headerlink" title="crontab 执行定时任务"></a>crontab 执行定时任务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">在vim中编写配置信息如下</span><br><span class="line"></span><br><span class="line">0 2 * * * bash  脚本执行路径</span><br></pre></td></tr></table></figure>

<p>每天凌晨两点进行文件备份，明天来看看能不能备份好</p>
<p>报错：<code>MAIL (mailed 144 bytes of output but got status 0x004b#012)</code></p>
<p>原因有几点：</p>
<p>1.命令执行过程中需要加上绝对路径</p>
<p>2.在crontab -e 编辑模式中需要 加上bash 脚本绝对路径</p>
<p>3.在与百度的进行连接的时候，报错了；重新获取验证码进行连接</p>
<p><code>API calling error 100 : Invalid parameter</code></p>
<h4 id="最后脚本每天定时在凌晨2点执行，并且在日志文件中记录着成功的记录"><a href="#最后脚本每天定时在凌晨2点执行，并且在日志文件中记录着成功的记录" class="headerlink" title="最后脚本每天定时在凌晨2点执行，并且在日志文件中记录着成功的记录"></a>最后脚本每天定时在凌晨2点执行，并且在日志文件中记录着成功的记录</h4><p><code>File /apps/bpcs_uploader/wordpress20190401_bk.sql uploaded.
Size:1282.812K MD5 Sum:fd4b82eda2347f0979bcc395da11d000</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_31655965/article/details/53288316" target="_blank" rel="noopener">https://blog.csdn.net/qq_31655965/article/details/53288316</a></p>
<p>crontab：<a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=https://www.cnblogs.com/zoulongbin/p/6187238.html" target="_blank" rel="noopener">点击查看</a></p>
]]></content>
  </entry>
  <entry>
    <title>聚类</title>
    <url>/codeHub/2020/06/23/2020-06/06%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>人以类聚，物以群分。在当今大数据的时代，利用机器学习的方法对大样本、大数据进行量化、根据每个数据的特征值进行分类，打标签；从而挖掘数据的价值，例如商家根据用户群体的分类，和标签定向的推送广告。对数据的聚类有多种方式，其中最经典的就是，基于数据密度和基于数据层次进行聚类。</p>
<a id="more"></a>

<h3 id="基于密度聚类"><a href="#基于密度聚类" class="headerlink" title="基于密度聚类"></a>基于密度聚类</h3><blockquote>
<p>Density Base spatial clustering of application with noise</p>
</blockquote>
<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>密度聚类算法：假设通过样本数据之间分布的紧密程度，能够反应数据的聚类结构；这是算法的假定前提。算法的具体实现通常基于样本之间的可连接性，将可以连接的样本聚在一类，并不断扩大聚类簇，获得最终的聚类结果</p>
<p>1.ε-：定义一个样本的邻近区域：该区域包含在数据集D中与给定样本点Xj的距离小于ε-的样本点；</p>
<p>2.核心对象： 样本点Xj邻域范围内包含的样本点数目，大于等于阀值MinPts</p>
<p>3.密度直达：X1位于X2的邻域范围内，同时X2为核心对象（跟很多人有关系），则X1则由X2密度直达</p>
<p>4.密度可达：两个样本点通过一系列密度直达样本对（Xi，Xi+1）建立联系</p>
<p>5.密度相连：两个样本同时和某一个样本点密度可达</p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/NtKcVK.png" alt="密度聚类概念"></p>
<h4 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h4><p>密度聚类中，同一簇中密度相连数满足最大，密度可达满足最大；不难推出当同一类样本中密度可达达到最大时，就满足优化目标</p>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>1.假定邻域距离ε- 与Minpts样本数目</p>
<p>2.计算样本中核心对象数据集Ω</p>
<p>3.随机获取核心数据集中的一个核心对象最为种子</p>
<p>4.根据递归迭代思想，对数据集进行迭代，当第一个随机核心对象组成的簇满足优化目标时，将第一簇数据从数据集中剔除，进入下一次迭代</p>
<p>5.直至所有核心对象被迭代完毕，聚类就结束</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1.MinPat设置的是整个数据集的邻域的最小样本数，但是并不是每一类中的密度都大于等于MinPat。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/NtKf8H.png" alt="NtKf8H.png"></p>
<p>当阀值提高后C3样本点会被当成噪音处理</p>
<p>2.当一个数据点在两个核心数据对象之间时，算法默认将数据点归类到先迭代的核心对象；因此算法不稳定</p>
<p>3.根据密度聚类的思想聚类时，有一些点与所有的核心对象都不相连时，会被算法默认为噪音</p>
<h3 id="基于层次聚类"><a href="#基于层次聚类" class="headerlink" title="基于层次聚类"></a>基于层次聚类</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>层次聚类：在不同层次之间对数据集进行划分；形成类似树形的聚类结果，在划分时可以采用“自底向上”与“自顶向下”进行聚类。</p>
<p>1.自底向上：先将每个样本看成一类，接着对所有进行聚类</p>
<p>2.自顶向下：所有样本看成一类，依次对数据集进行拆分聚类</p>
<h4 id="AGNES算法"><a href="#AGNES算法" class="headerlink" title="AGNES算法"></a>AGNES算法</h4><p>不同类之间的距离度量：</p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/NtKIKI.png" alt="NtKIKI.png"></p>
<p>其中最小距离由两个簇中最近的样本点决定；最大距离则由最远样本点决定；平均距离有所有样本共同决定。也被形象的称为“单链接”、“全链接”、“均链接”。</p>
<h4 id="应用范围："><a href="#应用范围：" class="headerlink" title="应用范围："></a>应用范围：</h4><p>最小值: 这种方法容易受到极端值的影响。</p>
<p>最大值:容易受到极端值的影响.</p>
<p>均值:这种方法计算量比较大，但结果比前两种方法更合理。</p>
<h4 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h4><p>1.计算所有样本点两两之间的距离矩阵</p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/NtKort.png" alt="距离矩阵"></p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>1.主要应用在数据量比较小的时候</p>
<p>2.算法稳定性比较好</p>
<p>3.选择不同的距离衡量，往往有不同的结果</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>机器学习[周志华版]</p>
<p><a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=https://www.cnblogs.com/zongfa/p/9344769.html" target="_blank" rel="noopener">层次聚类</a></p>
<p><a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=https://www.jianshu.com/p/0f33ed1c38b9" target="_blank" rel="noopener">密度聚类</a></p>
]]></content>
  </entry>
  <entry>
    <title>PCA降维打击</title>
    <url>/codeHub/2020/06/23/2020-06/05PCA%E9%99%8D%E7%BB%B4%E6%89%93%E5%87%BB/</url>
    <content><![CDATA[<h3 id="1-PCA的基本原理"><a href="#1-PCA的基本原理" class="headerlink" title="1.PCA的基本原理"></a>1.PCA的基本原理</h3><p>主成分分析（Principle component analysis）简称PCA，是常用的降维方法之一。通过将n维的数据集降维到n’低纬度空间；使得降维之后数据集尽可能的代表原数据集同时降维之后的损失尽可能的小。</p>
<p>如图1所示，在R中使用rnorm函数生成正态分布数据集在二维空间的分布；我们希望找到一个维度能够代表数据集在二维空间中的分布特征，而这样的维度有无数种.如何找到最好的那个维度使得数据集经过变换后尽可能的保留原始数据集的特征。</p>
<a id="more"></a>

<p>​    图1中有V1与V2两个一维的特征向量，从图1中可以看出在V1特征向量上能够更好的反应原始数据集的特征。数据集映射在V1的方向上进行映射后，映射后的数据集从低纬度重构出高纬度数据集D’，使得D’与原始数据集尽可能的相似，也就是D’中的点与原始数据集中的点的距离最小；或者可以从另一个角度理解为原始数据经过映射后在低纬空间中可以区分开来。这对应着PCA中两种优化目标：最近重构性与最大可分性。同样的当数据集从二维推广到任意维度时，我们的优化目标也就变成样本点在一个超平面进行重构后的距离最近或者在映射到超平面后样本内方差最大化。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/NtuZY4.png" alt="图1:随机3类数据集的在二维平面的分布"></p>
<h3 id="2-1基于最近重构性进行优化"><a href="#2-1基于最近重构性进行优化" class="headerlink" title="2.1基于最近重构性进行优化"></a>2.1基于最近重构性进行优化</h3><p>假定我们有一个m个n维的数据集 ，假定在每个维度上都进行了中心化，并且将原先的n维属性投影到新的坐标系使得这n个维度的属性构成标准的正交基向量 )，即任意两个w满足 ；进行正交化主要是考虑在降维的过程中，任意两个主成分之间应该尽可能的保留更多的信息，不存在相关性。</p>
<p>假设将数据从n维降到k维（k&lt;n）,则第样本点 在k维的投影坐标  其中 表示样本i在降维后第j个维度上的投影坐标。通过投影坐标 与标准正交基向量 )重构出原始数据 。</p>
<p>优化目标是使得所有重构出的样本与原始样本的累积距离最小。</p>
<p><a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=http://www.cnblogs.com/pinard/p/6239403.html" target="_blank" rel="noopener">具体的公式推导</a>可以看这个博主写的</p>
<h3 id="2-2基于最大可分性进行优化"><a href="#2-2基于最大可分性进行优化" class="headerlink" title="2.2基于最大可分性进行优化"></a>2.2基于最大可分性进行优化</h3><p>​    从最大可分性角度出发，优化目标是使得样本点在降维后的平面的投影尽可能的分开，相当于投影后的样本方差最大。</p>
<h3 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3.算法流程"></a>3.算法流程</h3><p>​    假定数据集包含m个n维数据。</p>
<ul>
<li>将原始数据按照n行m列进行排列</li>
<li>在每一个维度上进行中心化，也就是每个数据减去同一行中的均值方便后面的计算</li>
<li>计算数据集的协方差矩阵</li>
<li>对协方差求取特征值与特征向量</li>
<li>将特征向量 按照其特征值大小从上至下排列成矩阵</li>
<li>根据认为设定的K值，将数据集映射到K维的低纬空间</li>
</ul>
<h3 id="4-1实例"><a href="#4-1实例" class="headerlink" title="4.1实例"></a>4.1实例</h3><p>​    随机生成1000个3维数据集，并对其中的点打上标签如图2所示。当保留样本中65%的变异时，才使得数据集从3维降低到2维，如图3所示；而此时黄色和绿色样本之间仍旧没有完全区分开来可能是由于它们之间的区分确实不明显。同样从图3中也可以发现一些样本偏离比较远，在某种程度上可以认为是人为因素产生的噪声数据</p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/Ntulm6.png" alt="图2：1000个随机数据集的分布，其中不同颜色代表不同的类型"></p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/Ntu10K.png" alt="图3：1000个数据在PCA降维后的分布"></p>
<h3 id="4-2图片数据降维"><a href="#4-2图片数据降维" class="headerlink" title="4.2图片数据降维"></a>4.2图片数据降维</h3><p>使用UCI中的Yale数据集，数据集中包括了21个志愿者在四种心情状态，4种角度以及是否戴眼镜的图片数据。从中随机选取了10位志愿者，在某一种状态下进行图片数据的降维处理。从图4可以看出当保留原始数据90%的差异时，图片与原图的差异不是很大，但仍旧有一些图片还是与原始数据相比丢失的比较多；随着保留差异程度逐渐减少，重构数据相比原始数据丢失的越来越多，在图片上表现也就越来越不清晰。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/NtusAS.png" alt="图4从左边拍摄10名志愿者愤怒时的图片分别保留其90%、80%、70%差异进行重构图片"></p>
<p>对带上眼镜的图片数据进行同样的处理，如图4所示当保留90%的差异进行重构时，仍旧可以看出大概。通过PCA的简单降维，可以在保证图片质量的情况下牺牲图片的清晰度；一定程度上节省了带宽。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/23/Ntu6hQ.png" alt="图5 从左边拍摄10名志愿者愤怒时带眼镜的图片分别保留其90%、80%、70%差异进行重构图片"></p>
<h3 id="5总结"><a href="#5总结" class="headerlink" title="5总结"></a>5总结</h3><ul>
<li>PCA计算方法简单，运用了矩阵特征值分解</li>
<li>计算过程中使用协方差矩阵，保证了各个维度之间不会有相互影响，使得特征值分解时数据存在重叠的情况</li>
<li>PCA降维后的特征值在解释程度上不如原始样本</li>
<li>舍弃的一些方差信息，有时候可能是区分一些特定样本的重要信息</li>
<li>使用核化的方法对复杂数据进行PCA</li>
</ul>
<h3 id="6数据集与代码"><a href="#6数据集与代码" class="headerlink" title="6数据集与代码"></a>6数据集与代码</h3><h4 id="6-1图片加载函数"><a href="#6-1图片加载函数" class="headerlink" title="6.1图片加载函数"></a>6.1图片加载函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">单张图片的读取与图片向矩阵数据的转换</span></span><br><span class="line"><span class="string">    #p2与p4可以正常读取</span></span><br><span class="line"><span class="string">    img = Image.open("D:\\pycharm\\project\\pca\\faces\\an2i\\an2i_left_angry_open_2.pgm")</span></span><br><span class="line"><span class="string">    #颜色变成黑白，本来就是黑白的就省去这一步就行了</span></span><br><span class="line"><span class="string">    img2=img.convert("L")</span></span><br><span class="line"><span class="string">    img2.show()</span></span><br><span class="line"><span class="string">    data=img.getdata()</span></span><br><span class="line"><span class="string">    data=np.matrix(data)</span></span><br><span class="line"><span class="string">    print(data)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadpgm</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    first_file=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(filepath):</span><br><span class="line">        <span class="comment">#人名</span></span><br><span class="line">        rootpicture=root.split(<span class="string">"\\"</span>)[<span class="number">-1</span>]+<span class="string">".jpeg"</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment">#print(os.path.splitext(file)[0][-1])</span></span><br><span class="line">            <span class="comment">#文件后缀名</span></span><br><span class="line">            <span class="keyword">if</span> first_file:</span><br><span class="line">                <span class="keyword">if</span> os.path.splitext(file)[<span class="number">0</span>][<span class="number">-23</span>::] == <span class="string">"left_angry_sunglasses_2"</span>:</span><br><span class="line">                    img = Image.open((os.path.join(root, file)))</span><br><span class="line">                    oneperson = img.getdata()</span><br><span class="line">                    img.save(rootpicture)</span><br><span class="line">                    oneperson = np.array(oneperson).tolist()</span><br><span class="line">                    first_file=<span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> os.path.splitext(file)[<span class="number">0</span>][<span class="number">-23</span>::] == <span class="string">"left_angry_sunglasses_2"</span>:</span><br><span class="line">                    img = Image.open((os.path.join(root, file)))</span><br><span class="line">                    rootimg = Image.fromarray(np.array(img.getdata())).convert(<span class="string">"RGB"</span>)</span><br><span class="line">                    rootimg.save(rootpicture)</span><br><span class="line">                    oneperson=oneperson+(np.array(img.getdata()).tolist())</span><br><span class="line">                <span class="comment">#img.show()</span></span><br><span class="line">                <span class="comment">#print(img.size)</span></span><br><span class="line">    <span class="keyword">return</span> np.array(oneperson)</span><br></pre></td></tr></table></figure>

<h4 id="6-2文件读取函数"><a href="#6-2文件读取函数" class="headerlink" title="6.2文件读取函数"></a>6.2文件读取函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">(path)</span>:</span></span><br><span class="line">    file = open(path)</span><br><span class="line">    next(file)</span><br><span class="line">    first_else = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> file.readlines():</span><br><span class="line">        data = data.strip(<span class="string">"\n"</span>)</span><br><span class="line">        nums = data.split(<span class="string">"\t"</span>)[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> first_else:</span><br><span class="line">            matrix = np.array(nums)</span><br><span class="line">            first_else = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            matrix = np.c_[matrix, nums]</span><br><span class="line">    file.close()</span><br><span class="line">    <span class="comment"># 矩阵为n*m，m为样本数</span></span><br><span class="line">    <span class="keyword">return</span> np.mat(matrix).astype(float)</span><br></pre></td></tr></table></figure>

<h4 id="6-3数据中心化"><a href="#6-3数据中心化" class="headerlink" title="6.3数据中心化"></a>6.3数据中心化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zeroScale</span><span class="params">(dataset)</span>:</span></span><br><span class="line">    <span class="comment"># 对数据集按行求平均</span></span><br><span class="line">    meanVals = np.mean(dataset, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 中心化</span></span><br><span class="line">    zerodata = dataset - meanVals</span><br><span class="line">    <span class="keyword">return</span> zerodata</span><br></pre></td></tr></table></figure>

<h4 id="6-4特征值范围"><a href="#6-4特征值范围" class="headerlink" title="6.4特征值范围"></a>6.4特征值范围</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eigvalPc</span><span class="params">(eigVals, precentages)</span>:</span></span><br><span class="line">    <span class="comment"># 特征值从大到小排序</span></span><br><span class="line">    sortArray = np.sort(eigVals)[::<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 百分比</span></span><br><span class="line">    arrSum = sum(sortArray)</span><br><span class="line">    tmpSum = <span class="number">0</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sortArray:</span><br><span class="line">        tmpSum += i</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tmpSum/arrSum &amp;gt;= precentages:</span><br><span class="line">            <span class="comment">##返回最后的特征值下标</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<h4 id="6-5PCA函数"><a href="#6-5PCA函数" class="headerlink" title="6.5PCA函数"></a>6.5PCA函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(dataset, precentages)</span>:</span></span><br><span class="line">    meanVals = np.mean(dataset, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 中心化</span></span><br><span class="line">    zerodata = zeroScale(dataset)</span><br><span class="line">    <span class="comment"># 计算协方差矩阵</span></span><br><span class="line">    covMat = np.cov(zerodata)</span><br><span class="line">    eigVals, eigVects = np.linalg.eig(np.mat(covMat))</span><br><span class="line">    k = eigvalPc(eigVals, precentages)</span><br><span class="line">    <span class="comment"># 获取对应的特征值排好序的下标</span></span><br><span class="line">    eigIndex = np.argsort(eigVals)[::<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 获取对应的特征向量下标</span></span><br><span class="line">    eigIndex = eigIndex[<span class="number">0</span>:k + <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 获取主成分特征向量</span></span><br><span class="line">    eigPCA = eigVects[:, eigIndex]</span><br><span class="line">    <span class="comment"># 原始数据投影到低纬数据</span></span><br><span class="line">    lowDimdata = np.transpose(zerodata) * eigPCA</span><br><span class="line">    <span class="comment">#重构数据</span></span><br><span class="line">    reconMat=(lowDimdata*np.transpose(eigPCA))+np.transpose(meanVals)</span><br><span class="line">    <span class="comment">#np.savetxt(outfile, reconMat, delimiter="\t")</span></span><br><span class="line">    <span class="keyword">return</span>  reconMat</span><br></pre></td></tr></table></figure>

<h4 id="6-5图片生成与保存"><a href="#6-5图片生成与保存" class="headerlink" title="6.5图片生成与保存"></a>6.5图片生成与保存</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> loadpgm <span class="keyword">import</span> loadpgm</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">"D:\\pycharm\\project\\pca\\faces\\"</span>):</span><br><span class="line">        first_person = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</span><br><span class="line">            filepath = (os.path.join(root, dir))</span><br><span class="line">            <span class="keyword">if</span> first_person:</span><br><span class="line">                dataset = loadpgm(filepath)</span><br><span class="line">                first_person = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dataset = np.column_stack((dataset, loadpgm(filepath)))</span><br><span class="line">    <span class="comment">#数据矩阵化</span></span><br><span class="line">    dataset=np.mat(dataset)</span><br><span class="line">    out=pca(dataset,<span class="number">0.7</span>)</span><br><span class="line">    <span class="comment">#10张图片10*3840每张图片为60X64</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        outpicture=str(i)+<span class="string">".jpeg"</span></span><br><span class="line">        picture1 = (out[i].reshape(<span class="number">60</span>, <span class="number">64</span>))</span><br><span class="line">        <span class="comment"># 保存重构图片数据</span></span><br><span class="line">        picture1 = np.real(picture1)</span><br><span class="line">        picture1 = Image.fromarray(picture1).convert(<span class="string">"RGB"</span>)</span><br><span class="line">        picture1.save(outpicture)</span><br></pre></td></tr></table></figure>

<p>图片数据与PCA源代码上传到我的<a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=https://github.com/zpliu1126/Machine-Learn/tree/master/pca" target="_blank" rel="noopener">github仓库</a>中</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><strong>1.</strong>机器学习[周志华版]</p>
<p><strong>2.</strong>PCA定义：<a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=http://blog.codinglabs.org/articles/pca-tutorial.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/pca-tutorial.html</a></p>
<p><strong>3.</strong>公式推导：<a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=http://www.cnblogs.com/pinard/p/6239403.html" target="_blank" rel="noopener">http://www.cnblogs.com/pinard/p/6239403.html</a></p>
<p><strong>4.</strong>主要代码：<a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=http://www.cnblogs.com/chenbjin/p/4200790.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenbjin/p/4200790.html</a></p>
<p><strong>5.</strong>pgm数据处理：<a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=https://blog.csdn.net/xijuezhu8128/article/details/79661016" target="_blank" rel="noopener">https://blog.csdn.net/xijuezhu8128/article/details/79661016</a></p>
<p><strong>6.</strong>numpy包处理：<a href="http://211.69.141.138/wp-content/themes/begin%2Blts/inc/go.php?url=https://blog.csdn.net/qq_43287650/article/details/83211898" target="_blank" rel="noopener">https://blog.csdn.net/qq_43287650/article/details/83211898</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>简单实现python多进程</title>
    <url>/codeHub/2020/06/22/2020-06/04python%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>在处理特别大的数据的时候，尤其是多重循环。例如对2万个基因进行一个计算，每个基因的计算需要进行1亿次比较。仅仅使用一个主进程进行计算就显得十分吃力；于是学习了python多进程的的处理，极大的缩短了脚本的运行时间。</p>
<img data-src="https://s1.ax1x.com/2020/06/22/NJ9bMd.png" alt="小猪" style="zoom:50%;" />

<a id="more"></a>

<ul>
<li>首先根据进程数，来分配任务</li>
<li>将所有的进程加入进程池</li>
<li>启动多个进程任务时，阻塞当前主进程</li>
<li>待多进程任务完成后，在主进程中将结果输出</li>
</ul>
<h3 id="分配任务"><a href="#分配任务" class="headerlink" title="分配任务"></a>分配任务</h3><ul>
<li><code>ProcessNum</code>从命令行从获取进程数</li>
<li>根据进程数，平均分配任务给每个进程；最后一个进程负责除不尽的任务</li>
<li><code>p.apply_async</code>给每个进程指定调用的函数和参数</li>
<li><code>p.close()</code>所有进程任务指定完毕，开始执行进程任务</li>
<li><code>p.join()</code>阻塞主进程，等待子进程任务完成</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">with</span> open(args.AS, <span class="string">'r'</span>) <span class="keyword">as</span> File:</span><br><span class="line">    data = File.readlines()</span><br><span class="line">    ProcessNum = int(args.p)</span><br><span class="line">    average = int(len(data)/ProcessNum)</span><br><span class="line">    p = multiprocessing.Pool(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">for</span> processId <span class="keyword">in</span> range(<span class="number">0</span>, ProcessNum):</span><br><span class="line">        <span class="keyword">if</span> processId == ProcessNum<span class="number">-1</span>:</span><br><span class="line">            start = processId*average</span><br><span class="line">            end = len(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = processId*average</span><br><span class="line">            end = (processId+<span class="number">1</span>)*average</span><br><span class="line">        out.append(p.apply_async(mulProcessPSI,</span><br><span class="line">                                 (data[start:end], processId+<span class="number">1</span>)))</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<h3 id="获取进程结果"><a href="#获取进程结果" class="headerlink" title="获取进程结果"></a>获取进程结果</h3><ul>
<li><code>out</code>数组中存着每个进程计算的结果</li>
<li><code>get()</code>对每个进程调用get方法获得结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(args.o, <span class="string">'w'</span>) <span class="keyword">as</span> File:</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> out:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> result.get():</span><br><span class="line">            File.write(item)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/06/22/NJA8P0.png" alt="运行结果"></p>
<h3 id="仍需学习的"><a href="#仍需学习的" class="headerlink" title="仍需学习的"></a>仍需学习的</h3><ul>
<li>多个进程进行文件写入时，涉及谁先写，谁后写的问题；需要使用到文件锁</li>
<li>进程间通信问题</li>
<li>内存溢出问题，多个进程的结果合并后太大了</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://zhuanlan.zhihu.com/p/64702600" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64702600</a></li>
<li><a href="https://www.cnblogs.com/jiangfan95/p/11439207.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangfan95/p/11439207.html</a></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>番茄中广泛的结构变异对基因表达和性状改良中的作用</title>
    <url>/codeHub/2020/06/21/2020-06/03%E7%95%AA%E8%8C%84panSV/</url>
    <content><![CDATA[<p>​    </p>
<p>本文通讯作者</p>
<img data-src="https://www.cshl.edu/wp-content/uploads/2018/10/Lippman-Zachary.jpg"  style="zoom:25%;  float:left; margin-right:20px" />



<p>1.研究植物开花和花的发育</p>
<p>2.整合遗传学、基因组学和基因编辑技术研究植物分生细胞发育成花中的分子机制</p>
<p>3.利用新的概念和工具进行遗传改良</p>
<div style="clear:both"></div>

<p>冷泉巷实验室:<a href="https://www.cshl.edu/research/faculty-staff/zachary-lippman/" target="_blank" rel="noopener"><strong>Zachary</strong> <strong>Lippman</strong></a></p>
<img data-src="http://schatz-lab.org/images/2015-Schatz.JPG"  style="zoom:100%;  float:left; margin-right:20px" />

<p>1.主要研究基因组的结构和功能</p>
<p>2.针对大规模生物数据，开发新的算法和软件</p>
<p>3.研究 single molecule sequencing，单细胞数据分析</p>
<div style="clear:both"></div>

<p>约翰霍普金斯大学 <a href="http://schatz-lab.org/" target="_blank" rel="noopener"><strong>Michael Schatz</strong></a></p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>结构变异是一种基因组间的序列差别，构成了作物改良和驯化的基础。由于短序列测序技术的限制，分析SVs差异的程度以及量化对性状的影响程度，一直非常困难。通过对100个番茄野生株系使用nannpore测序，与标准基因组比较后鉴定到238490个SVs。结合这些panSv数据以及组织了14份新的参考基因组，表明不同基因型材料间存在大规模的混合，大量的SVs与基因区、cir-regulation区存在交集。与此同时数百个SV-gene表现出基因表达水平的改变，这可能影响数量性状位点。通过结合数量性状和基因组编辑技术，作者发现，多个SVs能够改变基因的剂量和表达水平，从而导致口感、大小、以及产量性状的改变。四个SVs影响3个相关的转录因子，使得一个产量性状的改变。该研究突出了SVs在基因型到表型关系中的作用，强调了在作物改良中的重要性和实用性。</p>
<a id="more"></a>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>作物的表型变异是受到来自野生祖先种种遗传变异的影响，同时人类的选择和保持一些突变集合同样会影响作物的表型。主要的变异是数量遗传变异，受到多个微效基因的控制，因此现在遗传学的目标主要是解析特定基因和变异对数量性状的影响。人们通过高通量的短读序列测序，在大多数农作物中鉴定了自然遗传变异，但是这种方法只能够使用SNP、或者小片段indel来描述遗传变异，往往忽略了其他因素，因此会带来一定的偏差。最近10几年来的研究，人们发现SVs(大片的的插入、缺失、重复、染色质重排)，对植物的进化以及一些重要的农艺性状产生巨大的影响，例如根尖结构、开花时间、果实大小、抗逆性。与SNP相比，SVs往往会造成cis调控区域产生大规模的扰动，进而有可能导致基因表达发生改变，表型发生变化。SVs同样可以通过直接改变基因的拷贝数，来改变基因的表达水平，尽管SVs如此重要，但是通过短读测序鉴定SVs非常困难，使得大多数SVs没有被鉴定出来，并且它们的分子机制和对表型的影响被隐藏起来。</p>
<p>全长Nanopore 测序，使得我们能够广泛的研究，群体规模的SV图谱，鉴定出SVs之间的差异，结合表达量的数据和基因组编辑技术，使得我们能够快速而直接的推断出SVs的分子机制和对表型的影响。在此，我们提供了番茄中最全面的 panSV图谱，并且研究它在进化、循环、数量遗传、育种中的作用。</p>
<ul>
<li>作者使用nanopore测序了包含野生种和栽培种的100份材料，并且鉴定了SVs。对超过200000个SVs序列进行分析发现，主要是转座子和重复元件。</li>
<li>对SVs的分布进行分析，发现群体水平内存在广泛的基因渗入</li>
<li>RNA测序分析表明，SVs通过影响cis区域、编码区域来影响基因的表达</li>
<li>重头组装的14份材料的基因组，使得我们能够更好的解析基因组的复杂性。</li>
<li>结合CRISPR-Cas9技术，表明了基因的剂量效应和表型之间的关系。</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><h4 id="1-结合long-read测序，构建PanSV-genome"><a href="#1-结合long-read测序，构建PanSV-genome" class="headerlink" title="1.结合long-read测序，构建PanSV genome"></a>1.结合long-read测序，构建PanSV genome</h4><p>收集了具有代表性的800份番茄材料，使用二代数据鉴定了SVs，选择了其中51份来自早期和现代栽培品种，并且包含了最多的SV信息；同时选择了49份野生种。这些品种主要分为:</p>
<ul>
<li>SP CHE GAL</li>
<li>SLC</li>
<li>SLL</li>
</ul>
<p>对100份材料进行40X的long read测序，将序列比对到标准参考基因组上鉴定SVs，筛选&gt;30bp的SVs并且合并和作为panSV genome，经过确认发现大多数SVs在短读测序中没有鉴定到。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQkzND.png" alt="NQkzND.png"></p>
<ul>
<li><p>B 图 单个材料鉴定的SVs范围在1928~45840之间，其中在野生种材料中包含有最多的SVs，在SVs的种类里出现最多的是插入与缺失，也有少量的易位于重复。</p>
</li>
<li><p>C图 基于SVs的有无，反应这些材料间的进化关系，可以发现在栽培种和半驯化品种中有一些栽培种与半驯化品种聚类在一起，说明他们之间有渗透。</p>
</li>
</ul>
<p><img data-src="C:%5CUsers%5CPC%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620075851305.png" alt="image-20200620075851305"></p>
<ul>
<li>D图 比较每个材料中SVs的数目，发现在野生种中SVs数量最多，同时栽培种中SLL最少，这样驯化过程中遗传资源的丢失是吻合的</li>
<li>E图 表明这100份材料的SVs仍旧有许多的SVs没有被发现</li>
<li>F图中可以发现很多SVs只在少数几个材料中被鉴定到。</li>
<li>G图 评估SVs的长度分布，发现大多数的SVs是比较小的，只在30~50bp</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQEge0.png" alt="NQEge0.png"></p>
<h4 id="2-组装14份高质量的番茄参考基因组"><a href="#2-组装14份高质量的番茄参考基因组" class="headerlink" title="2.组装14份高质量的番茄参考基因组"></a>2.组装14份高质量的番茄参考基因组</h4><p>结合panSV genome和其他的genome信息，作者选择了14个差异比较大的材料，进行了基因组的组装和注释。组装的新的基因组叫MAS2.0，与最近发布的ITAG进行比较，发现了一些新的“pan-genome“ gene。</p>
<h4 id="3-SV在材料间的分布，表明不同材料间发生看遗传渗透"><a href="#3-SV在材料间的分布，表明不同材料间发生看遗传渗透" class="headerlink" title="3.SV在材料间的分布，表明不同材料间发生看遗传渗透"></a>3.SV在材料间的分布，表明不同材料间发生看遗传渗透</h4><ul>
<li><p>A图 中在栽培种SLL中SVs热点区域，同时由于野生材料SP具有更多的SVs，SVs热点区域可能反应的是品种驯化过程中，遗传资源从野生种中渗透到栽培种中的。在番茄的育种中，通过将一些抗病、理想性状从野生供体中引入到SLL中。</p>
</li>
<li><p>从B中可以 ，看到有5个SLL材料中共有的渗入区间，其中两个是M82 and EA02054  ，这两个材料在5号染色体与11号染色体还有大的渗入区间，这也解释了在构建的系统发生树中，这两个材料与栽培材料隔得远</p>
</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQVAk8.png" alt="NQVAk8.png"></p>
<ul>
<li>D图 对11份SLLs品种的育种历史进行考察，真菌性镰刀菌病，在1930年首次出现，在1930~1980年，从SP材料中导入了I I2 I3个抗性基因。对这些基因进行分子克隆，发现它们主要位于11号染色体两端的臂，与UFL 的渗入区间有交集，这个区间内部还有一些其他的抗性基因。Fla.8111B  材料同样包括了这些抗病基因，不过没有对应的渗透区间，说明这些材料经过了纯化选择，将这些区间给过滤了，只保留下了抗性基因。</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQe0JO.png" alt="NQe0JO.png"></p>
<h4 id="与基因有关的SVs，对表达有影响"><a href="#与基因有关的SVs，对表达有影响" class="headerlink" title="与基因有关的SVs，对表达有影响"></a>与基因有关的SVs，对表达有影响</h4><p>SVs通过改变基因序列、基因拷贝数、cis调控序列的位置或者组成，来改变富集基因的表达。</p>
<ul>
<li>有50%的SVs与gene或者两侧的调控区存在交集，在34075个注释的基因中，有95%的基因附近存在至少一个SVs，并且主要是在cis调控区域。</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQmSl4.png" alt="NQmSl4.png"></p>
<ul>
<li>为了探讨SVs对gene表达的影响，选择23份材料进行RNA测序，共得到21,156  份gene-SV对，发现很多gene存在显著的改变。其中将近一半的SVs影响编码区的，表达发生显著的改变。</li>
<li>cis-eQTL能够解释了群体中造成表达差异变异的很大部分，作者使用分类模型通过基因表达水平的变化，预测附近SVs的有无，量化基因表达水平的变化与SVs间的相关程度。从E图中可以通过AUROC指标，发现分类器在对编码区的SVs进行预测的效果最好，总的来说，SVs能够轻微的影响基因的表达。</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQnd2D.png" alt="NQnd2D.png"></p>
<h4 id="新组装的基因组发现了多个挥发性的单倍型基因"><a href="#新组装的基因组发现了多个挥发性的单倍型基因" class="headerlink" title="新组装的基因组发现了多个挥发性的单倍型基因"></a>新组装的基因组发现了多个挥发性的单倍型基因</h4><p>通过新组装的MAS2.0、表达谱的数据，帮助我们找到一些影响数量性状的变异位点。通过GWAS，已经鉴定出的具有水果挥发性香气的QTL，但很少一部分进行了功能研究。其中一个QTL编码水杨酸甲脂，对消费者的吸引产生负面影响。</p>
<ul>
<li>还有一个E8基因，在水果的成熟过程中，负调控乙烯的生物合成；敲除E8基因后又导致一些不好的挥发物质的积累。由于当时基因组中E8两侧存在gap，所以没有其他的变异被检测到。</li>
<li>A图 另外一个研究对<strong>NSGT1</strong>和<strong>NSGT2</strong>突变后，造成愈创木酚的积累，NSGT1少量表达被认为是没有功能的，在成熟过程中NSGT2的上调表达，使得愈创木酚转化成三糖苷，从而预防了愈创木酚的挥发。为了研究NSGT1与挥发性物质的关系，检查了这个基因的物理位置。B图 发现在一起的基因组中这个基因的注释不完整，而在新组织的MAS2.0中，一共发现了5种组合C图</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQQFJ0.png" alt="NQQFJ0.png"></p>
<p>经过分析发现这些基因E8、NSGT1、NSGT2的变异构成了这个愈创木酚的变异。使用300份表达谱数据和代谢数据，计算了每种单倍型的关联程度。其中IV和V是在早期驯化品种SLCs中出现的。</p>
<ul>
<li>E图中有5个V型材料，NSGT2没有检测到表达</li>
<li>在图F中，IV和V在统计上没有差异，但相比于I II III都变现出更高含量的愈创木酸</li>
<li>G图使用一个新的群体包含SP、SLC进行关联分析后与F图结果类似</li>
<li>H图使用两个SLC构建的F2群体，表明E8和NSGT1的缺失都导致愈创木酸含量的提高</li>
</ul>
<p>这个结果表明高质量的基因组，能够帮助我们解决一些复杂的单倍型基因，同时从QTL分析中解释基因型与表型</p>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQlAAA.png" alt="NQlAAA.png"></p>
<h4 id="细胞色素P450基因与果实大小"><a href="#细胞色素P450基因与果实大小" class="headerlink" title="细胞色素P450基因与果实大小"></a>细胞色素P450基因与果实大小</h4><p>与果实大小有关的QTL已经被鉴定出来，其中最显著的fw3.2,是位于P450 <strong><em>SlKLUH</em></strong>启动子区域的一个SNP，这个SNP被认为能够提高SIKLUH基因的表达。</p>
<ul>
<li>通过将这个SNP位点与panSV genome比较发现这个地方有串连重复，其中有两个SIKLUH的相同拷贝，fw3.2 dup。</li>
<li>通过分析这个重复基因的有无对内部三个基因表达的影响发现，在存在重复基因时，表达量更高；同时为了探究到底是启动子区域SNP还是这个重复基因对果实大小造成影响，作者构建了F2群体，通过分离重复基因，其他QTL仍旧固定，D图中发现共分离。而SNP的有无对果实大小没有影响。</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQ3kWt.png" alt="NQ3kWt.png"></p>
<ul>
<li>作者认为fw3.2通过基因拷贝数的增加，造成剂量效应，从而使得果实变大。通过CRISPR-Cas9,造成大片段和小片段的缺失，进行PCR发现这些植株表型发生明显的改变</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQ31Wq.png" alt="NQ31Wq.png"></p>
<ul>
<li>在T0-1植株中表型没有很大变化，都存在野生型和突变的等位基因，利于我们研究剂量效应。进行杂交，其中野生种LA1589具有2个拷贝，在A组杂交中参数3个拷贝的F1，在B组中只有一个有效的变异，在图H、I中它们的花序、果实大小都有明显的差异</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQ85E4.png" alt="NQ85E4.png"></p>
<p>这个结果也表明panSV genome 结合CRISPR-Cas9编辑揭示了基因的剂量效应导致果实大小发生改变</p>
<h4 id="四个SVs造成的“无果柄”育种"><a href="#四个SVs造成的“无果柄”育种" class="headerlink" title="四个SVs造成的“无果柄”育种"></a>四个SVs造成的“无果柄”育种</h4><p>无果柄是番茄收获中重要的一个性状，使得果实从花卉中分离，研究表明它是由转座子的插入导致一个转录因子Js的表达下调。但是在引入无果柄后，又会导致过多的花序分支导致果实产量的下降。图A</p>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQJR7F.png" alt="NQJR7F.png"></p>
<p>育种家们为了克服这个问题，找到了两个QTL位点 sb1和sb3，能够恢复正常花序的表型。</p>
<ul>
<li>作者发现sb3是一个包含ej2的83kb重复，通过剂量效应弱化由于转座子插入导致的ej2表达水平的下降。</li>
<li>sb1则是一个抑制分支产生，定位到1号染色体6Mbp的区间;发现两个基因STM 、STM3；在分子数存在差异的两个亲本中SMT3在分支数比较多的材料里高量表达。这个基因的序列和调控区域没有明显的变化，而在原来的基因组中这里有gap，在MAS2.0中，揭示了这个地方存在22kb的串连重复拷贝，图D</li>
</ul>
<p>为了探究这个低拷贝的SMT3基因是否就是我们要找的sb1 QTL信号，作者使用CRISPR-Cas9技术打断了STM3和TM3基因座。两种CR-1和CR-del，两个突变体在花序表型上没有很大的变化 图F；在与多花序品种杂交产生的F2群体中考察花序的数目，发现SMT3敲除后，花序分枝发生减少</p>
<p><img data-src="https://s1.ax1x.com/2020/06/20/NQ0PRe.png" alt="NQ0PRe.png"></p>
<p>通过分析发现STM3作为新的调控花序发育的基因，对sb1的分析表明4个SVs影响了三MADS-box genes 的表达，从而影响花序的发育和果柄，进一步说明结构变异对基因功能研究的重要性</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img data-src="https://s1.ax1x.com/2020/06/21/N3VaZR.png" alt="N3VaZR.png"></p>
<ol>
<li><p>构建了植物panSV genome 数据，表明SV和基因差异表达相关</p>
</li>
<li><p>对3个具体功能的研究表明，结构变异是导致表型差异的原因</p>
</li>
<li><p>全面的植物结构变异数据，为精准的育种提供帮助</p>
</li>
</ol>
<ol start="4">
<li>利用基因编辑技术验证SV（拷贝数变异）的功能，对其他作物的研究具有指导意义</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>Major Impacts of Widespread Structural Variation on Gene Expression and Crop Improvement in Tomato  </li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>拟南芥中转录与剪切</title>
    <url>/codeHub/2020/06/17/2020-06/02%E6%8B%9F%E5%8D%97%E8%8A%A5%E4%B8%AD%E8%BD%AC%E5%BD%95%E4%B8%8E%E5%89%AA%E5%88%87/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>在真核生物中，基因在RNA聚合酶II的作用下被转录成成mRNA，其中多数时候intron是在转录的过程中被剪切复合体剪切掉。在酵母的long-read sequencing研究中发现，当聚合酶II越过内含子时，剪切随即发生。本文基于Nanopore测序技术，绘制了结合在染色质上的RNA图谱，与此同时能够在全基因组范围检测剪切状态、聚合酶II的位置、多聚腺苷酸化。通过分析发现，在聚合酶II越过3‘剪切位点1Kb后，仍旧有超过半数的intron仍旧保持未剪切的状态；相比于酵母，植物中的剪切速率慢的多。许多全长的chromatin-bound RNA在多聚腺苷化后，仍旧包含有未剪切的内含子。而这些内含子在细胞质中几乎是不存在的，对nonsense-mediate decay具有抵抗力，表明这些RNA是在转录完成后、被释放到细胞质之前完成剪切的；作者给这类intron下了一个定义，post-transcriptionally splice intron <strong>pts intron</strong>.对来自公共数据库中6500份RNA-sequencing分析后，发现pts intron的剪切依赖于剪切相关蛋白<strong>PRMT5</strong>、<strong>SKIP</strong>同时又受到各种环境信号的影响。在拟南芥中大多数内含子保留事件是发生在pts introns，表明pts intron是内含子保留事件的主要来源，也可能是机体产生有功能的mRA的一种快速响应机制。</p>
<a id="more"></a>

<h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><p>在真核生物中，pre-mRNA的剪切是mRNA成熟中一个基本的过程，并且剪切是转录往往同时进行。之前的研究通过人工合成pre-mRNA，在体外重构了剪切事件这一过程，帮助我们很好的理解了剪切位点的识别以及剪切复合体的组装。随着高通量测序技术的绘制新生RNA的图谱，极大的促进了在全基因组水平量化剪切事件，同时精准的追踪聚合酶II。但是研究剪切和转录之间的关系存在很大的困难，因为在同一个转录本上描述剪切和转录很困难。</p>
<p>通过long-read sequence可以发现大多数intron的剪切是在转录时发生的，当然这种现象也因组织而异。除了共转录剪切，也存在大量的转录后剪切，这些mRNA在多聚腺苷酸化后bound在染色质上。</p>
<p>通过对chromatin-bound RNA进行捕获后发现，处于延伸中的RNA占了70%，而多聚腺苷酸化的RNA只有30%。有了这些数据后，进一步的研究剪切和转录的关系。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NEjmOf.png" alt="NEjmOf.png"></p>
<p>进一步对处于elongating中的full-read 分析发现，有将近20%的read，存在至少一个已经剪切的intron，而有50%的内含子，在聚合酶II跨过3’剪切位点1100bp后,仍旧没有被剪切掉。</p>
<blockquote>
<p>不同颜色代表不同类型的mRNA，和对应的比例</p>
</blockquote>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NExRFe.png" alt="NExRFe.png"></p>
<p>由于文章的方法能够同时追踪来自同一个转录本的多个intron的状态，作者比较了任意两个相邻的intron的剪切顺序，发现有70%是上游的intron先发生剪切。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NVSwK1.png" alt="NVSwK1.png"></p>
<p>进一步比较了包含多个intron 的基因转录动态过程，发现上游intron被剪切的比例更高一些，同时又一部分的上游intron已经被剪切掉了，在聚合酶II越过下游内含子时，也有一部分上游内含子在下游内含子都剪切掉的情况、多聚腺苷酸化后仍旧没有被剪切。</p>
<p>还存在相邻两个intron协助剪切的情况，可能是由于位于同一个transcript上的intron通过招募一些剪切复合物来帮助其他intron剪切。</p>
<blockquote>
<p>柱状图中恒坐标表示第几个外显子，例如S2中当聚合酶II越过第2个内含子时，两个intron就有4中可能，对应4种比例</p>
</blockquote>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NV9VpQ.png" alt="NV9VpQ.png"></p>
<p>研究多聚腺苷酸化的transcript的剪切情况，其中有30%没有完全的剪切掉内含子，并且大多数为剪切的转录本只包含了一个或少数未剪切的intron。分析这些未完全剪切的transcript是否会从染色质上释放，</p>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NVF8V1.png" alt="NVF8V1.png"></p>
<p>通过分析那些未剪切比例大于0,.1的transcript在细胞核和细胞质中的含量，表明这些transcript仍旧bound在chromatin上，在多聚腺苷酸化后，同时FPKM分析也表明，驻留在chromatin上的表达量相比于细胞核、细胞质中的更高。unspliced的intron如果释放到细胞质中会被NMD降解，通过<strong><em>upf1</em></strong>敲除后，没有NMD发现unspliced的含量没有变化。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NVZT8P.png" alt="NVZT8P.png"></p>
<p>当分析RNA-seq数据时，内含子错误的注释是很常见的，因此作者选择了constitutively spliced introns  进行了下一步的分析。为了研究pts intron中调控内含子剪切的因素，作者选择了6521份RNA-seq数据进行分析，其中包括一些突变体、不同调节处理的材料。其中有10份突变材料中，500个intron的保留率相比于野生型有所提高。其中就包括已经报导的<strong>*PRMT5  *</strong>、**<em>SKIP  *</em>两个基因。这两个基因主要是促进pts transcript 中Intron的剪切，当然对于非pts也有一定的影响。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NV4Ege.png" alt="NV4Ege.png"></p>
<blockquote>
<p>PRMT5 is implicated in various developmental processes, such as flowering time control, stress response and circadian rhythm, by promoting the recruitment of NineTeen Complex to the spliceosome and modulating pre-mRNA splicing of diverse genes  </p>
</blockquote>
<p>在细胞核中保留的已经多聚腺苷酸化，但是没有完全剪切的transcript，被存储在细胞核中防止被NMD降解，可能是在机体受到环境刺激时，激活剪切机制，产生具有功能的mRNA。</p>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NVIMp8.png" alt="NVIMp8.png"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>Post-transcriptional splicing of nascent RNA contributes to widespread intron retention in plants  </li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>基于三代测序对等位基因进行分型</title>
    <url>/codeHub/2020/06/17/2020-06/2020-06-01/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>区分玉米不同单倍型的遗传变异对研究等位基因的功能和群体遗传分析，基因组的解析有着重要的作用。使用全长cDNA测序，在isform水平对两个玉米自交系品种和对应的杂交品种进行分析。通过使用IsoPhase方法，在胚胎、胚乳和根组织中验证了大多数从二代数据called SNP；并且在自交系与杂交后代之间鉴定了在等位基因间特异的、基因水平、isform水平的差异表达。在互惠杂交后代中，经过分型后对6907个基因注释了SNP，鉴定了大效应基因。并且，在不同的组织中鉴定了亲本起源的isform，杂交后代中独特的isform，印记基因。最后，作者表征了顺式和反式调节作用的变化。</p>
<a id="more"></a>

<h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><p>对遗传变异进行分型，对于鉴定出潜在的致病变异，表征遗传变异和表型之间的关系有着重要的作用。玉米作为一个二倍体物种，虽然不同基因组之间存在很高的相似性，但是仍旧表现出等位基因的特异性表达ASE（等位基因间表达水平不相同)。并且ASE随着不同组织、不同发育阶段、不同生长环境中变化。等位基因在序列水平上产生不同的转录本，为了更好的解析玉米的转录图谱，因此有必要分析ASE。之前的研究是通过二代数据，在SNP水平对等位基因的表达进行量化，但是不能够提供全长的单倍型信息。</p>
<p>PacBio和Nenopore则通过对全长转录本进行测序，广泛的被应用于基因组注释中；但是只有少量的研究使用long reads进行isform水平的亚型研究。本研究中使用PacBio和RNA-seq测序，并且开发了一套流程IsoPhase，对杂交种中等位基因的亚型进行分型。第一个在玉米中实验IsoPhase方法进行研究，这套流程同样适用于多倍体物种。这套流程不需要父母本的信息，虽然父母本的信息可以区分母本还是父本的等位基因。并且isform水平可以确定到底是那个等位基因在转录，可以产生特定的等位基因转录组。</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><h4 id="全长转录组测序和生信分析流程"><a href="#全长转录组测序和生信分析流程" class="headerlink" title="全长转录组测序和生信分析流程"></a>全长转录组测序和生信分析流程</h4><p><img data-src="https://s1.ax1x.com/2020/06/17/NAhv1H.png" alt="流程图"></p>
<p>首先两个亲本在一些性状上存在巨大的差异，使得这两个亲本的杂交非常的适合研究等位基因的杂种优势。同时为了量化不同组织中基因表达谱，作者提取了不同物种、不同组织的RNA进行反转录，加上组织特异的barcode进行混池测序，将得到的环形共识序列使用Isoseq3分析流程。其中有76.3的read被归类为全长的转录本，根据barcode和ployA是否出现。经过Isoseq处理后，产生了25万个高质量的全长转录本。将这些全长转录本比对到玉米参考基因组上，约有99.3%被比对到参考基因组上，根据覆盖度和相似度进行筛选后，仅仅保留91.8%，这些序列进一步  collapsed  成9万多个非冗余的转录本。将没有比对上的全长转录本比对到  RefSeq NR database  数据库中其中约有50%的比对到了其他生物中，说明这些在文库制备的时候来至于质粒或者其他来源。</p>
<h4 id="Isoform-characterization"><a href="#Isoform-characterization" class="headerlink" title="Isoform characterization"></a>Isoform characterization</h4><p>使用  SQANTI   将转录本与参考基因组注释进行比较，其中有  3344  被认为是新的没有被注释的转录本。其中有95.5%是位于基因间区的。</p>
<p>SQANTI  将转录本进行了分类</p>
<p><img data-src="https://s1.ax1x.com/2020/06/17/NA4iAf.png" alt="isform分类"></p>
<ol>
<li>FSM 与参考基因组注释的剪切完全匹配</li>
<li>ISM  不完全匹配</li>
<li>NIC 全新的在分类内</li>
<li>NNC全新的不在分类内</li>
<li>反义链</li>
<li>基因间区</li>
</ol>
<p>并且全长转录本测序的转录本长度能达到10kb以上。并且新鉴定出的基因主要是多外显子。</p>
<ul>
<li>对于剪切位点完全匹配的isform，发生了起始和终止位点的改变。</li>
</ul>
<p>将转录本进行分池，也就是分组织的分析。当一个组织中的转录本有一条全长转录本的read支持，就认为它已经表达了。每个组织中包含有20000到30000个表达的转录本。为了验证数据的饱和，对样本进行二次采样，Isoseq数据在基因水平上已经达到饱和。</p>
<p>在基因和isform水平比较双亲和杂交种，没有发现明显的模式。与此同时在比较双亲与两个杂交种时，发现一些共享的和品种特异的基因、isform；这个发现同样被二代测序的数据所确认。对这四个品种的剪切模式进行探讨发现，内含子保守时最主要的模式；使用二代数据进行定量分析发现，在三个组织中大多数基因表现出一种加性效应。同时比较了两个杂交种，发现它们在加性基因的数目上存在差异。这也可能是导致两个杂交种间存在差异的原因。在加性基因与非加性基因的比较中isform的数目上没有存在明显的差异。</p>
<h4 id="全长转录本实现准确的亚型分型"><a href="#全长转录本实现准确的亚型分型" class="headerlink" title="全长转录本实现准确的亚型分型"></a>全长转录本实现准确的亚型分型</h4><p><img data-src="https://s1.ax1x.com/2020/06/17/NA4aHx.png" alt="基于SNP进行分型"></p>
<p>为了对Iso-seq转录本进行分型，作者开发了一套IsoPhase流程，对于每个基因，将全长reads比对到基因区域，然后进行SNP的鉴定。之后使用全长reads的信息重构不同的亚型，使用简单的纠错方案获取两个等位基因。为了分清楚哪个是来自于母本哪个是来至于父本的等位基因，所有的read只能来自于同一个等位基因。只有双亲等位基因被鉴定出来，就得到了F1中每个等位基因的read数。对9000多个基因进行分型后，其中有6700多个基因存在至少一个SNP能够将它归类为B73或者Kill。</p>
<p>使用二代数据进行验证后，其中有96%的SNP得到验证，而其他PacBio特异的SNPs可能二代测序数据对UTR区域的覆盖不够。</p>
<h4 id="等位基因的特异性表达"><a href="#等位基因的特异性表达" class="headerlink" title="等位基因的特异性表达"></a>等位基因的特异性表达</h4><p><img data-src="https://s1.ax1x.com/2020/06/17/NA42DI.png" alt="等位基因表达"></p>
<p>只有母本等位基因的表达，比较了两个双亲在等位基因的表达上的差异</p>
<p>在F1杂交后代中，所有的isform都表达了，但是只有Kill检测出了出了一个isform。</p>
<p>monoallelic genes感觉是纯合的等位基因，在不同组织中比较了这些基因在isform数目上的差异</p>
<h4 id="对SNP进行功能注释"><a href="#对SNP进行功能注释" class="headerlink" title="对SNP进行功能注释"></a>对SNP进行功能注释</h4><p>其中有24%的SNP是同义突变，在非同义突变的SNP中，  22,093  多个SNP对  5140 genes  可能存在效应，有将近10~17%是在UTR区域，其中进行容忍度分析发现，0.05值为阀值，大约  2556 genes  SNP被认为是有害突变。同时在杂交后代中，isform的数目比父母中更高，但是在胚乳中两个杂交种表现不一致，说明不同的杂交组合影响胚乳的发育。</p>
<h4 id="印记基因、顺式反式调节效应"><a href="#印记基因、顺式反式调节效应" class="headerlink" title="印记基因、顺式反式调节效应"></a>印记基因、顺式反式调节效应</h4><p>胚乳中26个父本印记基因，其中70%在之前的研究中被报道了；在胚中2个印记基因同样出现在胚乳中。在胚乳中30个母本印记基因，在根中没有发现印记基因。</p>
<p>顺式、反式调控，通过比较父母本中等位基因表达比率与杂交后代中等位基因的杂交比例来区分。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>科学问题非常有趣，研究了不同等位基因特异性的表达，可能是造成杂种优势、印记基因等现象的原因</p>
</li>
<li><p>第一个利用全长转录组数据，在isforms水平对等位基因的特异性表达进行分析</p>
</li>
<li><p>每一个结果都结合了二代测序数据，说明了数据的真实性和可靠性</p>
</li>
<li><p>开发了一套基于全长转录本数据的分析流程IsoPhase</p>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>Variant phasing and haplotypic expression from long-read sequencing in maize</li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>生物学杂志汇总</title>
    <url>/codeHub/2020/05/31/2020-06%E4%BB%A5%E5%89%8D/27%E7%94%9F%E7%89%A9%E5%AD%A6%E6%9D%82%E5%BF%97%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>Cell系列</p>
<ul>
<li><a href="https://www.cell.com/cell/home" target="_blank" rel="noopener">Cell</a></li>
<li><a href="https://www.cell.com/molecular-cell/home" target="_blank" rel="noopener">Molecular Cell</a></li>
<li><a href="https://www.cell.com/molecular-plant/home" target="_blank" rel="noopener">Molecular Plant</a></li>
</ul>
<p>Nature系列</p>
<ul>
<li><a href="https://www.nature.com/nature/research" target="_blank" rel="noopener">Nature</a></li>
<li><a href="https://www.nature.com/ng/" target="_blank" rel="noopener">Nature Genetics</a></li>
<li><a href="https://www.nature.com/ncomms/" target="_blank" rel="noopener">Nature Communications</a></li>
<li><a href="https://www.nature.com/nplants/" target="_blank" rel="noopener">Nature Plants</a></li>
<li><a href="https://www.nature.com/nbt/" target="_blank" rel="noopener">Nature Biotechnology</a></li>
</ul>
<p>Science系列</p>
<ul>
<li><a href="https://science.sciencemag.org/" target="_blank" rel="noopener">Science</a></li>
<li><a href="https://advances.sciencemag.org/" target="_blank" rel="noopener">Science Advances</a></li>
</ul>
<p>英国牛津大学出版社</p>
<ul>
<li><a href="https://academic.oup.com/nar/" target="_blank" rel="noopener">Nucleic Acids Research</a></li>
<li><a href="https://academic.oup.com/mbe" target="_blank" rel="noopener">Molecular Biology and Evolution</a></li>
</ul>
<p>其他</p>
<ul>
<li><a href="https://nph.onlinelibrary.wiley.com/journal/14698137" target="_blank" rel="noopener">New Phytologist</a></li>
<li><a href="https://www.pnas.org/content/early/recent?page=1" target="_blank" rel="noopener">PNAS</a></li>
</ul>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>杂草水稻的进化</title>
    <url>/codeHub/2020/04/24/2020-06%E4%BB%A5%E5%89%8D/26%E6%9D%82%E8%8D%89%E6%B0%B4%E7%A8%BB%E7%9A%84%E8%BF%9B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Population-Genomic-Analysis-and-De-Novo-Assembly-Reveal-the-Origin-of-Weedy-Rice-as-an-Evolutionary-Game"><a href="#Population-Genomic-Analysis-and-De-Novo-Assembly-Reveal-the-Origin-of-Weedy-Rice-as-an-Evolutionary-Game" class="headerlink" title="Population Genomic Analysis and De Novo Assembly Reveal the Origin of Weedy Rice as an Evolutionary Game"></a>Population Genomic Analysis and De Novo Assembly Reveal the Origin of Weedy Rice as an Evolutionary Game</h1><p>​    杂草水稻具有很强的入侵性、再生能力以及与栽培稻竞争资源；同时又缺乏有效的除草剂进行控制；使得它成为稻田里的主要威胁。但与此同时，作为栽培稻的近缘物质，杂草水稻又具有与野生水稻类似的特征；这就使得杂草水稻作为理解水稻驯化和改良的良好模型。对于杂草水稻的起源以及它的一些特有属性的形成仍旧是未知的，在对亚洲的低纬度地区的杂草水稻研究后，认为有一部分基因是从野生品种中流向杂草水稻的。</p>
<p>​    在当前日益变化的气候和人口增长情况下，从杂草植物中克隆优良基因到作物中，能够提供农作物产量解决粮食安全问题。但是还存在一些限制因素，由于缺乏基因组信息，使得发掘优良基因和解析其遗传基础变得十分困难。</p>
<p>​    高纬度地区的杂草水稻相比与栽培水稻经历着更强的自然选择压，因此可以用它的遗传资源来改良栽培稻的生态适应性。</p>
<a id="more"></a>

<h3 id="系统发生树分析"><a href="#系统发生树分析" class="headerlink" title="系统发生树分析"></a>系统发生树分析</h3><p>通过结合多个品种的SNP数据，构建系统发生树</p>
<ul>
<li>48个高纬度杂草水稻 WRAH</li>
<li>43 个温带栽培粳稻   Japonica-C  </li>
<li>26 个温带粳稻地方品种   Japonica-L  </li>
<li>…</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/04/23/Jwctne.png" alt="系统发生树"></p>
<p>图中可以看出，高纬度杂草水稻与地方品种进化距离比较近，而与栽培品种距离较远。</p>
<blockquote>
<p><a href="http://www.biotrainee.com/thread-2253-1-1.html" target="_blank" rel="noopener">系统发生树</a></p>
</blockquote>
<h3 id="Selection-Features-in-the-WRAH-Genome"><a href="#Selection-Features-in-the-WRAH-Genome" class="headerlink" title="Selection Features in the WRAH Genome"></a>Selection Features in the WRAH Genome</h3><p>一般来说在驯化群体的选择区间中，一些比较关键的基因通常会表现出低的多态性、等位基因的偏好性。</p>
<blockquote>
<p>由于人为的选择某一性状，导致对应等位基因的多态性下降，同时某些等位基因的频率增加。衡量的指标有两个：</p>
<ul>
<li>π 值越大遗传多样性越高</li>
<li>Tajima’s D   大于0表示群体稀有等位基因频率在逐渐下降，小于0表示群体稀有等位基因频率逐渐增加；等于0表示群体内选择达到平衡，等位基因频率维持不变</li>
</ul>
</blockquote>
<p><img data-src="https://s1.ax1x.com/2020/04/23/JwRWAH.png" alt="选择区域的特征"></p>
<p>通过将WRAH与栽培稻、地方品种比较，发现π值更低、而Tajima’s D  值更高一些。进一步的使用window-based方法扫描整个基因组π值和Tajima’s D值。发现一些具有驯化或者改良基因有的特征（π值小、Tajima’s D值大);同时WRAH中一些与逆境相关的基因表现出未驯化或改良特征。在WRAH中那些π值高、Tajima’s D值大的区域可以理解成：这个区域稀有变异丰富同时选择达到平衡。</p>
<h3 id="Features-of-Domestication-in-WRAH"><a href="#Features-of-Domestication-in-WRAH" class="headerlink" title="Features of Domestication in WRAH"></a>Features of Domestication in WRAH</h3><p>基于WRAH群体的50k-SNP数据，计算了WRAH和  Japonica-M （栽培种和地方种的混合)的Fst值，同时将前5%Fst对应的SNP作为一个能够区分WRAH和Japonica-M 的数据集；这些Fst区域也是反映了WRAH和栽培品种间存在差异的地方。</p>
<blockquote>
<p>  Fst值越大，表明群体间分化越大</p>
</blockquote>
<p>紧接着，针对这两个数据集分别进行改良信号、和驯化信号的计算。发现在杂草和栽培稻之间存在差异的区域中受到的改良信号要高于整个区域的水平；而驯化信号在两个数据集中是相似的。</p>
<blockquote>
<p>说明遗传改良是造成杂草水稻和普通水稻分化的；</p>
</blockquote>
<p>使用这两个数据集，计算野生种和WRAH、 Japonica之间的遗传距离，发现同样没有区别。这些结果表明前5%Fst对应的区域与改良位点重合，而与驯化区域是不一样的，说明  WRAH 起源于栽培稻驯化后。</p>
<h3 id="Parallel-Evolution-between-WRAH-and-WRSC"><a href="#Parallel-Evolution-between-WRAH-and-WRSC" class="headerlink" title="Parallel Evolution between WRAH and WRSC"></a>Parallel Evolution between WRAH and WRSC</h3><p><img data-src="https://s1.ax1x.com/2020/04/23/JwOQSO.png" alt="数目"></p>
<p>为了检测WRAH（高纬度地区杂草)和WRSC(中纬度地区杂草),之间是否是独立的进化或者平行进化。分别检测了栽培稻与两个杂草稻的选择信号，以5%为阀值，发现了135和130个共享的离群值。同时检查了一些标记基因在1%的阀值、1Mb的窗口下，是否都会出现；发现了一些与驯化相关的基因在两个种群中同时出现。这些表明这两个杂草水稻物种经历的是平行的进化。</p>
<p><img data-src="https://s1.ax1x.com/2020/04/23/JwOky4.png" alt="log π值"></p>
<h3 id="QTL-Mapping-for-Weedy-Traits"><a href="#QTL-Mapping-for-Weedy-Traits" class="headerlink" title="QTL Mapping for Weedy Traits"></a>QTL Mapping for Weedy Traits</h3><p>杂草水稻存在一些特有的表型，例如较高株高、红色果皮等；对应它们的遗传基础仍旧是未知的。通过对这些数量性状位点进行定位，能够更好的理解杂草水稻的进化。构建了一个由杂草水稻和栽培稻杂交得到的重组自交系群体，并且双亲P1、P2在一些性状上具有明显的差异。</p>
<p>总共5307个高质量的SNP被用于构建连锁图谱，覆盖了1804.16cM，平均每个标记间相距0.34cM；通过分析标记在染色体上的实际位置和遗传图谱上的相对位置，发现它们之间存在99%的相关性，说明这些遗传标记比较好。</p>
<blockquote>
<p>1cM ：表示在群体中，两个基因有1%的概率发生基因重组</p>
</blockquote>
<p><img data-src="https://s1.ax1x.com/2020/04/24/J0wuLR.png" alt="物理距离与遗传距离相关性"></p>
<p>通过高密度的遗传图谱，将遗传标记分为一个个连锁群分别与性状进行关联，根据连锁群的大小设置一个显著性阀值，得到对应的连锁区段，映射到对应的染色体区间上。</p>
<p>通过QTL定位，发现在1号染色体末端有着强烈的选择信号，说明这个区间存在一些优良基因用于改良栽培稻。</p>
<p><a href="https://imgchr.com/i/J0wPZq" target="_blank" rel="noopener"><img data-src="https://s1.ax1x.com/2020/04/24/J0wPZq.png" alt="QTL定位区间"></a></p>
<h3 id="Demographic-Scenario-Analysis"><a href="#Demographic-Scenario-Analysis" class="headerlink" title="Demographic Scenario Analysis"></a>Demographic Scenario Analysis</h3><p>基于近似贝叶斯方法估计WRAH起源的后验概率，</p>
<blockquote>
<p>后验概率计算：</p>
<p>存在多个先验条件：比如A条件下事件发生的概率为80%，B条件下事件发生的概率为60%；A条件出现的概率为75%</p>
<p>当事件发生的时候，推断是A条件下发生的概率    </p>
</blockquote>
<p>通过构建多个进化模型，计算每个模型的后验概率大小，确定了连个最有可能的两个模型1、模型3。结合以有的研究，栽培稻出现的时间，与模型3最接近。</p>
<p><img data-src="https://s1.ax1x.com/2020/04/24/J02ShR.png" alt="进化模型"></p>
<h3 id="Genome-Sequencing-Assembly-and-Gene-Annotation"><a href="#Genome-Sequencing-Assembly-and-Gene-Annotation" class="headerlink" title="Genome Sequencing, Assembly, and Gene Annotation"></a>Genome Sequencing, Assembly, and Gene Annotation</h3><p><img data-src="https://s1.ax1x.com/2020/04/24/J02IbD.png" alt="Hi-c辅助组装"></p>
<p>使用Hi-c数据辅助基因组的组装</p>
<blockquote>
<p>原理: 染色质内部的互作大于染色质间的互作</p>
</blockquote>
<h3 id="比较不同水稻基因组中的基因家族"><a href="#比较不同水稻基因组中的基因家族" class="headerlink" title="比较不同水稻基因组中的基因家族"></a>比较不同水稻基因组中的基因家族</h3><p><img data-src="https://s1.ax1x.com/2020/04/24/J0fIbT.png" alt="Ka/Ks"></p>
<p>与栽培稻相比，杂草水稻（WRAH）,Ka/Ks的值都比较大；说明杂草水稻受到更大的选择压。同时在ka/Ks值大于1的地方，比例也比栽培稻高，说明杂草水稻基因组中积累了更多的功能突变。</p>
<blockquote>
<p>Ka/Ks值： 非同义突变/同义突变</p>
<p>在不存在选择的中行调节下，Ka/Ks值接近1</p>
<p>由于纯化选择的作用，使一些非同义突变Ka产生的有害突变被消除，保持蛋白质功能不变，这样就会使得Ka/Ks值小于1</p>
<p>在正向选择作用下，使得非同义突变产生的有利变异被保留，说明蛋白质逐渐在发生改变。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过比较杂草水稻与栽培稻等物种的进化关系，解释了杂草水稻的形成及进化。通过对杂草水稻驯化和选择区间的分析证明了杂草水稻是在水稻驯化后逐渐形成的。根据杂草水稻中一些与野生稻独有的特征表现，进行QTL定位，将基因定位到1号染色体臂端；说明这个区域存在一些杂草水稻特异的遗传资源。进行人口情景模拟，进一步证实了杂草水稻的进化历史。对杂草水稻的基因组进行从头组装，比较了基因家族的选择压，发现杂草水稻中累积了更多的功能突变，相比与栽培稻。总而言之，通过对杂草水稻基因组的组装，将会为水稻的遗传改良提供许多有益的遗传资源，更好的解析一些复杂性状的遗传机理。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.biotrainee.com/thread-2253-1-1.html" target="_blank" rel="noopener">系统发生树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/52064863" target="_blank" rel="noopener">Tajima’s D</a>   </li>
<li><a href="https://www.jianshu.com/p/88bd3b4d6c2f" target="_blank" rel="noopener">Ka/Ks</a></li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>癌症中基因组的重排对染色质折叠的影响</title>
    <url>/codeHub/2020/04/23/2020-06%E4%BB%A5%E5%89%8D/25%E7%99%8C%E7%97%87%E4%B8%AD%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E9%87%8D%E6%8E%92%E5%AF%B9%E6%9F%93%E8%89%B2%E8%B4%A8%E6%8A%98%E5%8F%A0%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h1 id="癌症中基因组的重排对染色质折叠的影响"><a href="#癌症中基因组的重排对染色质折叠的影响" class="headerlink" title="癌症中基因组的重排对染色质折叠的影响"></a>癌症中基因组的重排对染色质折叠的影响</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>基因组的构象在细胞核内是分层次的，其中TAD被认为是最能代表功能的区域，因为在TAD内部包含着可以去调控基因的调控元件，TAD边界区域的扰动可能会使相邻的TAD发生异常的交互从而去影响相邻基因的调控，相关的一些研究表明，基因组的重排现象会使得TAD的结构发生改变从而影响基因的调控，这篇文章就去探究在不同的肿瘤组织中不同的结构变异对于TAD以及基因表达的影响，从而帮助我们更好的理解染色质的折叠和基因组的重排之间的关系。</p>
<a id="more"></a>

<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><h3 id="TAD-boundaries-are-affected-by-different-types-of-somatic-SV-in-cancer-genomes"><a href="#TAD-boundaries-are-affected-by-different-types-of-somatic-SV-in-cancer-genomes" class="headerlink" title="TAD boundaries are affected by different types of somatic SV in cancer genomes"></a>TAD boundaries are affected by different types of somatic SV in cancer genomes</h3><ul>
<li>文章用了五种细胞的Hi-C数据去鉴定TAD，这五种细胞分别来自三个胚胎层：中胚层（ mesoderm）、下胚层（endoderm）、外胚层（ectoderm）</li>
<li>在这五种细胞中鉴定到了3,926 to 4,690个TAD，与之前的研究数据相比有84%以上的相似度</li>
<li>之后，作者鉴定了已知的这些 TAD边界附近的特征，然后在所有细胞种一共鉴定到了2477个边界，然后这2477区域就被用于之后的分析</li>
<li>之后作者鉴定了这些边界在癌症细胞中的存在分布情况，发现在白血病细胞和乳腺癌细胞中分别有85%和83.4%的重叠，说明绝大部分边界在正常细胞和恶性的细胞中使保守的</li>
<li>此外，作者发现边界TAD信号水平是最低的，这和TAD边界减少临近区域的交互这个特点相符合，如下图所示</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUymJU.png" alt="1.png" style="zoom:50%;" />

<ul>
<li>作者使用了288,457 个可信度较高的SVs，并且使用SVs断点的方向去将这些SVs分类（deletions, inversions, duplications or complex rearrangements），然后按照2Mb长度作为界限去将SVs分成两类：long-range SVs short-range SVs，deletions, inversions and duplications大部分都是短距离，其中大部分complex rearrangements都是长距离的，本文主要分析短距离的SVs</li>
<li>作者鉴定了那些跨越了整个TAD边界的SV，结果发现5.0%, 8.5%, 12.8% and 19.9% of all deletions, inversions, duplications and complex events是BA（(boundary affecting ）事件，如下图所示</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyeiT.png" alt="2.png" style="zoom:50%;" />

<ul>
<li>进而，作者发现和预期的边界扰动相比，BA-duplications高于预期，BA-deletion低于预期，其他两种在预期之内，这表明deletion更易于出现在TAD内部 ，duplication更易于跨越TAD，结果如下图</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyVoV.png" alt="3.png" style="zoom:50%;" />

<ul>
<li>作者还发现，在不同的SVs种，BA-SVs在长度上的分布基本相同，大部分BA-SVs都只影响一个边界，绝大多数(98.4%) 癌细胞的TAD边界都会被影响，很有趣的是，这些TAD的边界不太可能会被健康人群基因组中的deletion and duplication所影响。图示如下</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUynWF.png" alt="4.png" style="zoom: 50%;" />

<ul>
<li>最后作者研究了deletions在胚胎细胞和癌细胞中的分布，发现在胚胎细胞中只有少于0.1%的deletions发生在边界上，而癌细胞中有4.1%</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyEd0.png" alt="5.png" style="zoom: 50%;" />

<h3 id="Chromatin-folding-disruptions-are-specific-to-histological-subtypes"><a href="#Chromatin-folding-disruptions-are-specific-to-histological-subtypes" class="headerlink" title="Chromatin folding disruptions are specific to histological subtypes"></a>Chromatin folding disruptions are specific to histological subtypes</h3><ul>
<li>之后，作者比较了这些BA-SVs在不同的肿瘤类型中的分布情况，发现BA-SVs在不同的肿瘤类型之间存在显著差异</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyuz4.png" alt="6.png" style="zoom: 50%;" />

<ul>
<li>下面这张图描述了同一肿瘤类型的每一位病人的BA-SV分布情况</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyQy9.png" alt="7.png" style="zoom: 50%;" />

<h3 id="Recurrently-affected-boundaries-in-specific-cancer-types"><a href="#Recurrently-affected-boundaries-in-specific-cancer-types" class="headerlink" title="Recurrently affected boundaries in specific cancer types"></a>Recurrently affected boundaries in specific cancer types</h3><ul>
<li>作者接下来探究癌症驱动基因附近的TAD边界与这些结构变异之间分布关系，结果如下(red, deletion; orange, complex; green, duplication; gray, different SV types were observed)，圆圈大小代表某一个特定的肿瘤内BA-SV在这个癌症驱动基因中附近的出现比例</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyMQJ.png" alt="8.png" style="zoom: 50%;" />

<ul>
<li>此外，作者发现了KIAA1549、BRAF这两个基因之间的边界在纤维性星形细胞瘤中易于发生 BA-duplications  ；还发现在平滑肌肉瘤中MDM2这个位点附近的边界被影响的频率较高；同时平滑肌肉瘤12号染色体上突变频率较高，图示如下（列代表TAD边界，行代表不同的样本）</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUy3e1.png" alt="9.png" style="zoom:67%;" />

<ul>
<li>此外，作者研究了TAD内部的一些SVs，这些SVs主要扰动 CTCF–CTCF chromatin loops，作者鉴定了许多可能被扰动的 chromatin loops ，这表明染色质折叠的扰动会发生在不同的尺度上，包括TAD和CTCF–CTCF chromatin loop </li>
<li>其中值得注意的是在食道癌、胃癌和结肠癌细胞的6号染色体上 FOXC1 基因附近的一个CTCF位点与一个删除区域有重叠，如下图所示（图中紫色的弧线新出现的CTCF–CTCF loops ）</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUy0OA.png" alt="10.png" style="zoom:67%;" />

<h3 id="Most-domain-disruptions-do-not-result-in-marked-gene-expression-changes"><a href="#Most-domain-disruptions-do-not-result-in-marked-gene-expression-changes" class="headerlink" title="Most domain disruptions do not result in marked gene-expression changes."></a>Most domain disruptions do not result in marked gene-expression changes.</h3><ul>
<li>作者对TAD进行注释，通过分析TAD所在区域的的染色质状态将TAD分成五类： heterochromatin (61), low/quiescent (705), repressed (481), low-active (764) and active (365)，然后作者计算了每种类型的TAD内部基因的表达量，发现基因在repressed domains和constitutive LADs的表达要低于active domains和inter-LADs ，图解如下</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/04/22/JUy8dx.png" alt="11.png"></p>
<img data-src="https://s1.ax1x.com/2020/04/22/JUylLR.png" alt="12.png" style="zoom: 80%;" />

<ul>
<li>之后，作者研究了BA-SVs两侧的TAD的类型，发现大多数都是相同的，但不同的出现概率要大于预期，所以作者就研究了发生在活跃和抑制区域之间的BA-deletions，发现缺失导致的TAD的融合会使得附近基因表达上调，但这种现象并不是普遍存在的，图解如下</li>
</ul>
<p>图中黑色的块代表边界，阴影部分代表 BA-deletions 区域，WNT4表达上调37倍</p>
<img data-src="https://s1.ax1x.com/2020/04/22/JUytJO.png" alt="13.png" style="zoom: 50%;" />

<p>e图SLC22A2基因表达上调了26倍，但f图中SLC2A10只有1.1倍</p>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyaSe.png" alt="14.png" style="zoom: 33%;" />

<ul>
<li>但作者发现整体上BA-deletions附近的基因表达并没有显著差异，只有14%发生了两倍以上的变化，图示如下</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyGo6.png" alt="15.png" style="zoom: 80%;" />

<p>综上，作者总结出：在癌细胞基因组中基因的调控是多因素的，虽然在某些特定情况下染色质折叠的扰动会引起表达水平的差异，但并不是总是出现的。</p>
<h3 id="Cell-type-specific-alterations-in-chromatin-folding-patterns-by-different-SV-types"><a href="#Cell-type-specific-alterations-in-chromatin-folding-patterns-by-different-SV-types" class="headerlink" title="Cell-type-specific alterations in chromatin folding patterns by different SV types."></a>Cell-type-specific alterations in chromatin folding patterns by different SV types.</h3><ul>
<li>作者研究了BA-deletions, BA-inversions, BA-duplications and BA-complex rearrangements 是如何影响染色质交互热图的，结果如下</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyYFK.png" alt="16.png" style="zoom: 50%;" />

<p>附图，图中黑色框框住的就是倒位导致的改变</p>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyNWD.png" alt="17.png" style="zoom: 50%;" />

<ul>
<li>然后作者把跨越TAD边界和SV断点的交互称作Inter-breakpoint/TAD interactions 只跨越断点的交互称为Intra-breakpoint/TAD interactions ，作者发现后一种交互要强于前一种，所以SVs可能会导致跨越边界的交互的形成，还可能会导致新的TAD的形成。图示如下</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUydQH.png" alt="18.png" style="zoom: 50%;" />

<ul>
<li>作者举了两个TAD改变的例子</li>
</ul>
<p>左图是倒位导致的TAD的融合，右图是加倍导致的TAD的形成</p>
<img data-src="https://s1.ax1x.com/2020/04/22/JUywyd.png" alt="19.png" style="zoom: 50%;" />

<h3 id="Complex-rearrangements-markedly-change-chromatin-folding-maps-in-the-cancer-genomes"><a href="#Complex-rearrangements-markedly-change-chromatin-folding-maps-in-the-cancer-genomes" class="headerlink" title="Complex rearrangements markedly change chromatin folding maps in the cancer genomes"></a>Complex rearrangements markedly change chromatin folding maps in the cancer genomes</h3><ul>
<li>复杂的重排现象会明显导致Hi-C热图发生明显的变化，如下图所示：左图展示了8号染色体上的一个复杂的重排区域（ Green, tandem duplication; red, deletion; cyan and purple, inversion），右图展示了5号和8号染色体上以及两个染色体间的之间复杂的重排区域导致的热图的变化</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/22/JUyDeI.png" alt="20.png" style="zoom: 67%;" />

<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><ul>
<li>本文作者探讨了SVs在多种肿瘤类型中的分布及其在染色质折叠和基因调控中的潜在作用。</li>
<li>其次作者发现，一些边界的改变只分布在某一特定的癌症中，这可能与一些特定的癌症驱动基因有关</li>
<li>删除易于发生在TADs和LADs内，而加倍倾向于发生在TADs之间，这表明不同类型的SVs的产生机制可能存在差异</li>
<li>值得注意的是，作者没有观察到TAD的扰动与基因的总体表达水平变化之间有很强的关联，只有14%的TAD扰动导致了2倍以上的表达上调</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Disruption of chromatin folding domains by somatic genomic rearrangements in human cancer</p>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>指导植物RNA聚合酶II转录的‘GPS’</title>
    <url>/codeHub/2020/04/19/2020-06%E4%BB%A5%E5%89%8D/24%E6%8C%87%E5%AF%BC%E6%A4%8D%E7%89%A9RNA%E8%81%9A%E5%90%88%E9%85%B6II%E8%BD%AC%E5%BD%95%E7%9A%84%E2%80%98GPS%E2%80%99/</url>
    <content><![CDATA[<h1 id="指导植物RNA聚合酶II转录的‘GPS’"><a href="#指导植物RNA聚合酶II转录的‘GPS’" class="headerlink" title="指导植物RNA聚合酶II转录的‘GPS’"></a>指导植物RNA聚合酶II转录的‘GPS’</h1><p>组蛋白翻译后的修饰，通过调节转录过程中RNA聚合酶II的动态变化，塑造了基因的表达图谱。转录分为转录起始、延伸和终止等阶段，在植物中能够标识特定转录阶段的组蛋白修饰仍旧比较模糊。通过CHIP-seq技术，能够得到全基因组上组蛋白修饰的分布；并且发现了一些能够指导RNAII转录的基因组位置信号（GPS）。同时阐明了一些组蛋白修饰因子（readers、weiters、erasers），在基因表达和生物学上的作用。在不同的转录阶段，RNAPII有着不同的功能，这可能与组蛋白修饰存在一定的关联。</p>
<h3 id="组蛋白作为基因转录的坐标"><a href="#组蛋白作为基因转录的坐标" class="headerlink" title="组蛋白作为基因转录的坐标"></a>组蛋白作为基因转录的坐标</h3><p>基因的表达依赖于转录过程中RNA聚合酶II的不同功能，根据功能的不同将转录分成了3个阶段：1.转录起始、2.延伸、3.终止。那么问题来了，RNA聚合酶II是如何识别基因不同的位置信号来执行不同的功能的呢？</p>
<p><img data-src="https://s1.ax1x.com/2020/04/19/JKjSRU.png" alt="RNAPII转录周期"></p>
<p>在真核生物中，基因组被组装在核小体内，而核小体又由组蛋白八聚体组成（H2A、H2B、H3、H4）；组蛋白的N端氨基酸通常会经过多种的翻译后修饰（PTMs），其中就包括甲基化、乙酰化、泛素化，这些组蛋白修饰把染色质结构和基因表达联系起来。</p>
<p>组蛋白修饰通常由3种酶进行催化：</p>
<ol>
<li>‘reader’ enzymes 识别需要修饰的位点</li>
<li>‘writer’ enzymes 添加对应的修饰</li>
<li>‘eraser’ enzymes 去除对应的修饰</li>
</ol>
<p>通过这3种酶的作用，实现基因组上的组蛋白修饰。</p>
<p>通过ChIP-seq、CUT&amp;RUN-seq或者是CUT&amp;Tag-seq能够揭示全基因组范围的组蛋白修饰；但是这里存在一个争论：组蛋白修饰能够指导RNAPII的转录，但反过来RNAPII的活动也能够塑造染色质的 landscape；或者这两者之间存在着反馈调节作用。</p>
<p><img data-src="https://s1.ax1x.com/2020/04/19/JKXUbR.png" alt="几种seq技术"></p>
<h3 id="组蛋白修饰确立了RNAPII所处的时期"><a href="#组蛋白修饰确立了RNAPII所处的时期" class="headerlink" title="组蛋白修饰确立了RNAPII所处的时期"></a>组蛋白修饰确立了RNAPII所处的时期</h3><p>RNAPII在启动子区域的转录起始位点（TSSs），启动基因的转录；在完成转录起始之后，RNAII开始进入到gene body区域延伸新和成的RNA链，在刚开始进入gene body区域时RNAPII的移动速度会放缓，这一阶段也被称为（early elongation）；之后RNAPII 开始继续合成RNA（elongation）；在经过基因3’端的多聚腺苷酸位点时RNAPII的速度在一次放缓，协助转录的终止。</p>
<p>与此同时在转录的过程中还有一些共转录事件在进行着，例如 5’加帽，剪切、多聚腺苷酸化。那么RNAPII又是如何在对应的位置进入正确的阶段呢？有趣的是，通过CHIP-seq数据分析发现，组蛋白修饰的出现与不同的转录时期存在一定的关联，因此基因区域的组蛋白修饰可能是指导RNAPII进行正确转录的一种位置信号。</p>
<h3 id="在转录不同阶段的组蛋白修饰"><a href="#在转录不同阶段的组蛋白修饰" class="headerlink" title="在转录不同阶段的组蛋白修饰"></a>在转录不同阶段的组蛋白修饰</h3><p>在对组蛋白修饰和基因转录进行了广泛的研究之后，普遍认为在基因转录的不同阶段，存在着一些位置信号指导基因的转录。例如H3K9ac、H3K4me3在转录起始位点TTSs处富集，在转录早期延伸阶段H4K4me2和H3K36me3与其他peaks信号相比，稍微下降，这可能和RNAPII的失速有关。</p>
<p>在转录延伸阶段H2Bun（H2B泛素化）、和H3K4me3与转录激活呈相关。在转录终止阶段同样存在着一些组蛋白修饰信号。总的来说，整片文章的精华都集中在这张图片里了。</p>
<p><img data-src="https://s1.ax1x.com/2020/04/19/JKXVgg.png" alt="组蛋白修饰与转录阶段"></p>
<h3 id="基于‘GPS’指导植物的发育和与环境的互作"><a href="#基于‘GPS’指导植物的发育和与环境的互作" class="headerlink" title="基于‘GPS’指导植物的发育和与环境的互作"></a>基于‘GPS’指导植物的发育和与环境的互作</h3><p>当组蛋白修饰酶发生突变时，通常对基因的表达产生巨大的影响，最终导致生长、发育或者与环境互作方面的缺陷。</p>
<p><img data-src="https://s1.ax1x.com/2020/04/19/JKXiUP.png" alt="与植物生长发育"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>A G(enomic)P(ositioning)S(ystem) for PlantRNAPII Transcription  </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Promise源码解析</title>
    <url>/codeHub/2020/04/19/2020-06%E4%BB%A5%E5%89%8D/23Promise%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>众所周知javascript是一门单线程语言，这种设计有效的避免了多线程带来的复杂同步问题。但有时候单线程模式遇到耗时较长的任务时，会拖延整个程序的进度，造成浏览器长时间无响应。为了解决这个问题，js将任务分为两种执行模式：</p>
<ul>
<li>异步模式</li>
<li>同步模式</li>
</ul>
<p>为了获得异步任务得到的结果，最常见的做法是使用回调函数。但是回调函数剥夺了我们使用return和throw的权利，而且代码以一种向右扩展的风格；不利于维护（回调地狱)，还会产生一些回调问题。</p>
<ul>
<li>回调过早（一般是异步被同步调用）；</li>
<li>回调过晚或没有回调；</li>
<li>回调次数过多；</li>
<li>等等</li>
</ul>
<a id="more"></a>

<p><img data-src="https://user-gold-cdn.xitu.io/2018/7/11/1648870b900aeb47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="回调地狱"></p>
<p>​    值得注意的是，两种任务模式是位于两个任务队列里的；只有同步队列里的任务都执行完成后才会开始执行异步队列里的任务。这里在for循环同步任务结束后才会进入到异步队列执行异步任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'同步任务1'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'异步任务1'</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">var</span> j</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">      i = i - <span class="number">0.5</span></span><br><span class="line">      j = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line"><span class="comment">//同步任务1</span></span><br><span class="line"><span class="comment">//9999999.5</span></span><br><span class="line"><span class="comment">//异步任务1</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise状态"><a href="#Promise状态" class="headerlink" title="Promise状态"></a>Promise状态</h3><p>Promise在ES6中被引入，作为解决回调地狱的标准方法。Promise有三种状态</p>
<ul>
<li>padding</li>
<li>resolve</li>
<li>reject</li>
</ul>
<p>在任意时刻promise只能处于一种状态，并且状态只能从padding向resolve或者padding向reject转变；状态一经改变后就无法撤回。</p>
<p>在定义一个promise对象时，通过<code>reject()</code>或者<code>resolve()</code>来指定状态是否成功；<code>then</code>方法中定义对应的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功回调:'</span> + value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="回调函数定义顺序"><a href="#回调函数定义顺序" class="headerlink" title="回调函数定义顺序"></a>回调函数定义顺序</h3><ol>
<li>后定义回调函数</li>
</ol>
<p>这里<code>Promise</code>对象中，同步执行回调函数，此时then方法还没有执行，因此then中回调函数的定义时后定义的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功回调:'</span> + value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>先定义回调函数</li>
</ol>
<p>这里<code>Promise</code>对象中，异步执行回调函数，因此同步队列中的then方法执行完后才会开始执行异步队列中的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1s后启动异步回调:'</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">  (value) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功回调:'</span> + value)</span><br><span class="line">  &#125;,</span><br><span class="line">  (reason) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败回调:'</span> + reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p><code>then</code>方法返回的是一个新的<code>promise</code>对象，因此返回的新的<code>promise</code>对象又可以调用对应的then方法。</p>
<p>then方法中返回promise对象的三种方式：</p>
<ul>
<li>默认</li>
<li>新的<code>promise</code>对象</li>
<li>抛出错误</li>
</ul>
<h4 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then(</span><br><span class="line">      (value) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'成功回调:'</span> + value)</span><br><span class="line">      &#125;,</span><br><span class="line">      (reason) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'失败回调:'</span> + reason)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">then(</span><br><span class="line">      (value) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'成功回调:'</span> + value)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">              resolve()</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h4 id="返回新的Promise对象"><a href="#返回新的Promise对象" class="headerlink" title="返回新的Promise对象"></a>返回新的Promise对象</h4><p>在新的Promise对象中可以指定新的回调函数，并且这个新的Promise函数一定是在第一个Promise函数后执行的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then(</span><br><span class="line">        (value) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'成功回调:'</span> + value)</span><br><span class="line">        &#125;,</span><br><span class="line">        (reason) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'失败回调:'</span> + reason)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">2</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<h3 id="值传透"><a href="#值传透" class="headerlink" title="值传透"></a>值传透</h3><p>在Promise返回是吧状态后，如果没有定义对应的失败回调，错误将会传递到catch，这一切是通过默认的失败回调执行的</p>
<p>默认的失败回调如下，因此如果<code>then</code>中没有定义对应的失败回调则会将错误抛出，最后传递到catch中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(reason) =&gt; &#123;</span><br><span class="line">  <span class="keyword">throw</span> reason</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定定义失败回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)      </span><br><span class="line"> .then(</span><br><span class="line">    (value) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'成功回调:'</span> + value)</span><br><span class="line">    &#125;,</span><br><span class="line">    (reason) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'自定义解决:'</span> + reason)</span><br><span class="line">      <span class="keyword">throw</span> <span class="number">2</span> + reason</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'值传透:'</span> + reason)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>同样的如果then方法中传递的不是回调函数，它将会将结果传递给下一个promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">    .then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>))</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//foo</span></span><br></pre></td></tr></table></figure>

<h3 id="链终止"><a href="#链终止" class="headerlink" title="链终止"></a>链终止</h3><p>在catch后。Promise仍旧可以传递，通过返回一个padding状态的Promise实现链终止</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">      .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'值传透:'</span> + reason)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">      .catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'值传透:'</span> + reason)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;) <span class="comment">//padding状态</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>



<h3 id="1-参考"><a href="#1-参考" class="headerlink" title="1.参考"></a>1.参考</h3><ol>
<li><a href="https://juejin.im/post/5b45bea65188251b1c3ce1ec" target="_blank" rel="noopener">Promise解决了什么问题</a></li>
<li><a href="https://www.jianshu.com/p/4e8aaa87540a" target="_blank" rel="noopener">值传透</a></li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Tweenjs动画插件</title>
    <url>/codeHub/2020/04/17/2020-06%E4%BB%A5%E5%89%8D/22Tweenjs%E5%8A%A8%E7%94%BB%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>TweenJS允许你以一种平滑的方式来改变对象的属性。所有的动画处理函数都封装成了API，你需要做的仅仅是告诉它哪些属性需要被修改，修改的值的范围，修改所经历的时间、轨迹的选择。</p>
<h3 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h3><ul>
<li>首先给<code>TWEEN</code>对象传递一个对象，里面包含了需要修改的属性</li>
<li>传递属性范围值</li>
<li>激活TWEEN实例</li>
<li>使用主函数进行渲染</li>
</ul>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先为位置创建一个补间(tween)</span></span><br><span class="line"><span class="keyword">var</span> tween = <span class="keyword">new</span> TWEEN.Tween(position);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后告诉 tween 我们想要在1000毫秒内以动画的形式移动 x 的位置</span></span><br><span class="line">tween.to(&#123; <span class="attr">x</span>: <span class="number">200</span> &#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">tween.start();</span><br><span class="line"><span class="comment">//进行渲染</span></span><br><span class="line">animate();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	requestAnimationFrame(animate);</span><br><span class="line">	<span class="comment">// [...]</span></span><br><span class="line">	TWEEN.update();</span><br><span class="line">	<span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性更新时所做的操作</span></span><br><span class="line">tween.onUpdate(<span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(object.x);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-进度条展示"><a href="#2-进度条展示" class="headerlink" title="2.进度条展示"></a>2.进度条展示</h3><p><img data-src="https://s1.ax1x.com/2020/04/17/JZzUN8.gif" alt="进度条"></p>
<p>使用SVG绘制对应的圆形图片，这里使用两个圆进行重叠展示，其中一个圆充当背景色，另外一个充当进度条；数字的累积同样使用动画效果。</p>
<p>在<code>Vue</code>中通过this获取到DOM中的样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.$bar.style.strokeDashoffset</span><br></pre></td></tr></table></figure>

<h4 id="TWEENJS动态修改样式"><a href="#TWEENJS动态修改样式" class="headerlink" title="TWEENJS动态修改样式"></a>TWEENJS动态修改样式</h4><p>同时对两个属性进行操作，在动画<code>onUpdate</code>回调函数中分别去渲染对应的DOM节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> TWEEN.Tween(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'strokeDashoffset'</span>: (<span class="keyword">this</span>.width - <span class="keyword">this</span>.radius) * <span class="number">3.14</span>,</span><br><span class="line">    <span class="string">'showProgress'</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">).to(&#123;</span><br><span class="line">  <span class="string">'strokeDashoffset'</span>: (<span class="keyword">this</span>.width - <span class="keyword">this</span>.radius) * <span class="number">3.14</span> * (<span class="number">100</span> - <span class="keyword">this</span>.progress) / <span class="number">100</span>,</span><br><span class="line">  <span class="string">'showProgress'</span>: <span class="keyword">this</span>.progress</span><br><span class="line">&#125;, <span class="keyword">this</span>.duration).onUpdate(<span class="function">(<span class="params">tween</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.$refs.$bar.style.strokeDashoffset = tween.strokeDashoffset</span><br><span class="line">  <span class="keyword">this</span>.showprogress = tween.showProgress.toFixed(<span class="number">0</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>

<h3 id="3-无限链式"><a href="#3-无限链式" class="headerlink" title="3.无限链式"></a>3.无限链式</h3><p><img data-src="https://s1.ax1x.com/2020/04/17/JZza4S.gif" alt="无限链式调用"></p>
<ul>
<li>创建两个<code>TWEEN</code>实例对象</li>
<li>使用<code>chain</code>相互链起来，实现无限循环动画</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义下降动画</span></span><br><span class="line"><span class="keyword">var</span> tweenDown = <span class="keyword">new</span> TWEEN.Tween(</span><br><span class="line">        &#123;</span><br><span class="line">          top: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      tweenDown.to(&#123;</span><br><span class="line">        top: <span class="number">15</span></span><br><span class="line">      &#125;, <span class="number">1000</span>).onUpdate(<span class="function">(<span class="params">tween</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.Nextbutton.style.top = tween.top + <span class="string">"px"</span></span><br><span class="line">        <span class="comment">// this.$refs.Nextbutton.style.top = tween.top</span></span><br><span class="line">      &#125;).start()</span><br><span class="line"><span class="comment">//定义下降动画</span></span><br><span class="line">      <span class="keyword">var</span> tweenUp = <span class="keyword">new</span> TWEEN.Tween(</span><br><span class="line">        &#123;</span><br><span class="line">          top: <span class="number">15</span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      tweenUp.to(&#123;</span><br><span class="line">        top: <span class="number">10</span></span><br><span class="line">      &#125;, <span class="number">800</span>).onUpdate(<span class="function">(<span class="params">tween</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.Nextbutton.style.top = tween.top + <span class="string">"px"</span></span><br><span class="line">        <span class="comment">// this.$refs.Nextbutton.style.top = tween.top</span></span><br><span class="line">      &#125;).start()</span><br><span class="line"><span class="comment">//无限链式调用</span></span><br><span class="line">tweenDown.chain(tweenUp)</span><br><span class="line">tweenUp.chain(tweenDown)</span><br></pre></td></tr></table></figure>

<h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h3><ol>
<li><a href="https://github.com/tweenjs/tween.js/blob/master/docs/user_guide_zh-CN.md" target="_blank" rel="noopener">https://github.com/tweenjs/tween.js/blob/master/docs/user_guide_zh-CN.md</a> </li>
<li><a href="https://codepen.io/jackpan/pen/pdVVzE/" target="_blank" rel="noopener">https://codepen.io/jackpan/pen/pdVVzE/</a> </li>
<li><a href="https://segmentfault.com/a/1190000013219501" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013219501</a> </li>
<li><a href="https://www.cnblogs.com/createGod/p/6941340.html" target="_blank" rel="noopener">https://www.cnblogs.com/createGod/p/6941340.html</a> </li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>植物DNA甲基化机制和靶向操纵工具</title>
    <url>/codeHub/2020/04/17/2020-06%E4%BB%A5%E5%89%8D/21%E6%A4%8D%E7%89%A9DNA%E7%94%B2%E5%9F%BA%E5%8C%96%E6%9C%BA%E5%88%B6%E5%92%8C%E9%9D%B6%E5%90%91%E6%93%8D%E7%BA%B5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>DNA甲基化是表观遗传中的一种，它能够调控多种生物途径，例如：基因的表达、基因组的稳定性。在植物中对某个位点突变或者使用药物的方法被用来研究DNA甲基化的作用。许多工具就能够直接的对特定位点的DNA甲基化进行操作，从而评估DNA甲基化在特定途径中的直接效应。最近研究者们，通过改造DNA-binding蛋白，实现对甲基化机器的招募，从而改变特定位点的DNA甲基化水平。</p>
<a id="more"></a>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>DNA甲基化是一种保守的表观遗传标记，调控着包括基因表达、基因组稳定性和基因印记等多种生物学过程；因此破坏DNA甲基化会导致发育异常。在植物中，DNA甲基化包含以下几种:</p>
<ul>
<li>CG甲基化</li>
<li>CHG</li>
<li>CHH</li>
</ul>
<p>这些甲基化标记主要富集在异染色质区域的转座子、重复序列上，并且扮演着一个主要的角色-在转录水平沉默基因的表达。在内含子区域的转座子、重复元件的甲基化同样会影响mRNA的加工，例如改变mRNA的剪切方式、改变mRNA3‘端的多聚腺苷酸位点。在有些地方，DNA甲基化也能够促进基因的表达，通过DNA methyl-readers <strong>SU3-9</strong>.</p>
<p>通过基因突变或者药物的方式虽然能够改变DNA甲基化，但是这些方法是全基因组范围的改变甲基化水平，不能够实现研究特定位点的甲基化。因此为了达到这个目的，研究者们通过开发一些位点特异的工具来操纵DNA甲基化水平，并且在特定位点改变基因的表达模式来产生新的等位基因。</p>
<h3 id="植物中DNA甲基化机制"><a href="#植物中DNA甲基化机制" class="headerlink" title="植物中DNA甲基化机制"></a>植物中DNA甲基化机制</h3><p>在植物中，通过RNA介导的DNA甲基化（RdDM）途径来调控DNA的甲基化水平。DNA甲基转移酶2（<strong>DRM2</strong>）在不依赖于序列特异性的情况，催化新的DNA的甲基化。在RdDM途径中，植物中特异的RNA聚合酶IV合成单链RNA，进而在RDR2的催化下合成双链RNA（dsRNA）。dsRNA在<strong>DCL3</strong>的催化下被切割成24nt的small interfering RNA（siRNA），最后和AGO4/6 形成复合物。</p>
<p>在组蛋白reader <strong>SHHH1</strong>和<strong>CLASSSY</strong>的招募下，RNA聚合酶IV被招募到染色质区域，通过AGO-siRNA的与目标序列进行互补，RNA聚合酶IV合成non-coding RNAs。一旦形成了  AGO-siRNAncRNA-Pol V ribonucleoprotein complex  ，DRM2倍招募到DNA处，进行甲基化</p>
<p><img data-src="https://s1.ax1x.com/2020/04/17/JEBy5R.png" alt="甲基化机制"></p>
<p>在新的甲基化位点生成后，通过<strong>MET1</strong>、<strong>CMT2/3</strong>维持DNA的甲基化；这些酶分别针对<strong>CG</strong>|、<strong>CHH</strong>、<strong>CHG</strong>三种甲基化类型。在经历多轮的DNA复制后，DNA甲基化也可能会丢失在缺少  methylation maintenance时。植物中的去甲基酶就包括<strong>ROS1</strong>、<strong>DME</strong>、<strong>DML2/3</strong>。</p>
<h3 id="在植物中靶向操纵DNA甲基化"><a href="#在植物中靶向操纵DNA甲基化" class="headerlink" title="在植物中靶向操纵DNA甲基化"></a>在植物中靶向操纵DNA甲基化</h3><p><img data-src="https://s1.ax1x.com/2020/04/17/JEBfKO.png" alt="siRNAs"></p>
<h4 id="通过siRNAs介导靶向甲基化"><a href="#通过siRNAs介导靶向甲基化" class="headerlink" title="通过siRNAs介导靶向甲基化"></a>通过siRNAs介导靶向甲基化</h4><p>研究者通过使用不同的病毒、或者转化载体来产生与靶标位点互补的siRNAs。当siRNA靶向基因的启动子区域时，能够诱导RdDM和基因的转录沉默，其中应用最广泛就是VIGS。反向重复序列IR，同样能够产生siRNAs。</p>
<h4 id="改造DNA-binding蛋白操纵DNA甲基化"><a href="#改造DNA-binding蛋白操纵DNA甲基化" class="headerlink" title="改造DNA-binding蛋白操纵DNA甲基化"></a>改造DNA-binding蛋白操纵DNA甲基化</h4><p><img data-src="https://s1.ax1x.com/2020/04/17/JEBHPI.png" alt="DNA-binding"></p>
<p>例如DNA结合蛋白：  ZFs、TALEs  、CRISPR-dCas9，直接结合到靶标位点来招募甲基化机器改变附近的甲基化水平。这些改造的DNA-binding蛋白即使在缺少siRNAs的情况下，依旧能够招募聚合酶IV和AGO来驱动DNA的甲基化</p>
<h4 id="靶向的去除DNA的甲基化"><a href="#靶向的去除DNA的甲基化" class="headerlink" title="靶向的去除DNA的甲基化"></a>靶向的去除DNA的甲基化</h4><p>同样是使用改造的DNA-binding蛋白对靶标位点进行去甲基化，在动物中对<strong><em>FWA</em></strong>，进行可遗传的去甲基化，促进<strong><em>FWA</em></strong>的表达。</p>
<h3 id="conclusions"><a href="#conclusions" class="headerlink" title="conclusions"></a>conclusions</h3><p>这些靶向的操纵特定位点的甲基化工具虽然能够起到作用，但是如何精确、高效的并且减少脱靶率仍旧是需要进一步优化的。这些工具可以被用来修复那些不希望出现的甲基化位点，例如在植物的组织培养中后代甲基化水平的改变。并且甲基化化水平的改变是能够永久遗传的，从而改变基因的表达模式；可以考虑作为产生新的等位基因的一种方式。这些tools直接操纵蛋白质和RNA，不需要经过遗传转化从而实现操纵植物DNA的甲基化。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>DNA methylation in plants: mechanisms and tools for targeted manipulation  </li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>sgRNAcase9设计</title>
    <url>/codeHub/2020/04/16/2020-06%E4%BB%A5%E5%89%8D/20sgRNAcase9%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>使用<code>sgRNAcas9</code>软件包进行基于参考基因组的sgRNA 设计：针对每条给定的query 序列首先搜索<code>NGG</code>的PAM结构，找到对应的motif后，在全基因组范围内评估<code>on-target</code>和<code>off-target</code>值。如果有多条质量比较好的<code>on-target</code>sgRNA，后面还可以根据基因注释文件筛选那些距离5’端更近的sgRNA。</p>
<blockquote>
<p> <a href="http://www.biootools.com/software.html#tab1" target="_blank" rel="noopener">软件包地址</a></p>
</blockquote>
<a id="more"></a>

<p><img data-src="https://s1.ax1x.com/2020/04/16/JEVP3T.png" alt="CRISPRcase9"></p>
<h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><ol>
<li>提取基因的cDNA序列</li>
<li>使用软件包中<code>sgRNAcas9.pl</code>脚本，进行全基因组范围搜索靶位点</li>
<li>根据参考基因组的注释文件，对靶向位点进行注释（看是否靶向exon区域）</li>
</ol>
<h3 id="1-全基因组搜索sgRNA"><a href="#1-全基因组搜索sgRNA" class="headerlink" title="1.全基因组搜索sgRNA"></a>1.全基因组搜索sgRNA</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl sgRNAcas9_3.0.5.pl </span><br><span class="line">-i genes_end.fasta </span><br><span class="line">-x 20 </span><br><span class="line">-l 40 </span><br><span class="line">-m 60 </span><br><span class="line">-g Ghirsutum_genome.fasta </span><br><span class="line">-o b </span><br><span class="line">-t s -v l -n 5 -s -3 -e 33</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-i &lt;str&gt;                 Input file</span><br><span class="line">-x &lt;int&gt;                 Length of sgRNA[20]</span><br><span class="line">-l &lt;int&gt;                 The minimum value of GC content [20]</span><br><span class="line">-m &lt;int&gt;                 The maximum value of GC content [80]</span><br><span class="line">-g &lt;str&gt;                 The reference genome sequence</span><br><span class="line">-o &lt;str&gt;                 Searching CRISPR target sites using DNA strands based option(s/a/b)</span><br><span class="line">                         [s, sense strand searching mode]</span><br><span class="line">                         [a, anti-sense strand searching mode]</span><br><span class="line">                         [b, both strand searching mode]</span><br><span class="line">-t &lt;str&gt;                 Type of sgRNA searching mode(s/p)</span><br><span class="line">                           [s, single-gRNA searching mode]</span><br><span class="line">                           [p, paired-gRNA searching mode]</span><br><span class="line">-v &lt;str&gt;                 Operation system(w/l/u/m/a)</span><br><span class="line">                            [w, <span class="keyword">for</span> windows-32, 64]</span><br><span class="line">                            [l, <span class="keyword">for</span> linux-64]</span><br><span class="line">                            [u, <span class="keyword">for</span> linux-32]</span><br><span class="line">                            [m, <span class="keyword">for</span> MacOSX-64]</span><br><span class="line">                            [a, <span class="keyword">for</span> MacOSX-32]</span><br><span class="line">-n &lt;int&gt;                 Maximum number of mismatches [5]</span><br><span class="line">-s &lt;int&gt;                 The minimum value of sgRNA offset [-2] 错配罚分</span><br><span class="line">-e &lt;int&gt;                 The maximum value of sgRNA offset [32]</span><br><span class="line">-p &lt;str&gt;                 Output path</span><br></pre></td></tr></table></figure>

<h3 id="2-根据参考文件对sgRNA进行注释"><a href="#2-根据参考文件对sgRNA进行注释" class="headerlink" title="2.根据参考文件对sgRNA进行注释"></a>2.根据参考文件对sgRNA进行注释</h3><h4 id="2-1提取评分等级为一下的sgRNA-ID信息"><a href="#2-1提取评分等级为一下的sgRNA-ID信息" class="headerlink" title="2.1提取评分等级为一下的sgRNA ID信息"></a>2.1提取评分等级为一下的sgRNA ID信息</h4><ul>
<li>Best </li>
<li>repeat_sites_or_bad </li>
<li>low_risk </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#M表示错配碱基数</span></span><br><span class="line">0M	1M      2M    3M     rank </span><br><span class="line">2       0       0     0    repeat_sites_or_bad</span><br><span class="line">1       0       0    5    low_risk</span><br><span class="line">1       0       0    3    Best</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 例如repeat等级中0M靶向的位置有2个，我们要看看它靶向的位置是否是同一个基因，进行sgRNA评价 </p>
</blockquote>
<h4 id="2-2合并所有的sgRNA信息"><a href="#2-2合并所有的sgRNA信息" class="headerlink" title="2.2合并所有的sgRNA信息"></a>2.2合并所有的sgRNA信息</h4><p><code>cat A.Sort_OT_byID/*  &gt;all_genen_OT.txt</code></p>
<p>靶标序列评价</p>
<p> 使用自带的脚本<strong><em>ot2gtf_v2.pl\</em></strong>，对得到的sgRNA靶标进行评价，主要是看它是否靶向目标基因的外显子区域，或者存在靶向其他基因exon区域（脱靶情况）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl ../Usefull_Script/ot2gtf_v2.pl  -i Low_OT.text  -g ../Gh_gene.gtf  -o Low_OT_gtf_out.text</span><br><span class="line"><span class="comment">#也可以将上一步所有的OT文件合并之后，在运行脚本</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3去除脱靶的sgRNA"><a href="#2-3去除脱靶的sgRNA" class="headerlink" title="2.3去除脱靶的sgRNA"></a>2.3去除脱靶的sgRNA</h4><p>awk的原理:</p>
<ol>
<li>靶标基因与sgRNA的序列信息一致赋权值 0</li>
<li>sgRNA靶向同源基因和自己本身赋权值 0</li>
<li>靶标序列脱靶赋权值 1</li>
<li>最后将同一个sgRNA靶标的权值相加，为0则表示没有脱靶；否则脱靶舍弃</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#awk脚本</span></span><br><span class="line">-F <span class="string">"\t"</span> <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    a=substr($1,1,15);a1=substr($1,6,1);a2=substr($1,7,2);b1=substr($5,6,1);b2=substr($5,7,2)</span></span><br><span class="line"><span class="string">    &#125;&#123;</span></span><br><span class="line"><span class="string">if(a==$8)print $0"\t"0;</span></span><br><span class="line"><span class="string">else if(a1=="A"&amp;&amp;b1=="D")&#123;</span></span><br><span class="line"><span class="string">    if(a2==b2||a2=="02"&amp;&amp;b2==03||a2=="03"&amp;&amp;b2=="02")&#123;</span></span><br><span class="line"><span class="string">        print $0"\t"0;&#125;else print $0"\t"1;&#125;</span></span><br><span class="line"><span class="string">        else if(a1=="D"&amp;&amp;b1=="A")&#123;</span></span><br><span class="line"><span class="string">            if(a2==b2||a2=="02"&amp;&amp;b2=="03"||a2=="03"&amp;&amp;b2=="02")&#123;</span></span><br><span class="line"><span class="string">                print $0"\t"0;&#125;else print $0"\t"1;&#125;</span></span><br><span class="line"><span class="string">else print $0"\t"1;&#125;'</span> Best_Repeat_Low_OT_gtf  &gt;2222222</span><br></pre></td></tr></table></figure>

<p>得到的没有脱靶的sgRNA编号</p>
<p><img data-src="https://zpliu1126.github.io/Blog/img/sgRNAcase/otsgRNAcase.png" alt="没有脱靶sgRNA"></p>
<h3 id="3-sgRNA筛选"><a href="#3-sgRNA筛选" class="headerlink" title="3.sgRNA筛选"></a>3.sgRNA筛选</h3><p>经过上一步筛选后的sgRNA文件，我们需要根据以下几个指标筛选比较理想的靶标序列</p>
<ol>
<li>靶标序列尽量靠近5’端</li>
<li>同一个基因找两个靶标序列，尽量让这两段序列间隔在100bp左右</li>
</ol>
<p>自定义python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">usage:</span><br><span class="line">    -h|--help    <span class="keyword">print</span> help information</span><br><span class="line">    -g|--gff=    gff file path way</span><br><span class="line">    -s|--sgRNA=    sgRNA file path way</span><br><span class="line">    -l|--genelength=    length of gene</span><br><span class="line">    -r|--sequence=    sgRNA sequence path way</span><br><span class="line">    -o|--outfile=    output file path way</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://github.com/zpliu1126/Bioinformatic/blob/33379dd39a948ff6e463a9c9f31ca5fb837ac998/sgRNAcas9/comparisonsgRNA.py" target="_blank" rel="noopener">脚本获取</a></p>
</blockquote>
<h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h3><ol>
<li><a href="https://tiramisutes.github.io/2017/01/13/CRISPR-Designer.html" target="_blank" rel="noopener">tramisutes</a></li>
<li><a href="http://www.biootools.com/software.html#tab1" target="_blank" rel="noopener">sgRNAcase9</a></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python基于模块化编程</title>
    <url>/codeHub/2020/04/16/2020-06%E4%BB%A5%E5%89%8D/19python%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<img data-src="https://pypi.org/static/images/logo-large.svg" alt=" python模块化" style="zoom:80%;  float:left; margin-right:20px" />

<p>代码模块化是进行大型项目的必经之路，通过将代码进行模块化、解耦将功能进行模块化。在C语言中通过<code>include</code>语法，将不同模块的头文件进行重复利用；在javascript中使用<code>module export||require</code>语法实现模块的引入。同样在python中也可以引入自定义模块，简化代码。</p>
<a id="more"></a>

<h3 id="1-定义模块"><a href="#1-定义模块" class="headerlink" title="1.定义模块"></a>1.定义模块</h3><p>模块文件实际上就是一个<code>python</code>脚本，脚本中可以向外部提供变量、函数、类等数据结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 模块文件readHomolog.py</span></span><br><span class="line">def readHomologous(fileName,sep,columnId1,columnId2):</span><br><span class="line">   HomologDict=&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: <span class="comment">#调试模块时才会运行</span></span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="2-组织模块"><a href="#2-组织模块" class="headerlink" title="2.组织模块"></a>2.组织模块</h3><p>当一个工程之中包含有多个模块，并且模块之间具有一定的依赖关系；我们可以将这些模块组织起来形成一个packages。一个packages对应了一个工程所用到的模块，进而在python packa仓库发布。</p>
<ul>
<li>module1.py</li>
<li>modlue2.py</li>
</ul>
<blockquote>
<p>packages 目录中需要包含 <strong>init</strong>.py文件，说明当前目录为packages</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 目录结构</span></span><br><span class="line">homolog</span><br><span class="line">├── __init__.py</span><br><span class="line">├── __pycache__  <span class="comment">##引入packages后自动创建</span></span><br><span class="line">└── readHomolog.py</span><br></pre></td></tr></table></figure>

<h3 id="3-引入模块"><a href="#3-引入模块" class="headerlink" title="3.引入模块"></a>3.引入模块</h3><h4 id="3-1直接引入"><a href="#3-1直接引入" class="headerlink" title="3.1直接引入"></a>3.1直接引入</h4><p>当python可执行脚本与模块文件同属于一个父目录时，可以直接引入</p>
<p>例如<code>run.py</code>脚本与模块文件<code>readHomolog.py</code>同属于一个父目录，所以在<code>run.py</code>中直接import 即可。这里引入的是模块文件中自定义的函数</p>
<blockquote>
<p>from readHomolog import readHomologous</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">homolog</span><br><span class="line">├── __init__.py</span><br><span class="line">├── __pycache__  <span class="comment">##引入packages后自动创建</span></span><br><span class="line">└── readHomolog.py</span><br><span class="line">|__ run.py</span><br></pre></td></tr></table></figure>

<h3 id="3-2sys模块引入"><a href="#3-2sys模块引入" class="headerlink" title="3.2sys模块引入"></a>3.2sys模块引入</h3><p>使用<code>sys</code>模块，指定自定义模块所在目录，python能够自动进行搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在run.py中</span></span><br><span class="line">import sys</span><br><span class="line">sys.path.append(<span class="string">"模块所在绝对路径"</span>)</span><br><span class="line">from readHomolog import readHomologous</span><br></pre></td></tr></table></figure>

<h3 id="3-3通过pth文件进行配置"><a href="#3-3通过pth文件进行配置" class="headerlink" title="3.3通过pth文件进行配置"></a>3.3通过pth文件进行配置</h3><p>在python的安装路径<code>\Python35\Lib\site-packages</code>中配置对应的pth文件，</p>
<p>pth文件格式</p>
<p>conda中python对应的路径为<code>~/anaconda3/lib/python3.6/site-packages</code></p>
<blockquote>
<p>module_模块名.pth</p>
</blockquote>
<p>在脚本中直接引用即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">from readHomolog import readHomologous</span><br></pre></td></tr></table></figure>





<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://blog.csdn.net/weixin_34114823/article/details/92862081?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">模块引入</a></li>
<li><a href="https://blog.csdn.net/lengye7/article/details/90045498?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3" target="_blank" rel="noopener">模块属性</a></li>
<li><a href="https://blog.csdn.net/lengye7/article/details/90045498?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3" target="_blank" rel="noopener">模块组织</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>三维基因组中的结构变异</title>
    <url>/codeHub/2020/04/15/2020-06%E4%BB%A5%E5%89%8D/18%E4%B8%89%E7%BB%B4%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%8F%98%E5%BC%82/</url>
    <content><![CDATA[<h1 id="三维基因组中的结构变异"><a href="#三维基因组中的结构变异" class="headerlink" title="三维基因组中的结构变异"></a>三维基因组中的结构变异</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>染色体在结构和数量上的重排统称为结构变异（SV），它在很大程度上对人类的遗传多样性做出了贡献，因此其与癌症、罕见疾病和进化具有高度的相关性，近来的研究表明，SVs不仅仅可以影响基因剂量，还能影响基因的调控，SVs可以通过扰动TAD（topologically associating domains）来改变调控元件的拷贝数或对三维基因组造成影响，由于这些位置效应，SVs会影响距离SVs断点较远的基因的表达，从而导致疾病的发生，所以在解释这些疾病的病理的时候，必须要考虑SVs对三维基因组和基因表达调控的影响。</p>
<a id="more"></a>

<p>知识补充（在之后的文章中遇到不会的生物关键词，可以来这里查询）</p>
<ul>
<li>结构变异（SV）包括以下五种类型：deletions（缺失）, duplications（加倍）, inversions（倒位）, insertions（插入） and translocations （易位）</li>
<li>位置效性是指SVs可以不影响编码序列或启动子区域而导致疾病的发生</li>
<li>Copy number variation (CNV)：一种遗传变异只包括数量上的染色体重排，如缺失、加倍</li>
<li>Penetrance（外显率）：一种对有特定遗传变异(如某一特定基因的突变)的人表现出遗传障碍的症状和体征的比例的测量。如果有一些个体存在这种突变没有表现出这种疾病，这种情况称为 incomplete penetrance（不完全外显）</li>
<li>Haploinsufficiency（单倍剂量不足）：基因的一个拷贝被灭活或缺失，剩下的拷贝基因的表达不足以保持正常功能的一种状态。</li>
<li>Gene dosage （基因的剂量）：一个基因的拷贝数，包括在基因组中这个基因的所有的调控区域。</li>
<li>Intra- TAD SVs ：出现在TAD内部的结构变异</li>
<li>Inter- TAD SVs ：出现在TADs间的结构变异</li>
<li>TAD shuffling ：基因组内TADs的重排列</li>
<li>Enhancer adoption ：其中一个基因的异常表达是由位于不同调节区域的另一个基因的增强子所驱动的这种现象，又称作Enhancer hijacking（增强子劫持）</li>
</ul>
<h2 id="Structural-Variation-In-Disease"><a href="#Structural-Variation-In-Disease" class="headerlink" title="Structural Variation In Disease"></a>Structural Variation In Disease</h2><p>用于鉴定SVs的生物学方法有很多，但都各有利弊</p>
<ul>
<li>array comparative genomic hybridization (array  CGH) 被广泛用于鉴定CNV，但它的分辨率较低而且无法鉴定 balanced rearrangements </li>
<li>Whole- genome sequencing (WGS)可以鉴定所有类型的SVs，但它不能在重复的区域（出现多个断点）鉴定断点</li>
<li>Long- read sequencing technology可以很好的鉴定SVs和断点，但由于价格问题不能用于日常的临床诊断</li>
</ul>
<h2 id="De-Novo-Structural-Variation"><a href="#De-Novo-Structural-Variation" class="headerlink" title="De Novo Structural Variation"></a>De Novo Structural Variation</h2><ul>
<li>在人类基因组有多少SVs和疾病有关是一个重要的问题，因为新发生的SVs通常和疾病的发生有关，所以要想将基因组的多态性和导致疾病的SVs区分开，就需要去鉴定SVs是新发生的还是遗传于上一代的。</li>
<li>由目前的研究来看，即使使用相同的数据，估计出的新发生SVs的比率和其对疾病的影响也有很大不同。</li>
<li>虽然新生的SVs更容易引起疾病，但很多因素均会使得外显率降低，可能是由于潜在的隐形或者双等位基因遗传</li>
</ul>
<h2 id="Gene-Dosage"><a href="#Gene-Dosage" class="headerlink" title="Gene Dosage"></a>Gene Dosage</h2><ul>
<li>SVs影响编码序列是用根据它对基因的剂量的影响来解释的，这个方法在研究孟德尔疾病的病理时取得了巨大的成功，这个方法主要是用array  CGH数据和动物的数据去鉴定疾病基因</li>
<li>由于大多数SVs也影响非编码区域，所以还需要考虑基因的调控机制</li>
</ul>
<h2 id="From-Linear-View-To-3D-Perspective"><a href="#From-Linear-View-To-3D-Perspective" class="headerlink" title="From Linear View To 3D Perspective"></a>From Linear View To 3D Perspective</h2><ul>
<li>人的基因组种存在大量的调控序列，大多数的SVs会影响调控因子的位置和数量，在三维基因组种这些可能会影响空间结构，所以说了解基因组的空间结构对理解SVs的潜在致病性十分重要，（如果想详细了解基因组的空间结构，请阅读此<a href="[https://biocottonhub.github.io/codeHub/2020/04/08/15%E4%B8%89%E7%BB%B4%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B9%8BTAD%E7%9A%84%E5%BD%A2%E6%88%90%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81/](https://biocottonhub.github.io/codeHub/2020/04/08/15三维基因组之TAD的形成机制以及其特征/)">文章</a>的Introduce部分）</li>
<li>SVs通常会改变Hi-C的数据结果，还会留下一些信号供我们进一步理解，如缺失通常会使得原来被分离的两个区域发生新的交互。</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/15/Jik8gA.png" alt="3D" style="zoom: 50%;" />

<img data-src="https://s1.ax1x.com/2020/04/15/JPxLEd.png" alt="FIG1" style="zoom: 50%;" />

<h2 id="The-3D-Regulatory-Landscape"><a href="#The-3D-Regulatory-Landscape" class="headerlink" title="The 3D Regulatory Landscape"></a>The 3D Regulatory Landscape</h2><ul>
<li>染色质的折叠不仅束缚了染色质还为以增强子驱使的长距离的基因调控提供了条件，长距离的基因表达调控通常包含两种不同的顺式作用元件：启动子（由核心启动子和附近的调控元件组成）；更多的远端调控单位（包括所谓的增强子或被称作基因座控制区），TAD同时限制了增强子作用的基因组区域</li>
<li>60–70%的TAD在不同的细胞类型和五种类型之间都是保守的，这说明了TAD在基因组形式十分基础的功能</li>
<li>TAD的鉴定十分依赖于计算机的算法，但其受限于分辨率和阈值的调整</li>
</ul>
<h2 id="Enhancer-Redundancy"><a href="#Enhancer-Redundancy" class="headerlink" title="Enhancer Redundancy"></a>Enhancer Redundancy</h2><ul>
<li>研究表明，发育基因通常由具有组织特异性活性的多种增强子元件控制</li>
<li>增强子的活性部分或者完全重叠，这种现象被称作增强子冗余或者‘shadow enhancers’。冗余的增强子具有很强的转录活性控制一些关键的基因，而且其与癌症也有关联</li>
<li>增强子并不是单个独立的元件，而是形成一个复杂冗余的调控单位，为基因的表达提供了稳定精确的调控</li>
<li>总的来说，基因是由和自身具有亲和力和功能关系的调控元件所调控的，这些特性限制于他们在一维基因组的具体排列以及染色质的三维结构</li>
</ul>
<h2 id="The-Impact-Of-SVs-On-Gene-Regulation"><a href="#The-Impact-Of-SVs-On-Gene-Regulation" class="headerlink" title="The Impact Of SVs On Gene Regulation"></a>The Impact Of SVs On Gene Regulation</h2><ul>
<li>缺失和加倍除了会影响基因的剂量，它也有可能影响顺式调控元件的剂量和位置和这个位点的染色质的高级结构</li>
<li>同样，倒位和易位不仅会影响编码序列和转录，也会对三维结构造成影响</li>
<li>一些临床上的SVs影响基因组三维结构的例子如下</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/04/15/JPx7uD.png" alt="FIG2"></p>
<h2 id="Intra-TAD-SVs-Effects-On-Enhancer-Dosage"><a href="#Intra-TAD-SVs-Effects-On-Enhancer-Dosage" class="headerlink" title="Intra- TAD SVs: Effects On Enhancer Dosage"></a>Intra- TAD SVs: Effects On Enhancer Dosage</h2><ul>
<li>SVs可以通过影响顺式调控元件进而对距离几百kilobases的基因造成影响</li>
<li>TAD内部的SVs可能会影响增强子的剂量进而会导致内源目的基因的功能缺失或获得</li>
<li>当TAD内部调控元件缺失时，可能会导致基因功能的丧失，但由于增强子的冗余，所以单个的丢失往往不会造成影响</li>
<li>TAD内部调控元件的加倍可能导致内源靶基因的组织特异性过表达或错表达从而导致疾病</li>
<li>目前研究表明，不影响编码序列和TAD边界的倒位对长距离的基因调控没有影响</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/15/JPxojO.png" alt="FIG3" style="zoom: 80%;" />

<ul>
<li>a图：基因A、B分别控制头和四肢的发育，他们分别有各自的位于不同TAD的组织特异性顺式调控元件，TAD之间存在边界</li>
<li>b图：TAD内部的倒位（不影响编码基因或TAD的边界）对基因的远距离的调控没有大的影响，尽管目前尚无病例报道。</li>
<li>c图：调控B基因的增强子的缺失会导致B基因功能的丧失</li>
<li>d图：调控B基因的增强子的加倍会导致B基因的错误表达或过量表达</li>
</ul>
<h2 id="Inter-TAD-SVs-Effects-On-3D-Architecture"><a href="#Inter-TAD-SVs-Effects-On-3D-Architecture" class="headerlink" title="Inter- TAD SVs: Effects On 3D Architecture"></a>Inter- TAD SVs: Effects On 3D Architecture</h2><p>发生在TAD间的SVs同样会影响三维结构，并且具相关研究表明染色质域的改变是发育障碍和癌症的重要疾病机理，TAD间的SVs可能会导致以下三种TAD的变化</p>
<ul>
<li>TAD fusion</li>
<li>Neo-TADs</li>
<li>TAD shuffling</li>
</ul>
<p>下面是两幅图解</p>
<img data-src="https://s1.ax1x.com/2020/04/15/JPxbHH.png" alt="FIG4" style="zoom: 67%;" />

<ul>
<li>a图：基因A、B分别控制头和四肢的发育，他们分别有各自的位于不同TAD的组织特异性顺式调控元件，TAD之间存在边界</li>
<li>b图：边界上的元件缺失导致TAD的融合和增强子劫持，B基因的增强子会影响基因A的表达，同时也会导致四肢的发育异常</li>
<li>c图：边界和A基因的复制会导致neo- TAD的形成，在新的TAD种，加倍的调控B基因的增强子会调控A基因的表达，从而导致四肢发育异常</li>
<li>d图：A基因不加倍，即使形成新的TAD，也不会导致转录的变化</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/15/JPxHDe.png" alt="FIG5" style="zoom: 67%;" />

<ul>
<li>a图：基因A、B分别控制头和四肢的发育，他们分别有各自的位于不同TAD的组织特异性顺式调控元件，TAD之间存在边界</li>
<li>b图：TAD间的倒位，会导致来自B基因的增强子劫持，会导致A基因在四肢中的异常表达，同时也会导致B基因功能的丧失</li>
<li>c图：平衡易位通过将控制肢体发育的B基因的增强子替换为控制脊髓发育D基因的增强子来使基因组的TAD结构域重新排列，导致B基因的不表达，进而使得脊髓发育异常（D基因的变化图中没有展示）</li>
</ul>
<h2 id="Interpretation-Of-SVs-In-The-3D-Genome"><a href="#Interpretation-Of-SVs-In-The-3D-Genome" class="headerlink" title="Interpretation Of SVs In The 3D Genome"></a>Interpretation Of SVs In The 3D Genome</h2><p>考虑到SVs的多重影响，作者提出了一个系统的方法来解释SVs</p>
<img data-src="https://s1.ax1x.com/2020/04/15/JPxIgK.png" alt="FIG6" style="zoom: 80%;" />

<ul>
<li>第一步，判断基因SVs是调控元件突变还是基因的编码区突变</li>
<li>第二步，判断突变是否引起TAD边界的改变，进而对其进行分类</li>
<li>第三步，鉴定顺式调控元件和潜在的目的基因</li>
<li>第四步：功能验证</li>
</ul>
<h2 id="Conclusions-And-Future-Developments"><a href="#Conclusions-And-Future-Developments" class="headerlink" title="Conclusions And Future Developments"></a>Conclusions And Future Developments</h2><p>作者提出了现存的五个挑战</p>
<ul>
<li>SVs的比率计算和断点的精确定位还存在问题</li>
<li>相关的数据相对分散，需要一个跨学科的团队去研究人体的SVs</li>
<li>对于非编码区的调控序列的相关研究还十分有限，使预测表型变得十分困难</li>
<li>目前计算机预测工具还不够，需要深入包括动物模型在内的功能研究，来确定变异的致病性</li>
<li>目前，SVs主要是使用基因的剂量效应来解释，对于非编码区域的位置效应认识较浅，导致许多患者无法做出诊断</li>
</ul>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>棉属A基因组起源与进化</title>
    <url>/codeHub/2020/04/15/2020-06%E4%BB%A5%E5%89%8D/17%E6%A3%89%E5%B1%9EA%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BF%9B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="棉属A基因组的起源与进化"><a href="#棉属A基因组的起源与进化" class="headerlink" title="棉属A基因组的起源与进化"></a>棉属A基因组的起源与进化</h1><h3 id="Abstarct"><a href="#Abstarct" class="headerlink" title="Abstarct"></a>Abstarct</h3><p>在完成非洲棉 A1基因组、亚洲棉A2基因组、四倍体陆地棉（AD）1基因组组装后，表明A基因组可能起源于一个共同的A0基因组，同时在系统发生树上A1相比与A2更加接近于祖先A0基因组；同时异源四倍体的形成可能早于A1和A2基因组的分化。通过高斯密度分布函数估计表明，大约570万年前~61万年前出现的几次转座子爆发事件极大的促进了A基因组的扩张、物种的形成和进化。同时在基因区域大量的物种特异性的结构变异，改变了许多重要基因的表达，这些有可能是导致四倍体（AD）1中棉纤维品质得到改良。该研究不仅解决了长期以来颇具争议的概念：关于A基因组起源；同时为棉花的遗传改良提供了有价值的基因组资源。</p>
<a id="more"></a>

<p><img data-src="https://s1.ax1x.com/2020/04/15/JCoEi4.png" alt="棉属进化"></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>栽培棉花是世界上最重要的经济作物之一。其中异源四倍体陆地棉 G.hirsutum在世界棉花贸易中占据着主要地位，它是由旧世界的A基因组祖先和新世界D基因组组件杂交然后进过染色体加倍后形成。（AD）1的真正的A-genome 供体仍旧不确定，而世界上仅仅只存在两个二倍体A基因组分别是A1 非洲棉、A2亚洲棉。<strong>Stephens</strong> 第一个提出A2是异源四倍体中A基因组的供体，<strong>Gerstel</strong>则认为A1与At1关系更加接近。因此到现在为止对于四倍体中A基因组的起源仍旧具有争议。</p>
<p>在本研究中，作者基于PacBio测序技术、双末端测序技术、Hi-c技术，首次组装了A1基因组。并且重新组织了高质量的A2基因组、（AD）1基因组；揭示了A基因组的起源、转座子事件的爆发以及二倍体A基因组间的遗传差异；并且鉴定到大量的能够印象附近基因表达的结构变异，进一步的解释了不同棉种间的表型差异。</p>
<h3 id="2-1组装高质量的棉花基因组"><a href="#2-1组装高质量的棉花基因组" class="headerlink" title="2.1组装高质量的棉花基因组"></a>2.1组装高质量的棉花基因组</h3><p>作者使用PacBio对A1基因组进行测序，其中N50长度达到13Kb，测序深度达到x138倍；contigs的N50达到1915Kb，同时使用二代测序数据对组装进行校正。最后使用Hi-c数据将contigs分成了13组scaffolds，对应13条染色体。同样作者对A2、（AD）1进行了从头组装，相比与之前发表的数据质量得到了提升，减少了 contigs 之间的gaps。对基因信息进行注释后，其中A1、A2、（AD）1分别包含了 43,952, 43,278 and 74,350 蛋白编码基因。这些基因主要分布在染色体的两端，同时由于基因组复含转座子，这些TES regions主要位于染色体中间区域。</p>
<h3 id="2-2棉属间染色体的倒位和易位"><a href="#2-2棉属间染色体的倒位和易位" class="headerlink" title="2.2棉属间染色体的倒位和易位"></a>2.2棉属间染色体的倒位和易位</h3><p>通过比较A1和A2基因组发现，1号和2号染色体之间发生了相互易位，这种现象似乎是在两个物种形成之后才出现的并且在A2中被固定下来。将A1、A2分别与At1进行比较后发现一些染色体易位，并且有些只在At1中才出现，说明这些可能是在多倍化之后才出现的。大量的倒位现象同样也被检测到，其中有一些倒位只在某个基因组或者某两个基因组中才出现，例如只在A1中出现的倒位、只在A2和At1中才出现的倒位，说明这些倒位可能是在A1和A2分化之后才形成的。</p>
<h3 id="2-3四倍体棉花的起源"><a href="#2-3四倍体棉花的起源" class="headerlink" title="2.3四倍体棉花的起源"></a>2.3四倍体棉花的起源</h3><p>基于单拷贝基因建立分子树，表明At和A1、A2起源于同一个进化枝，表明它们之间具有一定的亲缘关系。通过计算发现A1、A2之间分化的时间大致在0.7个百万年前，四倍体的形成估计在1~1.6个百万年前。全基因组系统发生树分析，表明拓扑结构1与分子树结构一样，拓扑2表明At与A1是姐妹关系、拓扑3表明A2和At也是姐妹关系。结合Ka/Ks分析表明A1与A2之间的差异时最小的。进一步作者选择了几个具有代表性的材料，用它们的SNP数据构建了系统发生树。同比较发现，A1与At间SNP的数目更少一些，相比与A2与At。作者提出A1、A2可能都不是At基因组的祖先，于是提出假设A1、A2、At共同的祖先基因组A0与D5基因组杂交后形成四倍体物种。这种假说也就解释了A2、A1与D5之间杂交为什么不能成功，是由于它们之间遗传距离相差比较大。</p>
<h3 id="2-4对两个A基因组物种的研究"><a href="#2-4对两个A基因组物种的研究" class="headerlink" title="2.4对两个A基因组物种的研究"></a>2.4对两个A基因组物种的研究</h3><p>作者分别用了14份、67份具有代表性的A1、A2基因组材料。通过PCA主成分分析发现，这些材料分为2组分别对应了A1、A2。对材料进行聚类发现聚为了3类其中k=3和k=2之间存在一些差异，这可能是由于中国的A2是从印度引进，经过多年的地理隔离形成不独特的A2种族。通过分析也发现A1、和A2两个物种分别经历了独立的进化事件。</p>
<h3 id="2-5基因组的扩张和进化"><a href="#2-5基因组的扩张和进化" class="headerlink" title="2.5基因组的扩张和进化"></a>2.5基因组的扩张和进化</h3><p>在已经测序的D5和Dt1基因组中，它们基因组的大小与与可可之间相差将近两倍，而与木棉几乎差不多大。两个A基因组和At1亚基因组同样的进行了进一步的两倍扩张，并且与转座子的爆发事件有着很高的相关性。在D基因组中有50%左右LTR（ long terminal repeat  ），而在A基因组中则达到70%多，在棉属中的LTR反转座子经历了多次扩增。通过高斯密度分别函数估计LTR扩增事件的发生时间，其中最早的插入时间大约在~5.7个百万年前，那个时间点之前被认为是分化为A、D基因组的时间。紧接着是At1与Dt1，表明多倍化形成大约在2百万年前，</p>
<h3 id="2-6结构变异与纤维发育"><a href="#2-6结构变异与纤维发育" class="headerlink" title="2.6结构变异与纤维发育"></a>2.6结构变异与纤维发育</h3><p>大片段的插入或者删除，被报道驱动重要表型的变异。通过比较A基因组与At1基因组，发现大量的SVs。同时发现大量的结构变异在A1与A2中都存在，说明在物种A1、A2分化之前就已经形成了对应的SVs。将SVs与基因区域取交集，结合之前报道的与纤维性状有关的关联位点，找到一些SVs附近的基因，进行GO富集分析发现一些与纤维发育相关的关键基因和转录因子</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>Genome sequence of <em>Gossypium herbaceum</em> and genome updates of <em>Gossypium arboreum</em> and <em>Gossypium hirsutum</em> provide insights into cotton A-genome evolution</li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>ggplot-直方图</title>
    <url>/codeHub/2020/04/12/2020-06%E4%BB%A5%E5%89%8D/16ggplot-%E7%9B%B4%E6%96%B9%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="1-频数直方图"><a href="#1-频数直方图" class="headerlink" title="1.频数直方图"></a>1.频数直方图</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; head(pacBioData)</span><br><span class="line">               V1 V2</span><br><span class="line">1 Ghir_A01G000010  1</span><br><span class="line">2 Ghir_A01G000030  1</span><br><span class="line">3 Ghir_A01G000040  3</span><br><span class="line">4 Ghir_A01G000070  3</span><br><span class="line">5 Ghir_A01G000080  1</span><br><span class="line">6 Ghir_A01G000100  2</span><br></pre></td></tr></table></figure>

<p>如果你同时含有两个样本的频数信息，需要针对不同的样本画不同的的柱子；只需要在数据框中添加一个字段即可。例如我的数据中含有PacBio测序数据和参考基因组数据两个文件</p>
<ul>
<li>PacBio</li>
<li>regerence</li>
</ul>
<a id="more"></a>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pacBioData&lt;- read.table(<span class="string">"PacBio文件"</span>)</span><br><span class="line">referenceData &lt;- read.table(<span class="string">"reference文件"</span>)</span><br><span class="line"><span class="comment">##添加分类信息</span></span><br><span class="line">pacBioData$type &lt;- <span class="string">"PacBio"</span></span><br><span class="line">referenceData$type &lt;- <span class="string">"reference"</span></span><br><span class="line"><span class="comment">## 合并两个数据框</span></span><br><span class="line">mergeData &lt;- rbind(pacBioData, referenceData)</span><br></pre></td></tr></table></figure>

<h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><ul>
<li><code>x=V2</code>表示x轴数据使用V2字段进行映射</li>
<li><code>fill = type</code>针对type字段使用不同颜色进行填充</li>
<li><code>stat = &quot;count&quot;</code>统计x轴中每个值出现的次数，用作柱子的高度</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line">ggplot(data = mergeData, aes(x = V2, fill = type)) +</span><br><span class="line">  geom_bar(stat = <span class="string">"count"</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/04/12/GO7SiV.png" alt="堆积直方图"></p>
<h4 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h4><ul>
<li><code>position = &quot;dodge&quot;</code>将柱子调整为不堆积状态</li>
<li><code>width = 0.5</code>调整柱子宽度 </li>
</ul>
<p>这里由于x轴的坐标轴范围比较大，柱子缩放了看不清</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot(data = mergeData, aes(x = V2, fill = type)) +</span><br><span class="line">  geom_bar(stat = <span class="string">"count"</span>, position = <span class="string">"dodge"</span>, width = <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/04/12/GOH6nH.png" alt="不堆积"></p>
<h2 id="2-频率直方图"><a href="#2-频率直方图" class="headerlink" title="2.频率直方图"></a>2.频率直方图</h2><h3 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h3><p>使用R中的<code>table</code>函数和<code>prop.table</code>函数计算频率</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">PacBioFrequent &lt;- as.data.frame(prop.table(table(pacBioData$V2)))[<span class="number">1</span>:<span class="number">10</span>, ]</span><br><span class="line">referenceFrequent &lt;- as.data.frame(prop.table(table(referenceData$V2)))[<span class="number">1</span>:<span class="number">10</span>, ]</span><br><span class="line"><span class="comment">## 样本分类</span></span><br><span class="line">PacBioFrequent$type &lt;- <span class="string">"PacBio"</span></span><br><span class="line">referenceFrequent$type &lt;- <span class="string">"reference"</span></span><br><span class="line"><span class="comment">## 合并数据</span></span><br><span class="line">mergeData &lt;- rbind(PacBioFrequent, referenceFrequent)</span><br></pre></td></tr></table></figure>

<p>处理后的数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Var1       Freq   type</span><br><span class="line"><span class="number">1</span>    <span class="number">1</span> <span class="number">0.28121310</span> PacBio</span><br><span class="line"><span class="number">2</span>    <span class="number">2</span> <span class="number">0.21962588</span> PacBio</span><br><span class="line"><span class="number">3</span>    <span class="number">3</span> <span class="number">0.15747934</span> PacBio</span><br><span class="line"><span class="number">4</span>    <span class="number">4</span> <span class="number">0.10686098</span> PacBio</span><br><span class="line"><span class="number">5</span>    <span class="number">5</span> <span class="number">0.07342614</span> PacBio</span><br></pre></td></tr></table></figure>

<h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p>参数和之前的都是一样的</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot(data = mergeData, aes(x =Var1, y=Freq,fill = type)) +</span><br><span class="line">  geom_bar(stat = <span class="string">"identity"</span>, position = <span class="string">"dodge"</span>, width = <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/04/12/GOqkLQ.png" alt="频率直方图"></p>
<h2 id="3-美化图片"><a href="#3-美化图片" class="headerlink" title="3.美化图片"></a>3.美化图片</h2><h3 id="不涉及数据层的美化"><a href="#不涉及数据层的美化" class="headerlink" title="不涉及数据层的美化"></a>不涉及数据层的美化</h3><ul>
<li>图片背景色</li>
<li>图片网格</li>
<li>坐标轴刻度线</li>
<li>坐标轴刻度文字</li>
<li>坐标轴label文字</li>
<li>图例标题</li>
<li>图例位置</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p=ggplot(data = mergeData, aes(x =Var1, y=Freq,fill = type)) +</span><br><span class="line">  geom_bar(stat = <span class="string">"identity"</span>, position = <span class="string">"dodge"</span>, width = <span class="number">0.5</span>)  </span><br><span class="line"></span><br><span class="line">p+theme_bw() +</span><br><span class="line">  theme(</span><br><span class="line">    panel.grid = element_blank(), <span class="comment">#图片网格线</span></span><br><span class="line">    panel.background = element_blank(), <span class="comment">#图片背景色为空</span></span><br><span class="line">    axis.line = element_line(size = <span class="number">0.5</span>, color = <span class="string">"black"</span>),<span class="comment">#坐标轴线条</span></span><br><span class="line">    axis.text.x = element_text(size = <span class="string">"15"</span>), <span class="comment">#x坐标轴刻度文字</span></span><br><span class="line">    axis.text.y = element_text(size = <span class="string">"10"</span>), <span class="comment">#y坐标轴刻度文字</span></span><br><span class="line">    axis.title.y = element_text(size = <span class="string">"15"</span>), <span class="comment">#x坐标轴label文字</span></span><br><span class="line">    legend.title = element_blank(), <span class="comment">#图例标题</span></span><br><span class="line">    legend.position = c(<span class="number">0.8</span>, <span class="number">0.8</span>), <span class="comment">#图例位置</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/04/12/GOLE6O.png" alt="美化1"></p>
<h3 id="自定义填充色"><a href="#自定义填充色" class="headerlink" title="自定义填充色"></a>自定义填充色</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p+  scale_fill_manual(values = c(</span><br><span class="line">    <span class="string">"#f6e58d"</span>, <span class="string">"#ffbe76"</span>, <span class="string">"#686de0"</span>, <span class="string">"#4834d4"</span></span><br><span class="line">  ))</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/04/12/GOLYng.png" alt="美化2"></p>
<h3 id="调整柱子离坐标轴位置"><a href="#调整柱子离坐标轴位置" class="headerlink" title="调整柱子离坐标轴位置"></a>调整柱子离坐标轴位置</h3><p>这里我将柱子与x轴进行贴近，其他的可以类似</p>
<ul>
<li><code>expand</code>贴近坐标轴的位置</li>
<li><code>limits</code>设置显示的范围</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p+  scale_y_continuous(expand = c(<span class="number">0</span>, <span class="number">0</span>), limits = c(<span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/04/12/GOOFEj.png" alt="美化3"></p>
<h3 id="添加自定义文字"><a href="#添加自定义文字" class="headerlink" title="添加自定义文字"></a>添加自定义文字</h3><p>通过使用<code>geom_text</code>函数，并且选择不继承原有的图片数据</p>
<ul>
<li><code>data = labelData</code>要显示的注释信息</li>
<li><code>mapping</code>指定显示的位置和字段</li>
<li><code>inherit.aes</code>是否继承图形数据，如果是使用自定义数据，这里一定要<code>FALSE</code></li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将要展示的注释文字</span></span><br><span class="line">labelData &lt;- data.frame(text1 = <span class="string">"3.39"</span>, text2 = <span class="string">"/"</span>, text3 = <span class="string">"2.01"</span>)</span><br><span class="line">p+geom_text(</span><br><span class="line">    data = labelData,</span><br><span class="line">    mapping = aes(x = <span class="number">8</span>, y = <span class="number">0.5</span>, label = text1),</span><br><span class="line">    inherit.aes = <span class="literal">FALSE</span>,</span><br><span class="line">    show.legend = <span class="literal">NA</span>,</span><br><span class="line">    color = <span class="string">"#ffbe76"</span></span><br><span class="line">  ) +</span><br><span class="line">  geom_text(</span><br><span class="line">    data = labelData,</span><br><span class="line">    mapping = aes(x = <span class="number">8.5</span>, y = <span class="number">0.5</span>, label = text2),</span><br><span class="line">    inherit.aes = <span class="literal">FALSE</span>,</span><br><span class="line">    show.legend = <span class="literal">NA</span>,</span><br><span class="line">    color = <span class="string">"black"</span></span><br><span class="line">  ) +</span><br><span class="line">  geom_text(</span><br><span class="line">    data = labelData,</span><br><span class="line">    mapping = aes(x = <span class="number">9</span>, y = <span class="number">0.5</span>, label = text3),</span><br><span class="line">    inherit.aes = <span class="literal">FALSE</span>,</span><br><span class="line">    show.legend = <span class="literal">NA</span>,</span><br><span class="line">    color = <span class="string">"#4834d4"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/04/12/GOzsjx.png" alt="美化4"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>CDSN<a href="https://blog.csdn.net/Bone_ACE/article/details/47427453" target="_blank" rel="noopener">博客</a></li>
</ol>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title>三维基因组之TAD的形成机制以及其特征</title>
    <url>/codeHub/2020/04/08/2020-06%E4%BB%A5%E5%89%8D/15%E4%B8%89%E7%BB%B4%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B9%8BTAD%E7%9A%84%E5%BD%A2%E6%88%90%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<ul>
<li><h1 id="三维基因组之TAD的形成机制以及其特征"><a href="#三维基因组之TAD的形成机制以及其特征" class="headerlink" title="三维基因组之TAD的形成机制以及其特征"></a>三维基因组之TAD的形成机制以及其特征</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>了解细胞核内染色体折叠的机制对于确定基因组结构和功能之间的关系至关重要。最近应用的“染色体构象捕获”技术揭示了许多物种的基因组被组织成频繁交互的染色质区域，称为TADs。这种染色体区域化已成为高阶基因组结构和功能的重要特征。虽然TADs现在已经被广泛的研究于各种生物体中，但它们在大小、结构和形成过程中所涉及的蛋白质方面似乎有特定的特征。在此，我们描述了这些跨物种染色质区域的主要特征，并讨论了染色质结构、基因组活性和表观基因组之间的关系，着重讲述了TAD形成的机制原理。还涉及到了TADs在基因组进化中的潜在影响。</p>
<a id="more"></a>

<h2 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h2><p>A图展示了细胞核内的染色体折叠情况：染色质丝 &gt; TAD &gt; 区室 &gt; 染色体疆域</p>
<ul>
<li>染色质丝：染色体折叠的最基本的层是DNA组蛋白结合水平，形成核小体进而形成染色质丝</li>
<li>TAD：由于基因调控，染色体以不同的核小体密度进行包装，并在submegabase尺度折叠成内部相互作用的高级结构</li>
<li>区室：在染色体尺度，染色质被隔离成活跃的“A”和被抑制的的“B”区室，说明了具有相同表观遗传特征的染色质区域会更多的进行交互</li>
<li>染色体疆域：每个染色体在细胞核内占据自己位置，形成染色体疆域</li>
</ul>
<p>B图展示了不同染色体水平的Hi-C热图，反映了不同层次的高阶染色体折叠，两个坐标轴上都表示基因组坐标，区域间的交互频率用颜色深浅表示</p>
<ul>
<li>在submegabase尺度，TAD沿着正方形的对角线分布，相互作用十分频繁，同时TAD存在边界而且TAD被 contact depletion zones 分割开</li>
<li>在染色体尺度上，染色质的远距离的交互形成图中具有典型格子图案的相互排斥的A、B区室</li>
<li>与染色体间的交互相比，染色体内的交互频率会更高，这与染色体疆域的形成是相互一致的</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/03/31/GlV5As.png" alt="Fig. 1" style="zoom:67%;" />

<h2 id="TADs-Across-Species"><a href="#TADs-Across-Species" class="headerlink" title="TADs Across Species"></a>TADs Across Species</h2><p>在这个板块，作者主要讲述了TAD在不同的物种中的特征以及形成机制</p>
<h3 id="TADs-in-mammals"><a href="#TADs-in-mammals" class="headerlink" title="TADs in mammals"></a>TADs in mammals</h3><p>在哺乳动物中，TAD的特征十分的保守，特征主要有以下几条</p>
<ul>
<li>大多数哺乳动物TAD边界的一个显著特征是存在 CCCTC-binding factor (CTCF)  以及structural maintenance of chromosomes (SMC) cohesin complex， loop-anchored TADs 总是出现CTCF之间，并且位于一个收敛的方向，并且改变单个CTCF的方向会使TAD边界的位置消失或移动</li>
<li>针对这些TADs的形成，提出了一种称为“loop extrusion model“的模型，这个模型指出loop-anchored TADs 的形成与CTCF/cohesin有关，CTCF/cohesin来自于黏连蛋白复合物的出现和移除之间的平衡，这是一个动态的过程。另一个SMC蛋白复合物富集在TAD边界。</li>
<li>在缺乏cohesin或TADs通过自发的染色质接触形成的情况下，可能存在其他的TAD形成机制</li>
<li>CTCF与增强子-启动子的交互有关；transcription-associated supercoiling 和 type II DNA topoisomerase都与染色体的拓扑结构有关</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/03/31/GlVohq.png" alt="mammals" style="zoom:80%;" />

<ul>
<li>图中黑色的圆圈表明复合物再TAD边界的停留时间增加</li>
</ul>
<h3 id="TADs-in-Drosophila"><a href="#TADs-in-Drosophila" class="headerlink" title="TADs in Drosophila"></a>TADs in Drosophila</h3><ul>
<li><p>果蝇TADs表现出与表观遗传有很好的相关性，并根据其具体的表观遗传特征分为四个主要类别(active TADs、PcG TADs、 null or void TADs、 heterochromatin TADs}</p>
</li>
<li><p>RNAPII和转录过程与果蝇TAD的形成有关，但并不完全决定其形成</p>
</li>
<li><p>Zelda（一种转录因子）在TAD边界处起到绝缘子的作用，它可能与TAD边界处的其他调控因子合作，如 BEAF-32 and GAGA factor ，但在脊椎动物中没有发现其同系物，这也许是果蝇特有的机制</p>
</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/03/31/GlVfBQ.png" alt="Drosophila"  />

<h3 id="TADs-in-Caenorhabditis-elegans"><a href="#TADs-in-Caenorhabditis-elegans" class="headerlink" title="TADs in Caenorhabditis elegans"></a>TADs in Caenorhabditis elegans</h3><ul>
<li>X染色体上存在约1Mb大小的self-interacting domains ，但常染色体没有这个明显特征</li>
<li>雌雄同体的X染色体被 dosage compensation complex (DCC) 特异性结合，（DCC是一种凝缩蛋白复合物）</li>
</ul>
<h3 id="TADs-in-plants"><a href="#TADs-in-plants" class="headerlink" title="TADs in plants"></a>TADs in plants</h3><ul>
<li>拟南芥中没有明显的的TAD，但拟南芥基因组包含了与H3K27me3或H3K9me2等受抑制的染色质标记的相互作用的紧密区域；在水稻和棉花中可以鉴定出明显的TAD</li>
<li>玉米、番茄、高粱、粟、水稻中发现了一种类似于果蝇的 TAD-like domains ，也可以根据它的表观遗传特征分成四种染色质类型</li>
<li>在水稻TAD边界上发现了DNA GC-rich motifs，类似于那些属于TCP家族的被植物特异性转录因子结合的序列</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/03/31/GlVh7j.png" alt=" plants"></p>
<h3 id="Self-interacting-domains-in-yeast"><a href="#Self-interacting-domains-in-yeast" class="headerlink" title="Self-interacting domains in yeast"></a>Self-interacting domains in yeast</h3><ul>
<li>在裂殖酵母中发现了叫一种做”globules“ 的 Self-interacting domains，</li>
<li>最近，用了一个类似于Hi-C的Micro-C技术揭示了 small self-interacting domains的存在</li>
</ul>
<h3 id="TAD-like-domains-in-bacteria"><a href="#TAD-like-domains-in-bacteria" class="headerlink" title="TAD-like domains in bacteria"></a>TAD-like domains in bacteria</h3><ul>
<li>新月柄杆菌中存在分立的chromosomal interaction domains (CIDs) ，类似于真核生物的TAD</li>
<li>研究表明，富含plectonemes的区域形成CIDs，而边界是由高表达基因和无plectonemes区域的形成而形成的。</li>
<li>研究发现SMC环能够围绕DNA和染色体臂，形成依赖于复合物中腺苷三磷酸酶(ATPase)活性的 processive loops </li>
</ul>
<p><img data-src="https://s1.ax1x.com/2020/03/31/GlVWng.png" alt="bacteria "></p>
<h3 id="General-and-specific-features-of-TADs"><a href="#General-and-specific-features-of-TADs" class="headerlink" title="General and specific features of TADs"></a>General and specific features of TADs</h3><ul>
<li>虽然TADs或相互作用域作为基因组组织的一个基本组成部分出现，但它们的特征并不是普遍保守的。 在不同的物种中，交互域的显著程度、边界的清晰度都存在差异。此外，TAD形成的分子机制可能是多种多样的，这与不同类型TADs的存在是一致的。因此，尚不清楚TADs是高阶基因组的普遍单位，还是在进化过程中由于作用于染色质的不同分子引擎的相互作用而反复出现。然而，在不同物种都保守的一个显著特征是基因活性和基因组折叠之间的关系。边界的染色质活性相对较高</li>
<li>CTCF在脊椎动物的特性较为保守，然而，在其他生物如植物、酵母和秀丽隐杆线虫中没有发现CTCF</li>
<li>然而，绝缘体蛋白也可能在其他物种转录区域的TAD边界的定义中发挥类似的作用，如果蝇中的BEAF-32和CP190，植物中的TCP蛋白</li>
</ul>
<h2 id="Physical-Nature-Of-TADs"><a href="#Physical-Nature-Of-TADs" class="headerlink" title="Physical Nature Of TADs"></a>Physical Nature Of TADs</h2><h3 id="TADs-and-compartments"><a href="#TADs-and-compartments" class="headerlink" title="TADs and compartments"></a>TADs and compartments</h3><p>下图展示了在果蝇和哺乳动物中的染色体折叠情况</p>
<p>A图（果蝇）</p>
<ul>
<li>①TAD和区室都与其表观遗传区域相对应，其优先发生自身折叠并和同类型的TAD发生远程顺式交互</li>
<li>②大的受抑制的染色质区域形成显著的TAD</li>
<li>③这些大的受抑制的区域被这些转录基因分隔开，这些转录基因形成小的active TAD 或者 inter-TAD–like regions </li>
</ul>
<p>B图（哺乳动物）</p>
<ul>
<li>①在哺乳动物中，为TAD的形成提出了一种“loop extrusion model”，里边包含了一种 loop extrusion factor，被Nipbl和Wapl装载和释放，黏连蛋白挤压染色质使其分离、与另一个黏连蛋白发生碰撞、通过CTCF蛋白反向或者其他边界上的原件来到达TAD的边界。这些loop在TAD的边界之间的交互是被看作是一个strong peak</li>
<li>②在活跃的转录起始位点发现了绝缘子的存在</li>
<li>③最新研究发现，loop挤压过程会与本身活跃与不活跃的染色质之间的隔离相互竞争</li>
</ul>
<img data-src="https://s1.ax1x.com/2020/04/08/GWHh8K.png" alt="compartment" style="zoom:67%;" />

<h3 id="TAD-structure-and-dynamics"><a href="#TAD-structure-and-dynamics" class="headerlink" title="TAD structure and dynamics"></a>TAD structure and dynamics</h3><ul>
<li>显微镜技术、聚合物模型和Single-cell Hi-C (scHi-C) 都表明哺乳动物的TADs可以呈现各种各样的构象，从浓缩的球状物体到更延伸的结构</li>
<li>TADs的边界精度和绝缘程度在不同的细胞类型和不同的细胞周期期都不同</li>
<li>“stirring model” 表明增强子和启动子的相互作用是动态的。转录本身可能稳定近端染色质构象，减少增强子和启动子之间的距离</li>
<li>因此，TADs可能建立一个局部的染色体环境，调控信号会调节远端的增强子和启动子之间的动态相互作用的频率</li>
</ul>
<h2 id="TADs-And-Genome-Evolution"><a href="#TADs-And-Genome-Evolution" class="headerlink" title="TADs And Genome Evolution"></a>TADs And Genome Evolution</h2><ul>
<li>TAD可能作为缓冲因子，允许突变发挥局部影响，而不影响周围的的其他TAD位点</li>
<li>TAD在大小上表现出灵活可变性，可以允许DNA序列的增加和缺失，这有利于新的调控效应的出现</li>
<li>这些三维结构有利于维持内部各种元件的选择压力，进而有利于控制某些特定的位点</li>
<li>CTCF binding 和染色质的结构趋于共同进化</li>
<li>在斑马鱼和其他脊椎动物中，位于相同TAD的基因对比临近TAD的基因对在同源性上更近一些，</li>
<li>TAD的边界存在局部开放的染色质结构，边界一旦被扰动，会导致异常的交互和基因的错误表达，并通常会带来有害的影响，这为TAD在进化中保持完整性提供了基础</li>
<li>基因组的复制有时候会导致新的TAD出现，这些新的TAD有时候可以解释病理，但有时候它没有表型</li>
<li>在脊椎动物中，一个新的TAD的出现可能导致新的顺势调控元件的插入</li>
</ul>
<h2 id="Conclusion-And-Perspective"><a href="#Conclusion-And-Perspective" class="headerlink" title="Conclusion And Perspective"></a>Conclusion And Perspective</h2><p>染色体的折叠情况是一个跨物种保守的特征，为什么CTCF在不同物种之间的出现与消失仍然是一个有待解决的问题，在存在CTCF的物种中，CTCF可以用来定义TAD的边界，但是其他物种不存在CTCF表明TAD是一个可以脱离CTCF而存在的一个更基本的染色质结构，并且在这些物种中转录基因的分布和绝缘子的出现和分布为交互模型的构建提供了框架。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Principles of genome folding into topologically associating domains</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>Blast+网页</title>
    <url>/codeHub/2020/04/08/2020-06%E4%BB%A5%E5%89%8D/14Blast-%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="Blast-网页实现"><a href="#Blast-网页实现" class="headerlink" title="Blast+ 网页实现"></a>Blast+ 网页实现</h1><img data-src="http://image.sciencenet.cn/album/201311/28/073831c6zann9dznas78pw.jpg" alt=" Stephen Altschul, PhD " style="zoom:80%;  float:left; margin-right:20px" />

<span class="label success">BLAST</span>( Basic Local Alignment Search Tool ),基于局部比对算法的搜索工具，实现比较两段核酸序列或者蛋白序列之间的同源性的功能，快速找到序列之间的同源区域，并且进行打分来区分同源性的高低。BLAST的作者 斯蒂芬·弗兰克·阿尔丘尔 **Stephen Frank  Altschul**，是一位著名数学家，同时本科期间对生物学有着浓厚的兴趣。因此他阅读了一些关于DNA的书籍其中包括詹姆斯.沃森撰写的《The Double Helix 》；同时选修了《进化生物学》；在博士期间为X射线晶体学项目写过计算机代码。1994年至今在美国国家生物信息中心NCBI从事计算生物学的工作。

<p>​    网页版BLAST相比与本地BLAST有着一些优势，比如不用下载软件只需要在现代一款浏览器上便可以实现。</p>
<a id="more"></a>

<h3 id="1-前端发送表单"><a href="#1-前端发送表单" class="headerlink" title="1.前端发送表单"></a>1.前端发送表单</h3><p>表单数据包括</p>
<ul>
<li>序列信息</li>
<li>blast database</li>
<li>其他可选的参数</li>
<li>选择blastn或者blastp</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">formInline: &#123;</span><br><span class="line">  sequence: <span class="string">''</span>,</span><br><span class="line">  database: <span class="string">''</span>,</span><br><span class="line">  evalue: <span class="string">'-evalue 1.0e-5 -num_alignments 10 -max_hsps 10'</span>,</span><br><span class="line">  blastType: <span class="string">''</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="1-1提交表单数据前进行数据校验"><a href="#1-1提交表单数据前进行数据校验" class="headerlink" title="1.1提交表单数据前进行数据校验"></a>1.1提交表单数据前进行数据校验</h4><ul>
<li>表单校验不成功，不能够提交</li>
<li>校验成功后使用<code>FormData</code>封装表单数据</li>
<li>打开遮罩层，阻止多次提交</li>
<li>使用<code>axios</code>获取响应数据后，关闭遮罩层</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onSubmit () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$refs.blastForm.validate(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">      <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>.formInline) &#123;</span><br><span class="line">        formData.append(key, <span class="keyword">this</span>.formInline[key])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.showProcess = <span class="literal">true</span></span><br><span class="line">      request.post(<span class="string">'/test'</span>, formData).then(</span><br><span class="line">        (reponse) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.reponseData = reponse.data</span><br><span class="line">          <span class="keyword">this</span>.showProcess = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-响应数据渲染"><a href="#2-响应数据渲染" class="headerlink" title="2.响应数据渲染"></a>2.响应数据渲染</h3><p>封装一个<code>show.vue</code>子组件，子组件中使用<code>props</code>获取父组件传递的响应数据，子组件中<code>reponseData</code>初始化值为空</p>
<blockquote>
<p>在渲染序列比对情况时候，遇到对不齐的情况；主要是由于没有使用等宽字体</p>
</blockquote>
<p><img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200408152513.png" alt="字体对齐"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  reponseData: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [&#123;</span><br><span class="line">        query: <span class="string">'CYP78A7'</span>,</span><br><span class="line">        queryLength: <span class="string">'559'</span>,</span><br><span class="line">        alignments: []</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用计算属性，将父组件的响应数据转换成需要渲染的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">   <span class="function"><span class="title">ValidateReponse</span></span> () &#123;</span><br><span class="line">     var newDataArray = []</span><br><span class="line">     this.reponseData.forEach((item) =&gt; &#123;</span><br><span class="line">       var queryName = item.query</span><br><span class="line">       var queryLength = item.queryLength</span><br><span class="line">       var summaryTable = []</span><br><span class="line">       var singleTable = []</span><br><span class="line">       var AlignmentIf = <span class="string">''</span></span><br><span class="line">       <span class="keyword">if</span> (item.alignments.length &gt; 0) &#123;</span><br><span class="line">         AlignmentIf = <span class="literal">true</span></span><br><span class="line">         item.alignments.forEach((subject, index) =&gt; &#123;</span><br><span class="line">           summaryTable.push(</span><br><span class="line">             &#123;</span><br><span class="line">               id: index + 1,</span><br><span class="line">               subjectName: subject.subjectName,</span><br><span class="line">               score: subject.score,</span><br><span class="line">               evalue: subject.eValue,</span><br><span class="line">               length: subject.subjectLength,</span><br><span class="line">               identities: subject.identities,</span><br><span class="line">               pairSequence: subject.pairSequence</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">           )</span><br><span class="line">           singleTable.push([&#123;</span><br><span class="line">             id: index + 1,</span><br><span class="line">             subjectName: subject.subjectName,</span><br><span class="line">             score: subject.score,</span><br><span class="line">             evalue: subject.eValue,</span><br><span class="line">             length: subject.subjectLength,</span><br><span class="line">             identities: subject.identities,</span><br><span class="line">             pairSequence: subject.pairSequence</span><br><span class="line">           &#125;])</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         AlignmentIf = <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">       newDataArray.push(&#123;</span><br><span class="line">         queryName,</span><br><span class="line">         queryLength,</span><br><span class="line">         summaryTable,</span><br><span class="line">         AlignmentIf,</span><br><span class="line">         singleTable</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="built_in">return</span> newDataArray</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-后端node运行blast"><a href="#3-后端node运行blast" class="headerlink" title="3.后端node运行blast+"></a>3.后端node运行blast+</h3><p>使用node运行系统命令，来执行blast+</p>
<h4 id="3-1创建两个临时文件，用于存储序列信息和blast运行结果"><a href="#3-1创建两个临时文件，用于存储序列信息和blast运行结果" class="headerlink" title="3.1创建两个临时文件，用于存储序列信息和blast运行结果"></a>3.1创建两个临时文件，用于存储序列信息和blast运行结果</h4><ul>
<li>使用<code>tmp</code>模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">require</span>(<span class="string">'tmp'</span>)</span><br><span class="line"><span class="keyword">var</span> queryFile = tmp.fileSync()</span><br><span class="line"><span class="keyword">var</span> BlastOutFile = tmp.fileSync()</span><br><span class="line"><span class="comment">//程序结束后，可以选择删除临时文件；或系统自动处理</span></span><br><span class="line">BlastOutFile.removeCallback()</span><br><span class="line">queryFile.removeCallback()</span><br></pre></td></tr></table></figure>

<h4 id="3-2运行系统命令"><a href="#3-2运行系统命令" class="headerlink" title="3.2运行系统命令"></a>3.2运行系统命令</h4><p>使用<code>child_process</code>模块运行子进程，调用<code>execFile</code>函数执行系统脚本</p>
<p><code>execFile</code>函数参数:</p>
<ul>
<li>系统脚本所在绝对路径</li>
<li>传递参数的数组</li>
<li>回调函数，判断脚本是否执行成功</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callfile = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line">  callfile.execFile(</span><br><span class="line">    <span class="string">'使用系统脚本的绝对路径'</span>,</span><br><span class="line">    [</span><br><span class="line">      queryFile.name,</span><br><span class="line">      BlastOutFile.name,</span><br><span class="line">      req.body.blastType,</span><br><span class="line">      req.body.database,</span><br><span class="line">      req.body.evalue</span><br><span class="line">    ],  (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">        rep.send(<span class="string">'error'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//读取blast结果</span></span><br><span class="line">      BlastText = fs.readFileSync(BlastOutFile.name, <span class="string">'utf-8'</span>)</span><br><span class="line">      <span class="comment">//解析blast outfmt 0 格式文件</span></span><br><span class="line">      BlastJson = parseBlastText(BlastText)</span><br><span class="line">      BlastOutFile.removeCallback()</span><br><span class="line">      queryFile.removeCallback()</span><br><span class="line">      rep.send(BlastJson)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-3解析Blast-outfmt-0格式文件"><a href="#3-3解析Blast-outfmt-0格式文件" class="headerlink" title="3.3解析Blast+ outfmt 0格式文件"></a>3.3解析Blast+ <code>outfmt 0</code>格式文件</h4><ul>
<li>利用关键字<code>Query=</code>获取查询序列所在行号</li>
<li>关键字<code>&gt;</code>获取匹配序列所在行号</li>
<li>匹配序列之间，间隔行数是固定的</li>
</ul>
<p><a href="https://github.com/BiocottonHub/zpliuCode/blob/b9f1c6b4b3479e0104a32d2470b02a648e0275de/BioJs/parseBlastText.js" target="_blank" rel="noopener">脚本地址</a></p>
<h3 id="4-演示地址"><a href="#4-演示地址" class="headerlink" title="4.演示地址"></a>4.演示地址</h3><p> <a href="http://cotton.hzau.edu.cn/web/test#/blast/query" target="_blank" rel="noopener">http://cotton.hzau.edu.cn/web/test#/blast/query</a> </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>node<a href="http://nodejs.cn/api/child_process.html" target="_blank" rel="noopener">执行系统命令</a></li>
<li>tmp<a href="https://www.npmjs.com/package/tmp" target="_blank" rel="noopener">模块创建临时文件</a></li>
<li>转换Blast<a href="https://github.com/sing-group/biojs-vis-blasterjs/blob/ed8cfd8bb8e9a1b88251a6006cf308c30758dcab/lib/index.js" target="_blank" rel="noopener">输出文件</a></li>
<li><a href="https://biojs.net/#/" target="_blank" rel="noopener">js生物仓库</a></li>
</ol>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>fasta文件校验</title>
    <url>/codeHub/2020/04/06/2020-06%E4%BB%A5%E5%89%8D/13fasta%E6%96%87%E4%BB%B6%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="fasta文件校验"><a href="#fasta文件校验" class="headerlink" title="fasta文件校验"></a>fasta文件校验</h1><p>最近在利用javascripte构建网页blast时候，涉及到客户端文件和表单的提交。因此结合vue与element-ui框架封装了一个上传并对fasta文件进行校验的插件</p>
<a id="more"></a>

<h3 id="1-获取文件对象"><a href="#1-获取文件对象" class="headerlink" title="1.获取文件对象"></a>1.获取文件对象</h3><ul>
<li>使用拖拽事件，移动文件</li>
<li><code>dataTransfer.files</code>获取拖拽文件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.fileData = e.dataTransfer.files[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2-读取文件数据"><a href="#2-读取文件数据" class="headerlink" title="2.读取文件数据"></a>2.读取文件数据</h3><ul>
<li>使用<code>FileReader</code>对象读取文件对象内容</li>
<li>作为字符窜进行读取，触发<code>load</code>事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">reader.readAsText(fileData, <span class="string">'utf-8'</span>) <span class="comment">// 触发load事件</span></span><br><span class="line"> reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  reader.result <span class="comment">//文件内容</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-匹配核酸序列与蛋白序列"><a href="#3-匹配核酸序列与蛋白序列" class="headerlink" title="3.匹配核酸序列与蛋白序列"></a>3.匹配核酸序列与蛋白序列</h3><p>创建正则表达式对核酸序列与蛋白序列进行匹配</p>
<ul>
<li>核苷酸序列，除了<code>A T C G N</code>几种碱基外还有换行符<code>\n</code></li>
<li><code>i</code>忽略大小写，<code>m</code>多行匹配</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Basepattern = <span class="regexp">/[^ATCGN\n\r]/im</span> <span class="comment">// 匹配除这些字符之外的字符</span></span><br></pre></td></tr></table></figure>

<ul>
<li>蛋白序列就包含20中氨基酸缩写和换行符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ProteinPattern = <span class="regexp">/[^GAVLIPFYWSTCMNQDEKRH\\*\r\n]/im</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提取核苷序列与蛋白序列,<code>slice</code>忽略第一个空白字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sequenceArray = reader.result.split(<span class="regexp">/&gt;[^\n]+\n/</span>).slice(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历所有序列</li>
</ul>
<blockquote>
<p>只有序列中有一条满足正则表达式，则表示错误的序列格式；并返回true；</p>
<p>而蛋白序列的校验时还多了一条规则，因为蛋白序列都是以甲硫氨酸开头，并且核酸的基因缩写与氨基酸缩写重叠了不能够区分蛋白序列与氨基酸序列</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">BaseFlag = sequenceArray.some(<span class="function">(<span class="params">sequence</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Basepattern.test(sequence)</span><br><span class="line">&#125;)</span><br><span class="line">ProteinFlag = sequenceArray.some(<span class="function">(<span class="params">sequence</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ProteinPattern.test(sequence) || <span class="regexp">/^[^M]/i</span>.test(sequence)</span><br><span class="line">  <span class="comment">// 核苷酸序列碱基缩写被氨基酸序列覆盖，所有必须以M氨基酸开头才是蛋白序列</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-回调函数获取校验结果"><a href="#4-回调函数获取校验结果" class="headerlink" title="4.回调函数获取校验结果"></a>4.回调函数获取校验结果</h3><p>因为onload函数是异步的，所以有可能出现文件还没校验完，客户端状态就已经发生改变；所以使用回调函数获取校验结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">validateFasta(<span class="keyword">this</span>.fileData, (BaseFlag, ProteinFlag) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (BaseFlag &amp;&amp; ProteinFlag) &#123;</span><br><span class="line">            <span class="keyword">this</span>.showModal = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">this</span>.Modalmessage = <span class="string">'error fasta file'</span></span><br><span class="line">            <span class="keyword">this</span>.ModalFontColor = &#123; <span class="attr">color</span>: <span class="string">'#d63031'</span> &#125;</span><br><span class="line">            <span class="keyword">this</span>.Modalicon = <span class="string">'el-icon-check'</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.showModal = <span class="literal">false</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!BaseFlag) &#123;</span><br><span class="line">            <span class="keyword">this</span>.showModal = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">this</span>.Modalmessage = <span class="string">'Nucleic acid sequence file'</span></span><br><span class="line">            <span class="keyword">this</span>.ModalFontColor = &#123; <span class="attr">color</span>: <span class="string">'#4cd137'</span> &#125;</span><br><span class="line">            <span class="keyword">this</span>.Modalicon = <span class="string">'el-icon-close'</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.showModal = <span class="literal">false</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ProteinFlag) &#123;</span><br><span class="line">            <span class="keyword">this</span>.showModal = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">this</span>.Modalmessage = <span class="string">'Protein sequence file'</span></span><br><span class="line">            <span class="keyword">this</span>.ModalFontColor = &#123; <span class="attr">color</span>: <span class="string">'#4cd137'</span> &#125;</span><br><span class="line">            <span class="keyword">this</span>.Modalicon = <span class="string">'el-icon-close'</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.showModal = <span class="literal">false</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-校验完成后将数据提交后台"><a href="#5-校验完成后将数据提交后台" class="headerlink" title="5.校验完成后将数据提交后台"></a>5.校验完成后将数据提交后台</h3><p>客户端使用<code>FormData</code>对象可以同时提交文件与表单，在后台借助<code>connect-multiparty</code>插件获取上传的文件</p>
<ul>
<li>将文件数据与表单数据合并</li>
<li>表单数据需要使用for循环进行包装</li>
</ul>
<p>如果需要获取FormData已经添加的内容，需要使用get方法；因为添加进去的内容已经变成私有变量无法直接访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">  formData.append(<span class="string">'fastafile'</span>, <span class="keyword">this</span>.$refs.dropfile.fileData)</span><br><span class="line"><span class="comment">//包装表单数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>.formInline) &#123;</span><br><span class="line">        formData.append(key, <span class="keyword">this</span>.formInline[key])</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>提交后台</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.post(<span class="string">'/test'</span>, formData).then(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>测试过程遇到的跨域问题，使用本地代理服务器与后端API进行交互；因为使用浏览器与后端API交互时，浏览器处于安全原因会阻止跨域请求。</p>
<p>配置<code>vue.config.js</code>配置文件，以及axios的请求地址改成’/api’</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://后端地址:80'</span>,</span><br><span class="line">    ws: <span class="literal">true</span>, <span class="comment">// 允许跨域</span></span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/api'</span>: <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-后端获取数据"><a href="#6-后端获取数据" class="headerlink" title="6.后端获取数据"></a>6.后端获取数据</h3><p><img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200406191939.png" alt="后台获取数据展示"></p>
<ul>
<li>借助<code>connect-multiparty</code>插件,将文件存在<code>/tmp/</code>目录下</li>
<li>借助<code>body-parse</code>解析form表单数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> multipart = <span class="built_in">require</span>(<span class="string">'connect-multiparty'</span>) <span class="comment">//处理上传的文件</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multipartMiddleware = multipart()</span><br><span class="line">router.post(<span class="string">'/test'</span>, multipartMiddleware, <span class="function"><span class="keyword">function</span> (<span class="params">req, rep</span>) </span>&#123;</span><br><span class="line">  tmpFilePath = req.files.fastafile.path</span><br><span class="line">  <span class="built_in">console</span>.log(req.files)</span><br><span class="line">  <span class="keyword">var</span> fasta = fs.readFileSync(tmpFilePath, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(req.body)</span><br><span class="line">  <span class="built_in">console</span>.log(fasta)</span><br><span class="line">  rep.send(<span class="string">'test'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="7-演示地址"><a href="#7-演示地址" class="headerlink" title="7.演示地址"></a>7.演示地址</h3><p><code>fasta</code><a href="https://biocottonhub.github.io/VueCLII/#/blast/query">文件拖拽校验</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://blog.csdn.net/qq_39816673/article/details/89036065" target="_blank" rel="noopener">文件拖拽失效解决</a> </li>
<li><a href="https://blog.csdn.net/zhq2005095/article/details/89069851" target="_blank" rel="noopener">读取FileList对象内容</a></li>
<li><a href="https://www.jianshu.com/p/83311935d0c0" target="_blank" rel="noopener">拖拽事件触发</a></li>
<li>axios<a href="https://blog.csdn.net/qq_36485978/article/details/100017849?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">跨域</a></li>
</ol>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>circos模块安装</title>
    <url>/codeHub/2020/03/27/2020-06%E4%BB%A5%E5%89%8D/11circos%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Circos安装"><a href="#Circos安装" class="headerlink" title="Circos安装"></a>Circos安装</h2><ol>
<li><p>下载软件包</p>
<blockquote>
<p> <a href="http://circos.ca/software/download/circos/" target="_blank" rel="noopener">http://circos.ca/software/download/circos/</a> </p>
</blockquote>
</li>
<li><p>解压</p>
<p><code>tar -xvzf circos*.tgz</code></p>
</li>
<li><p>安装模块</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看依赖项是否安装</span></span><br><span class="line"><span class="built_in">cd</span> circos*</span><br><span class="line">./bin/circos -module</span><br><span class="line"><span class="comment">#####输出结果</span></span><br><span class="line">ok       1.26 Carp</span><br><span class="line">missing            Clone</span><br><span class="line">missing            Config::General</span><br><span class="line">ok       3.40 Cwd</span><br><span class="line">ok      2.145 Data::Dumper</span><br><span class="line">ok       2.52 Digest::MD5</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="推荐-使用cpanm安装模块"><a href="#推荐-使用cpanm安装模块" class="headerlink" title="[推荐]使用cpanm安装模块"></a>[推荐]使用cpanm安装模块</h3><p>手动安装local::lib模块</p>
<ul>
<li>这里我将所有的perl模块都装到<code>~/perl_lib</code>自定义目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://cpan.metacpan.org/authors/id/H/HA/HAARG/<span class="built_in">local</span>-lib-2.000024.tar.gz</span><br><span class="line">tar xf <span class="built_in">local</span>-lib-2.000024.tar.gz</span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">local</span>-lib-2.000024</span><br><span class="line">perl Makefile.PL --bootstrap=~/perl_lib</span><br><span class="line">make <span class="built_in">test</span> &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>设置环境变量</p>
<p>命令行运行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -I<span class="variable">$&#123;HOME&#125;</span>/自定义目录/lib/perl5 -Mlocal::lib=<span class="variable">$&#123;HOME&#125;</span>/自定义目录</span><br></pre></td></tr></table></figure>

<p>输出内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PATH=<span class="string">"******"</span>; <span class="built_in">export</span> PATH;</span><br><span class="line">PERL5LIB=<span class="string">"******"</span>; <span class="built_in">export</span> PERL5LIB;</span><br><span class="line">PERL_LOCAL_LIB_ROOT=<span class="string">"****<span class="variable">$&#123;PERL_LOCAL_LIB_ROOT:+:$&#123;PERL_LOCAL_LIB_ROOT&#125;</span>&#125;"</span>; <span class="built_in">export</span> PERL_LOCAL_LIB_ROOT;</span><br><span class="line">PERL_MB_OPT=<span class="string">"--install_base \"*****"</span><span class="string">"; export PERL_MB_OPT;</span></span><br><span class="line"><span class="string">PERL_MM_OPT="</span>INSTALL_BASE=****<span class="string">"; export PERL_MM_OPT;</span></span><br></pre></td></tr></table></figure>

<p>复制输出结果，粘贴到<code>~/.bashrc</code>文件内，</p>
<p><code>source ~/.bashrc</code>即可</p>
<p>安装cpanm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://cpan.metacpan.org/authors/id/M/MI/MIYAGAWA/App-cpanminus-1.7043.tar.gz</span><br><span class="line">tar xf App-cpanminus-1.7043.tar.gz</span><br><span class="line"><span class="built_in">cd</span> App-cpanminus-1.7043</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make <span class="built_in">test</span> &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>使用cpanm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpanm 模块名</span><br><span class="line"><span class="comment">#批量安装缺失模块</span></span><br><span class="line">circos -module|awk <span class="string">'$1~/missing/&#123;print $2&#125;'</span>|xargs  -I &#123;&#125; cpanm &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>从CPAN  <a href="https://www.cpan.org/" target="_blank" rel="noopener">https://www.cpan.org/</a>  下载对应的模块源文件</p>
<p>手动安装的配置信息文件 <code>perl_local_config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">module_path=/public/home/zpliu/perl_lib/</span><br><span class="line">PREFIX= <span class="variable">$&#123;module_path&#125;</span> </span><br><span class="line">INSTALLSCRIPT= <span class="variable">$&#123;module_path&#125;</span> /bin </span><br><span class="line">INSTALLBIN= <span class="variable">$&#123;module_path&#125;</span> /bin </span><br><span class="line">INSTALLMAN1DIR= <span class="variable">$&#123;module_path&#125;</span> /man1 </span><br><span class="line">INSTALLSITELIB= <span class="variable">$&#123;module_path&#125;</span> /lib</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PREFIX</code>指定build后路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压源文件</span></span><br><span class="line">tar -xvzf Clone-0.43.tar.gz</span><br><span class="line"><span class="comment">#编译，指定build目标路径</span></span><br><span class="line">perl Makefile.PL `cat ../perl_local_config `</span><br><span class="line">make </span><br><span class="line">make <span class="built_in">test</span> </span><br><span class="line">make install</span><br><span class="line"><span class="comment">#将路径加入环境变量</span></span><br><span class="line"><span class="built_in">export</span> PERL5LIB=/public/home/zpliu/perl_lib/lib/:/public/home/zpliu/perl_lib/lib/Module/lib64/perl5/:/public/home/zpliu/perl_lib/lib/Module/share/perl5/</span><br></pre></td></tr></table></figure>

<p><code>Build.pl</code>类型模块的安装</p>
<p>首先得安装module::build模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl build --prefix=/public/home/zpliu/perl_lib/</span><br><span class="line">./Build build</span><br><span class="line">./Build <span class="built_in">test</span></span><br><span class="line">./Build install</span><br><span class="line"><span class="comment">#添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> PERL5LIB=/public/home/zpliu/perl_lib/lib/:/public/home/zpliu/perl_lib/lib/Module/lib64/perl5/:/public/home/zpliu/perl_lib/lib/Module/share/perl5/</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl Build.PL --prefix=/public/home/zpliu/perl_lib/lib/Module/</span><br><span class="line">./Build build</span><br><span class="line">./Build <span class="built_in">test</span></span><br><span class="line">./Build install</span><br></pre></td></tr></table></figure>

<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><blockquote>
<p>Can’t locate ExtUtils/PkgConfig.pm</p>
</blockquote>
<p>缺失依赖项``ExtUtils::PkgConfig`同样的安装ExtUtils::PkgConfig模块</p>
<p>查看perl中已经安装的模块</p>
<p><code>instmodsh</code></p>
<ul>
<li><p><code>GD</code>模块安装出错，可以使用 libgd  软件替代</p>
<p> <a href="https://comery.github.io/2018/08/15/An-error-when-install-perl-module-GD/" target="_blank" rel="noopener">https://comery.github.io/2018/08/15/An-error-when-install-perl-module-GD/</a> </p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>perl模块安装  <a href="https://www.zhihu.com/question/28532172" target="_blank" rel="noopener">https://www.zhihu.com/question/28532172</a> </li>
<li>cpanm  <a href="https://www.jianshu.com/p/9e90b3524fe2" target="_blank" rel="noopener">https://www.jianshu.com/p/9e90b3524fe2</a> </li>
</ol>
]]></content>
      <categories>
        <category>Circos</category>
      </categories>
  </entry>
  <entry>
    <title>circos进阶之link图</title>
    <url>/codeHub/2020/03/26/2020-06%E4%BB%A5%E5%89%8D/10circos%E8%BF%9B%E9%98%B6%E4%B9%8Blink%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="circos进阶之link图"><a href="#circos进阶之link图" class="headerlink" title="circos进阶之link图"></a>circos进阶之link图</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Links主要试图利用连线关系，表明染色体上不同位置之间的联系。这在实际生物学问题中很常用，尤其是在表示基因和基因之间的共线性的时候，link图是我们的不二选择，之前我们一起学习了使用MCScanX进行共线性分析，下游分析中可以画一个圈图，但是本人认为那个圈图无论是配色还是布局都不是特别好看，今天我们就来学习如何处理MCScanX的结果文件然后用circos去画出我们想要的圈图</p>
<a id="more"></a>

<p>本次教程相应的配置文件和原始数据文件，请点击<a href="https://github.com/yxlong-science/yxlong/archive/master.zip" target="_blank" rel="noopener">此处</a>下载</p>
<h2 id="文件的处理"><a href="#文件的处理" class="headerlink" title="文件的处理"></a>文件的处理</h2><p>link图是需要输入数据的，所以下里面介绍一下link图的输入数据格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">hs1 100 200 hs2 250 300 color&#x3D;ch1</span><br><span class="line">hs2 400 550 hs3 500 750 color&#x3D;ch2</span><br><span class="line">hs3 600 800 hs4 150 350 color&#x3D;ch3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们来看看我们的raw data</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-  0:        Ghir_A01G000050.1       Ghir_D01G000050.1         2e-52</span><br><span class="line">0-  1:        Ghir_A01G000080.1       Ghir_D01G000080.1        5e-171</span><br><span class="line">0-  2:        Ghir_A01G000090.1       Ghir_D01G000100.1         2e-26</span><br><span class="line">0-  3:        Ghir_A01G000100.1       Ghir_D01G000120.1             0</span><br><span class="line">0-  4:        Ghir_A01G000110.1       Ghir_D01G000130.1        9e-179</span><br></pre></td></tr></table></figure>

<p>首先我们要找出MCScanX的结果文件<code>At-Dt.collinearity</code>，通过gff文件，把每一个基因的注释信息找出来，指令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">"\t"</span> <span class="string">'&#123;print $2 "\t" $3&#125;'</span> At-Dt.collinearity | awk <span class="string">'/^Ghir/&#123;print $1&#125;'</span> | xargs -I &#123;&#125; grep &#123;&#125; ./At-Dt.gff | awk <span class="string">'&#123;a=substr($2,1,8)&#125;&#123;print a "\t" $3 "\t" $4&#125;'</span> &gt; 1.tmp</span><br><span class="line">awk -F <span class="string">"\t"</span> <span class="string">'&#123;print $2 "\t" $3&#125;'</span> At-Dt.collinearity | awk <span class="string">'/^Ghir/&#123;print $2&#125;'</span> | xargs -I &#123;&#125; grep &#123;&#125; ./At-Dt.gff | awk <span class="string">'&#123;a=substr($2,1,8)&#125;&#123;print a "\t" $3 "\t" $4&#125;'</span> &gt; 2.tmp</span><br><span class="line">paste 1.tmp 2.tmp  &gt;link.tmp</span><br></pre></td></tr></table></figure>

<p>为了区分不同染色体之间的link，我们这里让link的染色和第一条染色体颜色相同，我们引入一个参数去定义颜色，指令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'&#123;a=substr($1,7,2)&#125;&#123;print $0 "\t" "value=rgb"a&#125;'</span> link.tmp &gt;link.tmp1</span><br></pre></td></tr></table></figure>

<p>我们的link文件就变成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ghir_A01        76870   77973   Ghir_D01        33573   38297   value&#x3D;rgb01</span><br><span class="line">Ghir_A01        88691   90135   Ghir_D01        58267   58998   value&#x3D;rgb01</span><br><span class="line">Ghir_A01        93974   95093   Ghir_D01        67754   69206   value&#x3D;rgb01</span><br><span class="line">...</span><br><span class="line">Ghir_A13	46708701	46711385	Ghir_D13	21207310	21209912	value&#x3D;rgb13</span><br></pre></td></tr></table></figure>

<p>这里我们再使用linux指令对我们的link文件进行筛选，指令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'&#123;gsub(/A0/,"A",$1);gsub(/D0/,"D",$4);print $0&#125;'</span> OFS=<span class="string">"\t"</span> link.tmp|awk <span class="string">'&#123;a=substr($1,7);b=substr($4,7);if(a==b)&#123;print $0&#125;else if(a&gt;=2&amp;&amp;a&lt;=3&amp;&amp;b&gt;=2&amp;&amp;b&lt;=3)&#123;print $0&#125;else if(a&gt;=4&amp;&amp;a&lt;=5&amp;&amp;b&gt;=4&amp;&amp;b&lt;=5)&#123;print $0&#125;&#125;'</span>|awk <span class="string">'&#123;gsub(/A([0-9])$/,"0&amp;",$1);gsub(/D([0-9])$/,"0&amp;",$4);print $0&#125;'</span> OFS=<span class="string">"\t"</span> |sed -e <span class="string">'s/0A/A0/g'</span> -e <span class="string">'s/0D/D0/g'</span> &gt;link.txt</span><br></pre></td></tr></table></figure>

<p>这里我们筛选条件有两个</p>
<ul>
<li><p>保留对应染色体之间的links</p>
</li>
<li><p>不同染色体之间只保留两个亚组的二号三号染色体间和四号五号染色体间的links</p>
</li>
</ul>
<h2 id="配置文件的书写"><a href="#配置文件的书写" class="headerlink" title="配置文件的书写"></a>配置文件的书写</h2><p>circos.conf、ideogram.conf、karyotype.conf、ticks.conf之前的文章有讲述，这里只是多了一个links和colors模块，所以我们这次重点讲述这两个模块</p>
<h3 id="mycolors-conf"><a href="#mycolors-conf" class="headerlink" title="mycolors.conf"></a>mycolors.conf</h3><p>染色体文件karyotype.txt如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chr - Ghir_A01 At01 0 117757855 rgb01</span><br><span class="line">chr - Ghir_A02 At02 0 108092100 rgb02</span><br></pre></td></tr></table></figure>

<p>看到这里肯定有许多小伙伴不太明白最后一列rgb的意义，我们就来看一下前面引用的colors.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rgb01&#x3D;26,188,156</span><br><span class="line">rgb02&#x3D;46,204,113</span><br><span class="line">...</span><br><span class="line">rgb12&#x3D;192,57,43</span><br><span class="line">rgb13&#x3D;142,68,173</span><br></pre></td></tr></table></figure>

<p>这里对每一个rgb都进行了注释，这里采用的注释信息均来自于<a href="https://flatuicolors.com/palette/defo" target="_blank" rel="noopener">flatuicolors</a>，可以直接在上面复制一些自己喜欢的颜色的rgb值。</p>
<h3 id="links-conf"><a href="#links-conf" class="headerlink" title="links.conf"></a>links.conf</h3><p>下面我们就来看一下links.conf这个控制文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;links&gt;</span><br><span class="line">&lt;link&gt;</span><br><span class="line"># 指定link文件，最好使用绝对路径</span><br><span class="line">file&#x3D;&#x2F;public&#x2F;home&#x2F;yxlong&#x2F;yxlong&#x2F;synteny&#x2F;At-DtMCScanX&#x2F;circos&#x2F;link.txt</span><br><span class="line"># links的起始终止位置</span><br><span class="line">radius&#x3D;0.95r</span><br><span class="line">color&#x3D;black_a4</span><br><span class="line"># Circos提供bezier_radius、crest、bezier_radius_purity等参数来控制link的弯曲形式，具体见下图</span><br><span class="line">bezier_radius&#x3D;0.1r</span><br><span class="line">thickness&#x3D;2</span><br><span class="line"># record_limit &#x3D; 控制最后图片上显示的link条数</span><br><span class="line">record_limit &#x3D; </span><br><span class="line"></span><br><span class="line"># 一下就是rules的使用了，这里主要对于link的颜色进行指定，使得link的颜色和A亚组的染色体颜色相同</span><br><span class="line">&lt;rules&gt;</span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb01&quot;</span><br><span class="line">color&#x3D;rgb(26,188,156)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb02&quot;</span><br><span class="line">color&#x3D;rgb(46,204,113)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb03&quot;</span><br><span class="line">color&#x3D;rgb(52,152,219)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb04&quot;</span><br><span class="line">color&#x3D;rgb(155,89,182)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb05&quot;</span><br><span class="line">color&#x3D;rgb(52,73,94)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb06&quot;</span><br><span class="line">color&#x3D;rgb(241,196,15)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb07&quot;</span><br><span class="line">color&#x3D;rgb(230,126,34)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb08&quot;</span><br><span class="line">color&#x3D;rgb(231,76,60)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb09&quot;</span><br><span class="line">color&#x3D;rgb(149,165,166)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb10&quot;</span><br><span class="line">color&#x3D;rgb(243,156,18)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb11&quot;</span><br><span class="line">color&#x3D;rgb(211,84,0)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb12&quot;</span><br><span class="line">color&#x3D;rgb(192,57,43)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition&#x3D; var(value) eq &quot;rgb13&quot;</span><br><span class="line">color&#x3D;rgb(142,68,173)</span><br><span class="line">&lt;&#x2F;rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;rules&gt;</span><br><span class="line">&lt;&#x2F;link&gt;</span><br><span class="line">&lt;&#x2F;links&gt;</span><br></pre></td></tr></table></figure>

<p>最后我们输入指令<code>circos -conf circos..conf</code>等待一会儿就可以得到下面这张图片</p>
<p><img data-src="https://s1.ax1x.com/2020/03/26/G93ZS1.png" alt="G93ZS1.png"></p>
<p>我们的circos之links图就画到这里了，之后我们继续学习更多的circos功能</p>
]]></content>
      <tags>
        <tag>Circos</tag>
      </tags>
  </entry>
  <entry>
    <title>拟南芥中co-transcriptional splicing</title>
    <url>/codeHub/2020/03/26/2020-06%E4%BB%A5%E5%89%8D/09%E6%8B%9F%E5%8D%97%E8%8A%A5%E4%B8%ADco-transcriptional-splicing/</url>
    <content><![CDATA[<blockquote>
<p>  The Features and Regulation of Co-transcriptional Splicing in Arabidopsis  </p>
</blockquote>
<p>在多数真核生物钟，前体RNA的剪切对于基因表达是至关重要的。在之前哺乳动物、果蝇和酵母的研究中发现，大多数剪切事件与RNA的转录是同时进行的。然而在植物中，co-transcriptional splicing(CTS ) 在细胞中表现的特征和它具体的调控机制仍旧是不清楚的。因此作者使用<strong>chromatin-bound RNA sequencing</strong>技术来研究拟南芥中的<strong>CTS</strong>(剪切与转录共同进行)。通过分析发现，拟南芥中大量的可变剪切事件是受到 co-transcriptionally 决定的。同时CTS的效率与基因表达水平、染色质状态、还有基因中内含子、外显子数目存在相关性，而与基因的长度不相关。与此同时结合免疫共沉淀技术，表明一些hnRNP-like 蛋白(RNA结合蛋白)，通过结合到外显子序列上来促进CTS。</p>
<a id="more"></a>

<blockquote>
<p><strong>bound RNA sequencing</strong></p>
</blockquote>
<ul>
<li>从细胞核中提取结合到染色质上的RNA</li>
<li>使用试剂去除非染色相关的RNa和蛋白质</li>
</ul>
<img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200326132718.png" alt="测试示意图" style="zoom: 80%;" />

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前体RNA的剪切是受到一种剪切复合物调控的，剪切复合物能够精准的切除前体RNA中的内含子。之前对于单个基因的研究表明，在基因的转录过程中剪切机制就已经发挥作用，这一过程也被称为<strong>co-transcriptional splicing</strong>(CTS)。这种机制的存在也不足为奇，因为基因的长度相对来说比较长，而基因转录所花的时间平均10min，剪切的时间平均3分钟；当生物为了高效、快速的产生mRNA时，必定会将两个步骤同时进行。在酵母中，RNA聚合酶II完成内含子3‘位点的转录后，向后平均延伸45bp时，剪切复合体就开始催化pre-mRNA的剪切；而在人类细胞中延伸的距离超过1000kb；这也表明不同物种中的CTS存在显著差异</p>
<p>在体内，转录和剪切高度的耦合在一起；但是在体外情况下两者还是可以独立的进行。其中有一种假说，</p>
<h4 id="动力学耦合"><a href="#动力学耦合" class="headerlink" title="动力学耦合"></a><strong>动力学耦合</strong></h4><p>在细胞内，基因在转录时更快的延伸速率将会使得一些弱的剪切位点被识别的几率降低，从而影响了mRNA isforms的产生。转录的延伸速率受到多种因素的调控，其中就包含以下两种:</p>
<ul>
<li>反式因子 </li>
<li>染色质结构， 染色质的开放状态</li>
</ul>
<p>在拟南芥中就报道了两个参与到开花时间控制<strong>FLC</strong>、光响应基因<strong>DOG1</strong>，在不同转录延伸速率下基因 表达出不同的isforms。</p>
<h4 id="剪切因子耦合"><a href="#剪切因子耦合" class="headerlink" title="剪切因子耦合"></a>剪切因子耦合</h4><p>在植物中研究比较深入的一类RNA-binding 蛋白，也被称为SR 蛋白。这些蛋白通过与exon或者intron出的sequence motifs结合，调节RNA聚合酶的延伸、停止。</p>
<h3 id="拟南芥种子中的CTS"><a href="#拟南芥种子中的CTS" class="headerlink" title="拟南芥种子中的CTS"></a>拟南芥种子中的CTS</h3><p>进过 bounding RNA sequence 后，对于每个基因位点可以检测到两种类型RNA：图B</p>
<ol>
<li>RNAs正在转录</li>
<li>RNA转录完成，但还没从染色质上释放</li>
</ol>
<p>将bounding RNA sequence测序得到的read比对回基因组后，发现exon处read比intronread多，说明剪切和转录时同时进行的，导致intron处的read被剪切掉。图C</p>
<img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200326133431.png" alt="测序数据验证" style="zoom: 80%;" />

<h4 id="CTS效率量化"><a href="#CTS效率量化" class="headerlink" title="CTS效率量化"></a>CTS效率量化</h4><p>通过计算发现，CTS rations平均值为0.2，这样说明拟南芥中大多数的pre-mRNA是共转录的剪切方式。</p>
<p><img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200326133934.png" alt="CTS量化"></p>
<h3 id="CTS效率与Exon、Intron数目相关"><a href="#CTS效率与Exon、Intron数目相关" class="headerlink" title="CTS效率与Exon、Intron数目相关"></a>CTS效率与Exon、Intron数目相关</h3><p>在老鼠与果蝇中，基因结构会影响剪切效率。其中第一个和最后一个intron被切除的效率更低，相比与内部的intron。同时基因长度、内含子|外显子的数目与 splice ratios呈负相关。由于基因长度和内含子外显子数目也有一定关系，于是作者分别在固定gene长度的条件下，和固定intron数目下比较相关性。发现intron|exon 的数目与剪切效率存在相关。</p>
<img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200326145813.png" style="zoom:80%;" />

<h3 id="CTS效率与组蛋白修饰呈现负相关"><a href="#CTS效率与组蛋白修饰呈现负相关" class="headerlink" title="CTS效率与组蛋白修饰呈现负相关"></a>CTS效率与组蛋白修饰呈现负相关</h3><p>高水平的H3K4me3、H3K9ac可能会导致更高的转录延伸速率，从而减少CTS的效率。</p>
<p><img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200326150123.png" alt="组蛋白修饰与CTS"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>The Features and Regulation of Co-transcriptional Splicing in Arabidopsis  </li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>ExonSkipDB 数据库</title>
    <url>/codeHub/2020/03/26/2020-06%E4%BB%A5%E5%89%8D/08ExonSkipDB-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<blockquote>
<p>  ExonSkipDB: functional annotation of exon skipping event in human  </p>
</blockquote>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>在人类中，外显子跳跃事件是最常见的一种剪切事件，它通常会导致功能保守位点的缺失或者是ORF的偏移，最终导致多种疾病的产生。而迄今为止，基于癌症组织和正常组织来系统的、完整的注释人类中外显子事件，没有人做过。因此作者通过建立人类中外显子跳跃数据库，在外显子水平上，为研究多种癌症的治疗靶标提供功能注释和参考。作者从  TCGA  数据集和  GTEx  数据集中收集了33份癌症组织和31份正常组织数据，鉴定到了90616和89845个ES事件，对应于14272个基因。对于外显子跳跃事件，作者进行了多种功能注释，包括对ES事件产生的转录本的ORF预测，ES事件导致的蛋白功能丧失，ES事件与碱基突变、甲基化的关联。总的来说，ExonSkipDB数据库将会是用于研究癌症、药物发现的独特资源。</p>
<a id="more"></a>



<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>逐渐累积的证据表明，可变剪切的破坏将会导致疾病的发生。在几种典型的剪切模式中，外显子跳跃是最常见的事件。由于ES将会导致保守功能域的丢失或者ORF的偏移，跳跃的外显子也被当做治疗的靶标。例如：</p>
<blockquote>
<p><strong><em>MET</em></strong> 基因第14个exon的skip导致E3 泛素连接酶不能结合，使得MET的表达水平增加，而MET表达的增加又驱动了癌细胞的扩增。</p>
</blockquote>
<blockquote>
<p>治疗方案：用络氨酸酶抑制剂的药物治疗MET第14个exon skip的患者</p>
</blockquote>
<p><strong>E3 泛素连接酶</strong>：蛋白降解系统里的一种酶</p>
<p>因此通过系统的鉴定和整合分析PAN-cancer和健康组织中的ES事件，将会为解析疾病的机理和发现新的靶标药物提供参考。</p>
<p>随着癌症基因组数据和其他生物数据指数级的增长，其中几个研究通过分析多个癌症中、组织特异性的AS，并且提供了web tools对AS的注释；但是这些研究仅仅只是关注在AS的鉴定以及isform 结构的可视化，并没有对AS的具体功能进行注释。因此作者就建立了ExonSkipDB数据库，为研究癌症、药物发提供参考。</p>
<h3 id="数据库概括"><a href="#数据库概括" class="headerlink" title="数据库概括"></a>数据库概括</h3><p>通过使用ExonSkipDB，用户可以得到如下几方面的信息。</p>
<ul>
<li>通过比较癌细胞与正常细胞中ES事件的PSI、isform丰度，能够发现潜在的癌症或者与癌症相关的特异性ES事件</li>
<li>分析大量ES事件的特征，更深层次的理解癌细胞ES事件中 功能缺失效应</li>
<li>对ES的exon进行ORF预测，分为能够反映的ES和不能翻译的ES；提供能够恢复蛋白功能的候选位点</li>
<li>由于甲基化参与到RNA聚合酶II转录延伸速率的控制，因此作者分析了剪切和甲基化之间的关联sQTM。</li>
</ul>
<h4 id="数据整合"><a href="#数据整合" class="headerlink" title="数据整合"></a>数据整合</h4><p>从TCGA和GTEx数据集中下载了33种癌症类型和31中不同组织的正常组织，其中只有跳跃的那个Exon、上游Exon、下游Exon都保守的才被用于本次研究。</p>
<h4 id="ORF注释"><a href="#ORF注释" class="headerlink" title="ORF注释"></a>ORF注释</h4><p>对于那些特异的Exon skip事件，作者检查主要isform对于的转录本序列，当跳跃的exon是位于编码区的内部，并且碱基数是3的倍数是，这种编码框没有偏移，而当跳跃的exon的碱基数是1或者2的倍数时，称作frame-shift</p>
<h4 id="蛋白特征注释"><a href="#蛋白特征注释" class="headerlink" title="蛋白特征注释"></a>蛋白特征注释</h4><blockquote>
<p>  6 molecule processing features, 13<br>  region features, 4 site features, 6 amino acid modifcation<br>  features, 2 natural variation features, 5 experimental info<br>  features and 3 secondary structure features  </p>
</blockquote>
<h4 id="鉴定与ES相关的突变"><a href="#鉴定与ES相关的突变" class="headerlink" title="鉴定与ES相关的突变"></a>鉴定与ES相关的突变</h4><p>根据  Wimmer et al. and Anna and Monika  的研究表明，总共有5种剪切突变。其中就包括</p>
<ul>
<li>外显子区域突变，导致剪切增强子被破坏</li>
<li>exon-intron边界区域的剪切位点 突变</li>
<li>内含子区域分支位点 突变</li>
<li>内含子区域多嘧啶束 突变</li>
<li>内含子区域新的剪切位点的突变</li>
</ul>
<p>在数据库中，由于作者用到的是全基因组外显子测序数据而不是全基因组测序数据，所有这里只分析外显子区域的突变，而导致的ES事件。</p>
<h4 id="sQTL和sQTM分析"><a href="#sQTL和sQTM分析" class="headerlink" title="sQTL和sQTM分析"></a>sQTL和sQTM分析</h4><p>为了鉴定ES特定的QTL，作者使用TCGA中的sQTL数据，其中有来自于2254个ES基因的4124个SNP被鉴定到。</p>
<p>为了鉴定与ES相关的甲基化位点，作者使用线性回归对ES区域的甲基化程度进行计算，结合eQTL，计算了ES区域甲基化程度与上游区域甲基化程度的相关性。为了鉴定与疾病相关的sQTM，作者挑选出一些显著性的cis-sQTMs，运行生存分析，使用  Kaplan–Meier method and log-rank test  方法。</p>
<h4 id="药物和疾病相关信息"><a href="#药物和疾病相关信息" class="headerlink" title="药物和疾病相关信息"></a>药物和疾病相关信息</h4><p>从Drug Bank数据集中提取了药物靶标互作信息，其中重复的数据被剔除，并且系统的进行了分类编码。从gene-disease关联数据库中提取了疾病-遗传相关信息。</p>
<h3 id="web界面和分析结果"><a href="#web界面和分析结果" class="headerlink" title="web界面和分析结果"></a>web界面和分析结果</h3><h4 id="1-ES结构浏览和与潜在疾病相关的特定ES"><a href="#1-ES结构浏览和与潜在疾病相关的特定ES" class="headerlink" title="1.ES结构浏览和与潜在疾病相关的特定ES"></a>1.ES结构浏览和与潜在疾病相关的特定ES</h4><h4 id="2-对单个ES进行ORF分析有利于筛选潜在的药物靶标"><a href="#2-对单个ES进行ORF分析有利于筛选潜在的药物靶标" class="headerlink" title="2.对单个ES进行ORF分析有利于筛选潜在的药物靶标"></a>2.对单个ES进行ORF分析有利于筛选潜在的药物靶标</h4><h4 id="3-ES导致蛋白功能丧失的特征"><a href="#3-ES导致蛋白功能丧失的特征" class="headerlink" title="3.ES导致蛋白功能丧失的特征"></a>3.ES导致蛋白功能丧失的特征</h4><h4 id="4-非同义突变与ES的关联"><a href="#4-非同义突变与ES的关联" class="headerlink" title="4.非同义突变与ES的关联"></a>4.非同义突变与ES的关联</h4><h4 id="5-ES与sQTL、sQTM"><a href="#5-ES与sQTL、sQTM" class="headerlink" title="5.ES与sQTL、sQTM"></a>5.ES与sQTL、sQTM</h4><h4 id="6-与ES相关的药物和人类疾病"><a href="#6-与ES相关的药物和人类疾病" class="headerlink" title="6.与ES相关的药物和人类疾病"></a>6.与ES相关的药物和人类疾病</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>ExonSkipDB: functional annotation of exon skipping event in human  </li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>白血病中T细胞3维染色质图谱</title>
    <url>/codeHub/2020/03/24/2020-06%E4%BB%A5%E5%89%8D/07T%E7%BB%86%E8%83%9E3%E7%BB%B4%E6%9F%93%E8%89%B2%E8%B4%A8%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<blockquote>
<p>Three-dimensional chromatin landscapes in T cell acute lymphoblastic leukemia</p>
</blockquote>
<hr>
<p>​    染色质3维结构的差异会影响TADs(topologically associating domains)的完整性，使得特定的增强子和启动子发生互作，从而影响基因的表达、导致疾病的发生。通过使用人类中白血病样本，并且检测在药物施加后染色质结构的变化，整合原位Hi-c、RNA-seq、CTCG Chip-seq等多种数据集，揭示了白血病细胞中TAD内部的交互、TAD边界的结缘效应的差异。本文研究发现：TAD的 ‘fusion’事件与CTCT的缺失存在关联，TAD的合并事件也直接导致<strong><em>MYC</em></strong>基因去远端超级增强子之间发生互作。同时作者也发现，小分子药物通过靶向癌症相关基因或是对应的表观调控过程，最终能够改变白血病细胞中特定的3D交互。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    在人类基因组中充斥着大量的调控元件，例如我们常说的启动子、增强子、绝缘子。最近的研究基因组在空间上形成3维结构，来控制这些调控元件在物理上的距离，从而达到对基因表达的精细控制。</p>
<p>​    基因组压缩成染色体包含多个步骤，其中就包括将染色质压缩成核小体、染色质丝、compartments、染色质domain。多种证据表明，在Mb分辨率下，基因组被组织成一个个称作TAD的染色质区域，在每个TAD区域内部染色质发生频繁的交互。从生物学上解释这个现象就是，TAD限制了调控元件和基因在同一个区域，与此同时又隔绝了与相邻区域的交互；保证了基因正常的表达。进一步的证据也表明基因组内往往存在一些超级增强子，它们调控一些控制细胞身份、或者是驱动癌症发生的关键基因的表达；但是这些增强子往往与TAD 的boundary一同存在，从而隔绝了它对下游基因的调控，保证生命活动的正常进行。</p>
<p>​    TAD boundary （TAD 边界）通常富集一些能够与<strong>CTCF</strong>蛋白结合的motif，motif的方向以及  Cohesin-mediated  是形成TADs的关键。在TAD 边界处异常的<strong>CTCF</strong> 结合位点或者倒置的方向，都会倒置TAD结构的改变，并且使得增强子和启动子之间的交互发生改变，倒置异常的基因表达。</p>
<img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200324211307.png" alt="TAD结构图" style="zoom:80%;" />

<p>​    </p>
<p>​    作者通过比较正常的T细胞与白血病人的T细胞中，染色质结构的差异；在白血病患者T细胞中鉴定到一个TAD boundary的改变，而TAD边界的改变导致<strong>MYC</strong>基因与  NOTCH-bound super-enhancer之间的交互。通过药物<strong>γSI</strong>抑制<strong>MYX</strong>和增强子的交互，结果发现有一部分仍旧维持交互。作者通过分析发现另外一个因子<strong>CDK7</strong>，也能控制启动子和增强子的交互。</p>
<h3 id="3D-染色质结构在T细胞中的差异"><a href="#3D-染色质结构在T细胞中的差异" class="headerlink" title="3D 染色质结构在T细胞中的差异"></a>3D 染色质结构在T细胞中的差异</h3><p>​    通过对数据集中  ‘hic-ratio’ insulation scores 指标 ，在每样本个基因组bin中的分值进行PCA分析，发现数据集被分为3类样本。通过分析白血病细胞的表达模式，发现样本可以分为两个亚组。比较不同类之间Compartment  的差异，发现一些样本特异的 Compartments,和共有的compartments。 </p>
<img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200324200600.png" alt="图1" style="zoom:80%;" />



<h3 id="T细胞中TAD活性的差异"><a href="#T细胞中TAD活性的差异" class="headerlink" title="T细胞中TAD活性的差异"></a>T细胞中TAD活性的差异</h3><p>比较白血病T细胞与正常的T细胞中共有的TAD活性的差异，将TAD分成几类：</p>
<ul>
<li>在正常细胞中TAD活性下降</li>
<li>在白血病细胞中TAD活性增加</li>
</ul>
<p>在两类细胞中活性改变的模式也呈现相似性。</p>
<p>为了进一步分析正常T细胞和白血病T细胞中TAD的差异，作者结合 CTCF Chip-seq数据，分析了CTCG在上一步分好类的TAD的聚集情况。基因表达在不同类型TAD的情况，超级增强子非富集情况。可以看出在<code>在白血病细胞中TAD活性增加</code>这一类TAD中，增强子的富集程度存在显著差异。</p>
<p><img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200324203041.png" alt="TAD差异与其他数据的关联"></p>
<h3 id="TAD-boundary的绝缘效应"><a href="#TAD-boundary的绝缘效应" class="headerlink" title="TAD boundary的绝缘效应"></a>TAD boundary的绝缘效应</h3><p>​    在比较了两种细胞TAD上的差异后，作者又比较了TAD boundary的差异。TAD boundary的丢失通常增加TAD内部的交互，使得相邻的两个TAD融合成为一个TAD；而TAD boundary的获得，会减少TAD内部的交互，因为TAD boundary的存在隔绝了TAD 与TAD之间的交互。</p>
<p>通过比较两类细胞中boundary gain类型与boundary loose类型的boundary在绝缘效应上的变化，发现boundary获得性绝缘效应增加(图f),而boundary丢失型，绝缘效应减少。</p>
<img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200324204344.png" alt="boundary的差异" style="zoom:80%;" />



<h3 id="CTCF介导TAD的绝缘效应，控制MYC基因与增强子的交互"><a href="#CTCF介导TAD的绝缘效应，控制MYC基因与增强子的交互" class="headerlink" title="CTCF介导TAD的绝缘效应，控制MYC基因与增强子的交互"></a>CTCF介导TAD的绝缘效应，控制MYC基因与增强子的交互</h3><ul>
<li><p>MYC基因在白血病细胞中显著上调，与此同时发现MYC基因对应的基因组区域有TAD 融合事件，表明附近染色质的交互作用增强。</p>
</li>
<li><p>通过比较正常细胞与白血病细胞的CTCF Chip-seq数据发现，白血病细胞peak的缺失。导致peak的缺失原因不是由于碱基的突变或者DNA的超甲基化。</p>
</li>
<li><p>通过CRISPR技术将正常细胞的CTCF位点突变后，使用FISH进行染色，发现MYC启动子与增强子之间的物理距离被拉近。这也证实了作者的猜想，CTCF可能是控制TAD 稳定性的一个因素</p>
</li>
</ul>
<p><img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200324210009.png" alt="CTCF绝缘效应"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>MYC基因的上调表达，以及CTCF peak的缺失，表明TAD的融合对基因表达的影响；但是究竟是什么调控CTCF仍旧是未知的。初步的研究以及排除了碱基突变和超甲基化两种可能的因素；ATAC-seq分析表明染色质可及性可能是一个潜在的原因。</li>
<li>TAD内部的交互与基因表达、增强子活性存在关联</li>
<li>有些特定的抑制剂能够抑制对应增强子的活性，但是仍旧有一些增强子不会被抑制；并且这些增强子长度更长，可能它受到多种调控因子的作用</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>Three-dimensional chromatin landscapes in T cell acute lymphoblastic leukemia  </li>
<li>On the existence and functionality of topologically associating domains  </li>
</ol>
]]></content>
      <categories>
        <category>文献</category>
      </categories>
  </entry>
  <entry>
    <title>MCScanX共线性分析</title>
    <url>/codeHub/2020/03/24/2020-06%E4%BB%A5%E5%89%8D/06MCScanX%E5%85%B1%E7%BA%BF%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="MCScanX的简介"><a href="#MCScanX的简介" class="headerlink" title="MCScanX的简介"></a>MCScanX的简介</h2><p>MCScanX：Multiple Collinearity Scan toolkit是一种算法，扫描多个基因组或亚基因组，以识别假定的同源染色体区域，然后使用基因定位这些区域。它的速度很快，操作简单，便于使用，是我们在进行基因共线性分析时的一个利器。</p>
<p>今天我们就来学习一下如何使用这个利器来帮助我们分析生物学问题</p>
<a id="more"></a>

<h2 id="MCScanX的下载与安装"><a href="#MCScanX的下载与安装" class="headerlink" title="MCScanX的下载与安装"></a>MCScanX的下载与安装</h2><p>下载软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://chibba.pgml.uga.edu/mcscan2/MCScanX.zip</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip MCScanX.zip</span><br></pre></td></tr></table></figure>

<p>到安装目录之后，给</p>
<ul>
<li>msa.h</li>
<li>dissect_multiple_alignment.h</li>
<li>detect_collinear_tandem_arrays.h</li>
</ul>
<p>这三个文件前面添加上<code>\#include &lt;unistd.h&gt;</code>，原因是软件不支持64位操作系统，然后make一下就安装完成了。</p>
<h2 id="原始数据的准备"><a href="#原始数据的准备" class="headerlink" title="原始数据的准备"></a>原始数据的准备</h2><p>我们这里使用陆地棉TM-1的基因组数据作为原始数据，去探究棉花两个亚基因组之间的共线性。</p>
<p>首先下载数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://cotton.hzau.edu.cn/EN/data/download/Ghirsutum_genome_HAU_v1.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf Ghirsutum_genome_HAU_v1.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>我们需要<code>Ghirsutum_gene_model.gff3</code>、<code>Ghirsutum_gene_peptide.fasta</code>这两组数据，我们来看看两组数据长什么样</p>
<h3 id="gff文件"><a href="#gff文件" class="headerlink" title="gff文件"></a>gff文件</h3><p>下面是<code>Ghirsutum_gene_model.gff3</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ghir_A01        Ghir_EVM        gene    80323913        80324566        .       +       .       ID&#x3D;Ghir_A01G013980;Name&#x3D;Ghir_A01G013980</span><br><span class="line">Ghir_A01        Ghir_EVM        mRNA    80323913        80324566        .       +       .       ID&#x3D;Ghir_A01G013980.1;Parent&#x3D;Ghir_A01G013980</span><br><span class="line">Ghir_A01        Ghir_EVM        CDS     80324198        80324566        .       +       0       ID&#x3D;cds.Ghir_A01G013980.1;Parent&#x3D;Ghir_A01G013980.1</span><br></pre></td></tr></table></figure>

<p>软件需要的gff文件格式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sp#	 gene	starting_position	ending_position</span><br></pre></td></tr></table></figure>

<p>所以我们可以使用linux指令中的awk去处理我们的文件，指令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">"\t"</span> <span class="string">'&#123;a=substr($9,4,15)&#125;$0~/gene/&#123;print $1 "\t" a".1" "\t" $4 "\t" $5&#125;'</span> Ghirsutum_gene_model.gff3 &gt;At-Dt.gff</span><br></pre></td></tr></table></figure>

<p>因为我们的gff文件中的基因名最后是没有.1的，但是我们使用了每一个基因的第一个蛋白质序列，所以两个输入文件中的基因名不同，我们可以将gff文件中的基因名后面加上.1</p>
<h3 id="蛋白质序列文件"><a href="#蛋白质序列文件" class="headerlink" title="蛋白质序列文件"></a>蛋白质序列文件</h3><p>然后就是<code>Ghirsutum_gene_peptide.fasta</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;Ghir_A01G000010.1</span><br><span class="line">MLKQDGTLCSFSPCMEQVQRSCETLRSDFIEIYGPLKYCSACMKSVNGKWITRRSMMGIPLHALHTRGGRLQVKQVWGTM</span><br><span class="line">QVLRESWLGHLLKLEGILDI</span><br><span class="line">&gt;Ghir_A01G000020.1</span><br><span class="line">MNKIPYPDLTVDLRDKTITLVARLILLLIHAQHSMLRQSSSEIYDLGRKLGNSSFLGAWPDSIAGRWG</span><br></pre></td></tr></table></figure>

<p>每个基因可以预测出多个蛋白质序列，我们这里同统一采用.1结尾的序列，并且我们需要比对的是A亚组和D亚组，所以我们就要把A亚组和D亚组的蛋白质序列数据分开，指令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'NR==1&amp;&amp;$1~/^&gt;/&#123;print $0&#125;NR&gt;=2&amp;&amp;$1~/^&gt;/&#123;print "\n"$0&#125;$1~/^[^&gt;]/&#123;printf $0&#125;'</span> Ghirsutum_gene_peptide.fasta |grep <span class="string">'^&gt;Ghir_A'</span> -A 1|grep <span class="string">'\.1$'</span> -A 1 |sed <span class="string">'/--/d'</span> &gt;At.fasta</span><br><span class="line">awk <span class="string">'NR==1&amp;&amp;$1~/^&gt;/&#123;print $0&#125;NR&gt;=2&amp;&amp;$1~/^&gt;/&#123;print "\n"$0&#125;$1~/^[^&gt;]/&#123;printf $0&#125;'</span> Ghirsutum_gene_peptide.fasta |grep <span class="string">'^&gt;Ghir_D'</span> -A 1|grep <span class="string">'\.1$'</span> -A 1 |sed <span class="string">'/--/d'</span> &gt;Dt.fasta</span><br></pre></td></tr></table></figure>

<h3 id="blast结果文件"><a href="#blast结果文件" class="headerlink" title="blast结果文件"></a>blast结果文件</h3><h4 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">makeblastdb -in At.fasta -dbtype prot -parse_seqids -out Atdb</span><br></pre></td></tr></table></figure>

<p>这里选择两个亚基因组中的任意一个建库即可</p>
<h4 id="比对"><a href="#比对" class="headerlink" title="比对"></a>比对</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blastp -query Dt.fasta -db Atdb -out At-Dt.blast -evalue 1e-10 -num_threads 30 -outfmt 6 -num_alignments 5</span><br></pre></td></tr></table></figure>

<p>参数解释如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-query 被比对的物种的蛋白质文件</span><br><span class="line">-db 上一步建的库</span><br><span class="line">-out 输出结果</span><br><span class="line">-evalue 设置输出结果的e-value值，值越小相似度越高。</span><br><span class="line">-num_threads 比对所用的线程数</span><br><span class="line">-outfmt 输出的格式</span><br><span class="line">-num_alignments 输出比对上的序列的最大值条目数</span><br></pre></td></tr></table></figure>

<p>这一步是限速步骤，会花费一些时间</p>
<p>运行结束后会得到一个名为<code>At-Dt.blast</code>的文件，这是我们软件需要的输入文件之一。</p>
<p>至此为止我们就得到了两个软件的输入文件<code>At-Dt.blast``At-Dt.gff</code></p>
<p>注意事项</p>
<ul>
<li><p>如果比较多个基因组之间的共线性，我们要将这些物种的gff文件cat在一起</p>
</li>
<li><p>两个输入文件里边的基因名必须一致，一定要仔细检查</p>
</li>
</ul>
<h2 id="软件的运行"><a href="#软件的运行" class="headerlink" title="软件的运行"></a>软件的运行</h2><p>将上一步生成的At-Dt.blast和At-Dt.gff放到新建的At-Dt文件夹内，然后输入指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MCScanX .&#x2F;At-Dt</span><br></pre></td></tr></table></figure>

<p>经过短暂的时间后，就会生成一个文件<code>At-Dt.collinearity</code>和一个文件夹<code>At-Dt.html</code></p>
<p>At-Dt.collinearity里记录了共线性信息,可以清楚的看到共线性基因的数目比例以及具体的比对信息</p>
<h2 id="下游分析"><a href="#下游分析" class="headerlink" title="下游分析"></a>下游分析</h2><p>这里主要讲可视化分析，这里有四种图供我们选择</p>
<h3 id="dot-plotter"><a href="#dot-plotter" class="headerlink" title="dot_plotter"></a>dot_plotter</h3><p>首先我们需要修改<code>MCScanX/downstream_analyses</code>里边的<code>dot.ctl</code>这个control文件，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">800	&#x2F;&#x2F;dimension (in pixels) of x axis</span><br><span class="line">800	&#x2F;&#x2F;dimension (in pixels) of y axis</span><br><span class="line">Ghir_A01,Ghir_A02,Ghir_A03,Ghir_A04,Ghir_A05,Ghir_A06,Ghir_A07,Ghir_A08,Ghir_A09,Ghir_A10,Ghir_A11,Ghir_A12,Ghir_A13	&#x2F;&#x2F;chromosomes in x axis</span><br><span class="line">Ghir_D01,Ghir_D02,Ghir_D03,Ghir_D04,Ghir_D05,Ghir_D06,Ghir_D07,Ghir_D08,Ghir_D09,Ghir_D10,Ghir_D11,Ghir_D12,Ghir_D13	&#x2F;&#x2F;chromosomes in y axis</span><br></pre></td></tr></table></figure>

<p>主要修改的部分就是染色体名字，想画哪条染色体就把那一条染色体写进去就可以了，染色体名字要和gff文件中的染色体名字相同，然后运行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java dot_plotter </span><br><span class="line">-g At-Dt.gff </span><br><span class="line">-s At-Dt.collinearity </span><br><span class="line">-c dot.ctl </span><br><span class="line">-o At-Dtdot.PNG</span><br></pre></td></tr></table></figure>

<ul>
<li>-g后面是gff文件</li>
<li>-s是得到的后缀为collinearity的结果文件</li>
<li>-c是我们需要修改的control文件</li>
<li>-o是输出的文件名称</li>
</ul>
<p>各个文件的路径要指定明确，之后会得到图片如下</p>
<img data-src="https://s1.ax1x.com/2020/03/24/8qbv6K.png" alt="At-Dtdot.PNG" style="zoom: 50%;" />

<p>如果有使用Xshell运行上述代码时提示需要下载Xmanager的小伙伴，可以参考主页文章<a href="[https://biocottonhub.github.io/codeHub/2020/03/22/04vscode%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AFR%E4%BA%A4%E4%BA%92/](https://biocottonhub.github.io/codeHub/2020/03/22/04vscode与服务端R交互/)">04vscode与服务端R交互</a></p>
<h3 id="dual-synteny-plotter"><a href="#dual-synteny-plotter" class="headerlink" title="dual_synteny_plotter"></a>dual_synteny_plotter</h3><p>dual_synteny.ctl文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">600     &#x2F;&#x2F;plot width (in pixels)</span><br><span class="line">800     &#x2F;&#x2F;plot height (in pixels)</span><br><span class="line">Ghir_A01      &#x2F;&#x2F;chromosomes in the left column</span><br><span class="line">Ghir_D01       &#x2F;&#x2F;chromosomes in the right column</span><br></pre></td></tr></table></figure>

<p>指令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java dual_synteny_plotter </span><br><span class="line">-g At-Dt.gff </span><br><span class="line">-s At-Dt.collinearity </span><br><span class="line">-c dual_synteny.ctl </span><br><span class="line">-o At-Dtdual.PNG</span><br></pre></td></tr></table></figure>

<img data-src="https://s1.ax1x.com/2020/03/24/8LPmu9.png" alt="At-Dtdual.PNG" style="zoom:50%;" />

<h3 id="circle-plotter"><a href="#circle-plotter" class="headerlink" title="circle_plotter"></a>circle_plotter</h3><p>circle.ctl文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">800	&#x2F;&#x2F;plot width and height (in pixels)	</span><br><span class="line">Ghir_A01,Ghir_A02,Ghir_A03,Ghir_D01,Ghir_D02,Ghir_D03	&#x2F;&#x2F;chromosomes in the circle</span><br></pre></td></tr></table></figure>

<p>指令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java circle_plotter </span><br><span class="line">-g At-Dt.gff </span><br><span class="line">-s At-Dt.collinearity </span><br><span class="line">-c circle.ctl </span><br><span class="line">-o At-Dtcircle.PNG</span><br></pre></td></tr></table></figure>

<img data-src="https://s1.ax1x.com/2020/03/24/8LPnBR.png" alt="At-Dtcircle.PNG" style="zoom:50%;" />

<h3 id="bar-plotter"><a href="#bar-plotter" class="headerlink" title="bar_plotter"></a>bar_plotter</h3><p>bar.ctl文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">800     &#x2F;&#x2F;dimension (in pixels) of x axis</span><br><span class="line">800     &#x2F;&#x2F;dimension (in pixels) of y axis</span><br><span class="line">Ghir_A01,Ghir_A02,Ghir_A03      &#x2F;&#x2F;reference chromosomes</span><br><span class="line">Ghir_D01,Ghir_D02,Ghir_D03      &#x2F;&#x2F;target chromosomes</span><br></pre></td></tr></table></figure>

<p>指令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java bar_plotter </span><br><span class="line">-g At-Dt.gff </span><br><span class="line">-s At-Dt.collinearity </span><br><span class="line">-c bar.ctl </span><br><span class="line">-o At-Dtbar.PNG</span><br></pre></td></tr></table></figure>

<img data-src="https://s1.ax1x.com/2020/03/24/8LPZjJ.png" alt="At-Dtbar.PNG" style="zoom:50%;" />

<p>至此我们就基本掌握MCScanX的用法，还有一些其他的下游分析，可以参考<a href="http://chibba.pgml.uga.edu/mcscan2/" target="_blank" rel="noopener">官网</a></p>
<p>如果想画出更美观的图片，可以参考我们的后续文章，会教大家如何处理MCScanX的结果文件然后使用circos画出更好看的圈图</p>
]]></content>
  </entry>
  <entry>
    <title>hexo文章书写规范</title>
    <url>/codeHub/2020/03/23/2020-06%E4%BB%A5%E5%89%8D/05hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<h2 id="文章书写规范"><a href="#文章书写规范" class="headerlink" title="文章书写规范"></a>文章书写规范</h2><h3 id="1-生成一篇空白markdown文件"><a href="#1-生成一篇空白markdown文件" class="headerlink" title="1.生成一篇空白markdown文件"></a>1.生成一篇空白markdown文件</h3><ul>
<li>在生成新的markdown时，加上数字编号，以便以后方便查看</li>
<li>当然在文章属性栏，把数字去掉这样在网页上就不会看到这个编号了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"05hexo文章发布"</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>空白mrakdown生成后便如下所示:</p>
<p><img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200323104754.png" alt="空白文件"></p>
<h3 id="2-给文章分类或者加标签"><a href="#2-给文章分类或者加标签" class="headerlink" title="2.给文章分类或者加标签"></a>2.给文章分类或者加标签</h3><ul>
<li>在文章属性栏进行修改，一篇文章可以有多个分类和标签</li>
<li>注意<code>-</code>和标签名之间的空格</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 05hexo文章发布</span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">author: zpliu</span><br><span class="line">date: 2020-03-23 10:10:41</span><br><span class="line">categories:</span><br><span class="line">	- RNA-seq</span><br><span class="line">	- Circos</span><br><span class="line">Tags:</span><br><span class="line"> 	- hexo</span><br></pre></td></tr></table></figure>



<h3 id="3-创建新的标签或者分类"><a href="#3-创建新的标签或者分类" class="headerlink" title="3.创建新的标签或者分类"></a>3.创建新的标签或者分类</h3><p>当你写好一篇文章后发现没有你想要的分类或者标签时，可以自己手动创建对应的标签或者分类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">"新的标签名"</span></span><br></pre></td></tr></table></figure>

<p>创建好后修改对应的标签文件<code>source/新的标签名/index.md</code></p>
<ul>
<li>如果是标签则增加<code>type</code>属性为<code>tags</code></li>
<li>如果是分类则增加<code>rype</code>属性为<code>catrgories</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 新的标签名</span><br><span class="line">date: 2020-03-22 21:56:41</span><br><span class="line"><span class="built_in">type</span>: tags</span><br></pre></td></tr></table></figure>

<h3 id="4-文章书写好后进行发布"><a href="#4-文章书写好后进行发布" class="headerlink" title="4.文章书写好后进行发布"></a>4.文章书写好后进行发布</h3><p>首先在将云端源代码全部pull下来</p>
<blockquote>
<p>因为这个项目是多个人共同编辑的，你需要将别人写好的源代码同样的拉到本地，进行编译</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>在将源代码更新到最新状态后，对markdown文件进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">gulp </span><br><span class="line">hexo d --message <span class="string">"comments"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-上传源代码"><a href="#5-上传源代码" class="headerlink" title="5.上传源代码"></a>5.上传源代码</h3><p>在发布完成后，同样的需要将你的源代码上传到仓库中，因为其他人在发布文章的时候同样需要用到你的源代码进行编译</p>
<p>使用命令<code>git status</code>查看当前源代码仓库文件变动</p>
<p>可以看到在文章书写好后，源代码仓库中多了一个markdown文件，这个文件就需要提交到云端源码仓库</p>
<p><img data-src="https://43423.oss-cn-beijing.aliyuncs.com/img/20200323110839.png" alt="y源代码变动"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"上传源代码 文章书写规范"</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>



<p>需要注意的是，对于仓库中一下文件不需要做修改</p>
<ul>
<li><code>theme/</code>下所有文件</li>
<li><code>_confg.yml</code>文件</li>
</ul>
<p>以上就完成了文章的发布，尽情享受hexo带来的便捷吧!</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode与服务端R交互</title>
    <url>/codeHub/2020/03/22/2020-06%E4%BB%A5%E5%89%8D/04vscode%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AFR%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<span class="label success">vscode</span> 一款让人爱不释手的IDE，也是前端工程师一大杀器。在window上使用R对数据进行操作，当数据量太大的时候，电脑就会吃不消；而服务端的R一看起来就灰常的枯燥。加上最近vscode增加了对R语言的支持，使得在vscode中编写R脚本变成现实，vscode多session的特点使得能够同时打开多个窗口使用服务端的R进行大数据的计算。

<a id="more"></a>

<p>服务端R使用常见3种方法</p>
<ul>
<li>1.<code>Rstudio-server</code>建立网页版的Rstudio，需要管理员权限</li>
<li>2.使用conda安装Rstudio，再使用x-manger将信号转发，软件收费</li>
<li>3.使用vscode与连接服务器，直接与服务端进行交互</li>
</ul>
<p>我使用的是第3种方法</p>
<h3 id="1-vscode安装插件"><a href="#1-vscode安装插件" class="headerlink" title="1.vscode安装插件"></a>1.vscode安装插件</h3><p>使用<code>Remote-SSH</code>插件连接服务器</p>
<ul>
<li>点击魔方图标，搜索关键字<code>remote-ssh</code></li>
<li>下载对应的插件即可</li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3XwhHP.png" alt="插件下载"></p>
<h3 id="2-使用Remote-SSH连接·服务器"><a href="#2-使用Remote-SSH连接·服务器" class="headerlink" title="2.使用Remote-SSH连接·服务器"></a>2.使用<code>Remote-SSH</code>连接·服务器</h3><h4 id="2-1如下所示进行信息的配置"><a href="#2-1如下所示进行信息的配置" class="headerlink" title="2.1如下所示进行信息的配置"></a>2.1如下所示进行信息的配置</h4><p> <img data-src="https://s2.ax1x.com/2020/03/07/3Xdbex.png" alt="3Xdbex.png"></p>
<h4 id="2-2配置信息如下"><a href="#2-2配置信息如下" class="headerlink" title="2.2配置信息如下"></a>2.2配置信息如下</h4><ul>
<li><p>如果存在墙的话，可以使用x-shell隧道将信号转发到本地</p>
<p>参考 <a href="https://zpliu.gitbook.io/booknote/mysql/02sqlyog-ruan-jian-pei-zhi" target="_blank" rel="noopener">https://zpliu.gitbook.io/booknote/mysql/02sqlyog-ruan-jian-pei-zhi</a> 进行隧道转发</p>
</li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3XdfFU.png" alt="3XdfFU.png"></p>
<h3 id="3-验证密码"><a href="#3-验证密码" class="headerlink" title="3.验证密码"></a>3.验证密码</h3><ul>
<li>密码输入后就登录成功了</li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3X02PU.png" alt="3X02PU.png"></p>
<ul>
<li><p>选择要显示的目录，这里需要再一次输入密码</p>
<p><strong><em>这里选择<code>.vscode</code>目录是方便vscode根据文件的变化情况进行自动刷新</em></strong></p>
</li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3XBCIf.png" alt="3XBCIf.png"></p>
<ul>
<li>登录成功后的样子</li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3XDOud.png" alt="3XDOud.png"></p>
<h3 id="4-给服务器装vscode的插件"><a href="#4-给服务器装vscode的插件" class="headerlink" title="4.给服务器装vscode的插件"></a>4.给服务器装vscode的插件</h3><ul>
<li><code>R</code></li>
<li><code>R LSP Client</code></li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3XsCIx.png" alt="3XsCIx.png"></p>
<h4 id="4-1分别对插件R和R-LSP-Clint进行配置"><a href="#4-1分别对插件R和R-LSP-Clint进行配置" class="headerlink" title="4.1分别对插件R和R LSP Clint进行配置"></a>4.1分别对插件<code>R</code>和<code>R LSP Clint</code>进行配置</h4><ul>
<li>主要就是将<strong>服务器端的R执行脚本绝对路径</strong>添加进去</li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3XyY9K.png" alt="3XyY9K.png"></p>
<ul>
<li><code>R LSP Client</code>插件也是同样的进行配置</li>
</ul>
<h3 id="5-重启vscode"><a href="#5-重启vscode" class="headerlink" title="5.重启vscode"></a>5.重启vscode</h3><ul>
<li>再次输出服务器密码进行登录</li>
<li>在目录下创建一个新的<code>test.R</code>文件</li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3X6yZ9.png" alt="3X6yZ9.png"></p>
<ul>
<li><p>在<code>test.R</code>文件中编写脚本</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"ggplot2"</span>)</span><br><span class="line"><span class="keyword">require</span>(ggplot2)</span><br><span class="line">qplot(carat, price, data = diamonds, xlab = <span class="string">"hhh"</span>, xlim = c(<span class="number">1</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>快捷键<code>ctrl + enter</code>按行执行脚本</p>
</li>
<li><p><code>ctrl + shift +s</code>执行整个文件</p>
</li>
</ul>
<h4 id="5-1最终效果"><a href="#5-1最终效果" class="headerlink" title="5.1最终效果"></a>5.1最终效果</h4><ul>
<li>vscode能够自动跟踪文件的变化，刷新图片进行显示</li>
</ul>
<p><img data-src="https://s2.ax1x.com/2020/03/07/3X6xsg.png" alt="3X6xsg.png"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.jianshu.com/p/0740b08e2a37" target="_blank" rel="noopener">https://www.jianshu.com/p/0740b08e2a37</a> </li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Frenkun.me%2F2019%2F12%2F11%2Fwriting-r-in-vscode-a-fresh-start%2F" target="_blank" rel="noopener">Writing R in VSCode: A Fresh Start</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Frenkun.me%2F2019%2F12%2F26%2Fwriting-r-in-vscode-interacting-with-an-r-session%2F" target="_blank" rel="noopener">Writing R in VSCode: Interacting with an R session</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fremote%2Fssh" target="_blank" rel="noopener">Remote Development using SSH</a></li>
<li><a href="">Quick start: SSH key</a></li>
</ol>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
  </entry>
  <entry>
    <title>circos作图基础</title>
    <url>/codeHub/2020/03/22/2020-06%E4%BB%A5%E5%89%8D/03circos%E4%BD%9C%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="circos的简介"><a href="#circos的简介" class="headerlink" title="circos的简介"></a>circos的简介</h2><p>​    众所周知，生物信息学是一个以庞大的数据量为基础的学科，这也就是使得结果的可视化变得有些困难，随着生物信息的发展，其辅助分析工具也迅速增多，Martin Krzywinski等人开发的Circos就在一定程度上解决了可视化困难这个问题。Circos是一个可视化数据和信息的软件包。它以圆形布局可视化数据——这使得Circos非常适合探索对象或位置之间的关系。它是创建高质量信息图表和插图的理想工具，具有丰富的分层数据和令人愉快的对称性。你可以根据你的受众调整其焦点和细节并且可以很好地控制图中的每个元素，此外，其具备高度自动化的特点，是由纯文本配置文件控制，十分的方便快捷。</p>
<a id="more"></a>

<h2 id="circos的安装"><a href="#circos的安装" class="headerlink" title="circos的安装"></a>circos的安装</h2><p>​    首先在<a href="http://circos.ca/software/download/circos/" target="_blank" rel="noopener">这里</a>下载到最新的Circos软件包，这里主要介绍linux版本，Circos本身是基于Perl的，所以不需要编译安装。解压下载的软件包到你想要存放的位置，并将circos/bin加入环境变量即可。它依赖较多的Perl模块，可以用<code>circos -module</code>查看相关Perl模块的安装情况。如果全部安装完毕，结果如图所示</p>
<p><img data-src="https://s1.ax1x.com/2020/03/21/8RAyfP.png" alt="8RAyfP.png"></p>
<p>如果安装模块儿出现问题，别着急，之后会有文章详细介绍模块儿的安装哦</p>
<h2 id="样本的运行测试"><a href="#样本的运行测试" class="headerlink" title="样本的运行测试"></a>样本的运行测试</h2><p>​    Circos包里有自己的demo，可通过<code>circos -conf yourpath/circos/example/etc/circos.conf</code>来运行，如果你成功的在命令行当前目录下生成png和svg两个图形文件。如下图所示，那么恭喜你已经完成了第一步并且得到了一个十分漂亮的图。</p>
<p><img data-src="https://s1.ax1x.com/2020/03/21/8RAIkn.png" alt="8RAIkn.png"></p>
<h2 id="数据文件格式"><a href="#数据文件格式" class="headerlink" title="数据文件格式"></a>数据文件格式</h2><p>circos主要有四个模块儿需要输入数据文件，包括karyotype以及highlight、plot、link，其格式都相对简单，编辑起来也不麻烦。</p>
<p>我们来看karyotype这个数据文件，这个文件记载了染色体的相关信息，其基本数据格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chr - ID LABEL START END COLOR	</span><br><span class="line">chr - hs1 1 0 249250621 chr1</span><br><span class="line">chr - hs2 2 0 243199373 chr2</span><br><span class="line">chr - hs3 3 0 198022430 chr3</span><br><span class="line">chr - hs4 4 0 191154276 chr4</span><br><span class="line">chr - hs5 5 0 180915260 chr5</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里第一列和第二列一般都是固定的</p>
<p>ID是染色体的名称，一定是你课题中使用的染色体名称</p>
<p>LABEL是在图中显示的染色体名称</p>
<p>START、END尽量覆盖全长，其他的控制文件可以控制画出来的长度</p>
<p>最后一列的color可以随心所欲的自己控制</p>
<h2 id="配置文件的书写"><a href="#配置文件的书写" class="headerlink" title="配置文件的书写"></a>配置文件的书写</h2><h3 id="最简配置文件"><a href="#最简配置文件" class="headerlink" title="最简配置文件"></a>最简配置文件</h3><p>配置文件至少需要五个部分，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Karyotypes</span><br><span class="line">karyotype &#x3D; data&#x2F;karyotype&#x2F;karyotype.human.txt</span><br><span class="line"></span><br><span class="line"># Ideograms</span><br><span class="line">&lt;ideogram&gt;</span><br><span class="line"></span><br><span class="line">&lt;spacing&gt;</span><br><span class="line">default		&#x3D; 0.002r</span><br><span class="line">&lt;&#x2F;spacing&gt;</span><br><span class="line"></span><br><span class="line">thickness	&#x3D; 25p</span><br><span class="line">fill		&#x3D; yes</span><br><span class="line">radius		&#x3D; 0.80r</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;ideogram&gt;</span><br><span class="line"></span><br><span class="line"># Image</span><br><span class="line">&lt;image&gt;</span><br><span class="line">&lt;&lt;include etc&#x2F;image.conf&gt;&gt;</span><br><span class="line">&lt;&#x2F;image&gt;</span><br><span class="line"></span><br><span class="line"># RGB&#x2F;HSV color definitions, color lists, location of fonts, fill patterns.</span><br><span class="line">&lt;&lt;include etc&#x2F;colors_fonts_patterns.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line"># Debugging, I&#x2F;O and other system parameters</span><br><span class="line">&lt;&lt;include etc&#x2F;housekeeping.conf&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以在…/circos-0.69-9/example/etc/下面创建一个test文件夹来逐渐学习我们的配置文件，在test文件夹下创建一个新的circos.conf文件，并将上述代码复制进去，并执行下列指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">circos -conf ./circos.conf</span><br></pre></td></tr></table></figure>

<p>就可以得到这样的一张图片</p>
<p><img data-src="https://s1.ax1x.com/2020/03/21/8RAcSf.png" alt="8RAcSf.png"></p>
<p>下面我们就对上述代码中涉及到模块儿进行学习，包括karyotype、ideogram、ticks等模块。</p>
<h3 id="Karyotype"><a href="#Karyotype" class="headerlink" title="Karyotype"></a>Karyotype</h3><p>Karyotype的信息就如同坐标轴一般，其大小、顺序、位置等直接决定了后续数据的展示。这里我们新建一个karyotype.conf文件用来设置karyotype的相关信息，主要设置的参数包括数据文件来源、是否使用特定染色体、染色体显示的单位大小（unit）、颜色、图中半径等，我们可以在我们的circos.conf中使用&lt;<include karyotype.conf>&gt;来进行调用，karyotype.conf文件的具体格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定数据文件的位置，这里共使用了人类的数据</span><br><span class="line">karyotype &#x3D; data&#x2F;karyotype&#x2F;karyotype.human.txt</span><br><span class="line">chromosomes_display_default &#x3D; no</span><br><span class="line"># 使用哪些染色体，这里可以使用正则表达式</span><br><span class="line">chromosomes	&#x3D; &#x2F;hs[12345678XY]$&#x2F; #匹配以[]中的字符结尾的</span><br><span class="line"># 染色体排序方式</span><br><span class="line">chromosomes_order_by_karyotype	&#x3D; yes</span><br><span class="line"># 染色体单位大小，在后续进行ticks等的设置时都会参考</span><br><span class="line">chromosomes_units	&#x3D; 1000000</span><br><span class="line"># 设置染色体颜色，不指定则用默认设置</span><br><span class="line">chromosomes_color	&#x3D; </span><br><span class="line"># 将染色体反向排列,将所需反向排列的染色体名称写在下面即可</span><br><span class="line">chromosomes_reverse	&#x3D; hs1</span><br><span class="line"># 改变染色体在circos环图内所占比例</span><br><span class="line">chromosomes_scale	&#x3D; hs1:0.25r;hs2:0.25r</span><br><span class="line"># 改变染色体在circos环图内半径大小，如图中右上角</span><br><span class="line">chromosomes_radius	&#x3D; hs1:1.15r;hs2:1.05r</span><br></pre></td></tr></table></figure>

<p>图片会变成下面这个样子</p>
<p><img data-src="https://s1.ax1x.com/2020/03/21/8RAhwj.png" alt="8RAhwj.png"></p>
<h3 id="Ideogram"><a href="#Ideogram" class="headerlink" title="Ideogram"></a>Ideogram</h3><p>Ideogram主要是karyotype相关的其它一些基本显示信息的设置，包括线条颜色、粗细、间隔，标签位置、字体等，这里我们新建一个ideogram.conf文件用来管理ideogram的相关信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ideogram&gt;</span><br><span class="line"></span><br><span class="line">&lt;spacing&gt;</span><br><span class="line">default &#x3D; 0.002r</span><br><span class="line">&lt;&#x2F;spacing&gt;</span><br><span class="line"></span><br><span class="line"># Ideogram position, fill and outline</span><br><span class="line">radius           &#x3D; 0.80r</span><br><span class="line">thickness        &#x3D; 20p</span><br><span class="line">fill             &#x3D; yes</span><br><span class="line">stroke_color     &#x3D; dgrey</span><br><span class="line">stroke_thickness &#x3D; 4p</span><br><span class="line"></span><br><span class="line">#显示label</span><br><span class="line">show_label       &#x3D; yes</span><br><span class="line">label_font       &#x3D; default </span><br><span class="line">## label位置在圈外侧50像素</span><br><span class="line">label_radius     &#x3D; dims(ideogram,radius_outer) + 50p</span><br><span class="line">label_size       &#x3D; 30</span><br><span class="line"># label与karyotype平行</span><br><span class="line">label_parallel   &#x3D; yes</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;ideogram&gt;</span><br></pre></td></tr></table></figure>

<p>我们的圈图就变成了下面这个样子</p>
<p><img data-src="https://s1.ax1x.com/2020/03/21/8RAROg.png" alt="8RAROg.png"></p>
<h3 id="Ticks"><a href="#Ticks" class="headerlink" title="Ticks"></a>Ticks</h3><p>Ticks主要是指坐标刻度和区块分隔线等，可以针对不同尺度设置不同的刻度显示方式。需要注意的是，Circos是由大至小进行刻度标识的，因此大尺度的刻度显示方式会替换小尺度。这里我们新建一个ticks.conf文件来设置相关信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 是否显示ticks</span><br><span class="line">show_ticks &#x3D; yes</span><br><span class="line"># 是否显示ticks的lables</span><br><span class="line">show_tick_labels &#x3D; yes</span><br><span class="line">#子程序ticks的设置</span><br><span class="line">&lt;ticks&gt;</span><br><span class="line"># ticks的位置</span><br><span class="line">radius &#x3D; 1r</span><br><span class="line"># ticks的颜色</span><br><span class="line">color &#x3D; black</span><br><span class="line"># ticks的厚度</span><br><span class="line">thickness &#x3D; 2p</span><br><span class="line">multiplier &#x3D; 1e-6</span><br><span class="line"># label 值的格式化方法。%d 表示结果为整数；%f 结果为浮点数； %.1f 结果为小数点后保留1位； %.2f 结果为小数点后保留2位。</span><br><span class="line">format &#x3D; %d</span><br><span class="line">## 以下设置了 2 个 ticks，前者是小刻度，后者是大刻度。</span><br><span class="line">&lt;tick&gt;</span><br><span class="line"># 设置每个刻度代表的长度。若其单位为 u，则必须要设置 chromosomes_units 参数。比如设置 chromosomes_units &#x3D; 1000000，则如下 5u 表示每个刻度代表 5M 长度的基因组序列。</span><br><span class="line">spacing &#x3D; 5u</span><br><span class="line"># 设置 tick 的长度</span><br><span class="line">size &#x3D; 10p</span><br><span class="line">&lt;&#x2F;tick&gt;</span><br><span class="line">&lt;tick&gt;</span><br><span class="line">spacing &#x3D; 25u</span><br><span class="line">size &#x3D; 15p</span><br><span class="line"># 以下用于设置展示 ticks&#39; label。</span><br><span class="line">show_label &#x3D; yes</span><br><span class="line"># 设置 ticks&#39; label 的字体大小</span><br><span class="line">label_size &#x3D; 20p</span><br><span class="line"># 设置 ticks&#39; label 离 ticks 的距离</span><br><span class="line">label_offset &#x3D; 10p</span><br><span class="line">format &#x3D; %d</span><br><span class="line">&lt;&#x2F;tick&gt;</span><br><span class="line">&lt;&#x2F;ticks&gt;</span><br></pre></td></tr></table></figure>

<p>此外需要将上一个板块儿中的参数50p改为250p，否则ticks会与染色体的label重叠</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label_radius     &#x3D; dims(ideogram,radius_outer) + 250p</span><br></pre></td></tr></table></figure>

<p>最终我们就得到的圈图，如下图所示</p>
<p><img data-src="https://s1.ax1x.com/2020/03/21/8RAfmQ.png" alt="8RAfmQ.png"></p>
<p>最后我们的配置circos.conf文件就变成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#karyotypes</span><br><span class="line">&lt;&lt;include karyotype.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line"># Ideograms</span><br><span class="line">&lt;&lt;include ideogram.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line"># Image</span><br><span class="line">&lt;image&gt;</span><br><span class="line">&lt;&lt;include etc&#x2F;image.conf&gt;&gt;</span><br><span class="line">&lt;&#x2F;image&gt;</span><br><span class="line"></span><br><span class="line">#Ticks</span><br><span class="line">&lt;&lt;include ticks.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line"># RGB&#x2F;HSV color definitions, color lists, location of fonts, fill patterns.</span><br><span class="line">&lt;&lt;include etc&#x2F;colors_fonts_patterns.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line"># Debugging, I&#x2F;O and other system parameters</span><br><span class="line">&lt;&lt;include etc&#x2F;housekeeping.conf&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Circos</tag>
      </tags>
  </entry>
  <entry>
    <title>基因差异表达分析</title>
    <url>/codeHub/2020/03/22/2020-06%E4%BB%A5%E5%89%8D/02%E5%9F%BA%E5%9B%A0%E5%B7%AE%E5%BC%82%E8%A1%A8%E8%BE%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="差异表达基因"><a href="#差异表达基因" class="headerlink" title="差异表达基因"></a>差异表达基因</h1><p>​    生物学上不同样本之间的表达差异时服从负二项分布的，RNA-seq中得到的基因表达水平是抽样过程中的一种离散形式。在测得的reads总量一定的情况下，表达水平越高的基因在抽样过程中所占的比例就越高，有些低表达的基因也有可能无法被检测出来。在得到基因的表达量之后，根据实验设计对不同样本之间基因进行差异表达分析</p>
<ol>
<li>同物种、不同组织间的比较</li>
<li>同一物种、同一组织、在不同处理下的比较</li>
<li>同一组织、不同物种间的比较</li>
<li>同一组织在不同时期间的比较</li>
</ol>
<p>​    通过差异表达分析，发现组织特异性、时期特异性、物种特异性的基因表达模式。通过GO功能富集、KEGG分析发现基因在细胞中参与的代谢和具体的功能、基因与基因之间的互作等。</p>
<a id="more"></a>

<h3 id="1-reads计数"><a href="#1-reads计数" class="headerlink" title="1.reads计数"></a>1.reads计数</h3><p>​    使用python包HTseq对统计每个基因比对到的read数</p>
<h4 id="1-1软件安装"><a href="#1-1软件安装" class="headerlink" title="1.1软件安装"></a>1.1软件安装</h4><p>​    非root用户需要使用<code>--user</code>参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install HTSeq --user</span><br></pre></td></tr></table></figure>

<h4 id="1-2统计基因比对上的read数"><a href="#1-2统计基因比对上的read数" class="headerlink" title="1.2统计基因比对上的read数"></a>1.2统计基因比对上的read数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htseq-count  -f bam -r pos -t exon -i gene_id  -m union -q  1_1_5_rmdup.bam genome.gtf &gt;count.txt</span><br></pre></td></tr></table></figure>

<p>​    <strong>命令参数如下</strong>：</p>
<ul>
<li><code>-f | --format</code>设置输入文件格式，默认sam</li>
<li><code>-r | --order</code> 设置输入文件排序方式，默认按照read name排序</li>
<li><code>-s | --stranded</code>是否链特异性建库，默认yes</li>
<li><code>-a | --a</code>设置质量阀值，默认忽略比对质量低于10的read</li>
<li><code>-t | --type</code>对gtf或者gff文件中指定feature计算，默认exon</li>
<li><code>-i | --idattr</code>设置feature id，通常是指第9列中，多个exon共有的gene属性如gene_id</li>
<li><code>-m | --mode default: union</code>设置统计模式</li>
<li><code>-o | --samout</code>输出一个sam文件，比对结果中多一个XF标签比对到的feature id。</li>
<li><code>-q | --quiet</code> 不输出程序运行的状态信息和警告信息</li>
<li><code>-h | --help</code>输出帮助信息。</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/6049898-721e9cbe006abbe3.png" alt="计数模式图"></p>
<h4 id="1-3输出结果"><a href="#1-3输出结果" class="headerlink" title="1.3输出结果"></a>1.3输出结果</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ghir_A01G000010	11</span><br><span class="line">Ghir_A01G000020	10</span><br><span class="line">Ghir_A01G000030	20</span><br><span class="line">Ghir_A01G000040	139</span><br><span class="line">Ghir_A01G000050	9</span><br><span class="line">Ghir_A01G000060	52</span><br><span class="line">Ghir_A01G000070	68</span><br><span class="line">__no_feature	8716242</span><br><span class="line">__ambiguous	157518</span><br><span class="line">__too_low_aQual	0</span><br><span class="line">__not_aligned	0</span><br><span class="line">__alignment_not_unique	0</span><br></pre></td></tr></table></figure>

<h4 id="1-4批量提交任务"><a href="#1-4批量提交任务" class="headerlink" title="1.4批量提交任务"></a>1.4批量提交任务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `ls `</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">bsub -J htseqCount -q <span class="string">"smp"</span> -n 1 -R span[hosts=1] -e htseqCount.err -o htseqCount.out <span class="string">"bash htseqcount.sh <span class="variable">$&#123;i&#125;</span>"</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="2-样品无重复"><a href="#2-样品无重复" class="headerlink" title="2.样品无重复"></a>2.样品无重复</h3><p>​    使用DESeq包，对于技术重复作者推荐将两个技术重复的read进行加和后作为样本的read数</p>
<blockquote>
<p> For technical replicates (e. g. when the same library preparation was distributed over multiple lanes of the sequencer), please sum up their counts to get a single column, corresponding to a unique biological replicate.  </p>
</blockquote>
<h4 id="2-1读取原始read数据"><a href="#2-1读取原始read数据" class="headerlink" title="2.1读取原始read数据"></a>2.1读取原始read数据</h4><p>​    其中行名为基因名，列名为样本名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	untreated3 untreated4 treated2 treated3</span><br><span class="line">FBgn0000003 0 0 0 1</span><br><span class="line">FBgn0000008 76 70 88 70</span><br><span class="line">FBgn0000014 0 0 0 0</span><br><span class="line">FBgn0000015 1 2 0 0</span><br><span class="line">FBgn0000017 3564 3150 3072 3334</span><br><span class="line">FBgn0000018 245 310 299 308</span><br></pre></td></tr></table></figure>

<h4 id="2-2补充样品分组信息"><a href="#2-2补充样品分组信息" class="headerlink" title="2.2补充样品分组信息"></a>2.2补充样品分组信息</h4><p>​    第一列与第二列属于<code>untreated</code>处理的两个重复</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">condition = factor( c( <span class="string">"untreated"</span>, <span class="string">"untreated"</span>, <span class="string">"treated"</span>, <span class="string">"treated"</span> ) )</span><br></pre></td></tr></table></figure>

<h4 id="2-3将分组信息与read表进行合并"><a href="#2-3将分组信息与read表进行合并" class="headerlink" title="2.3将分组信息与read表进行合并"></a>2.3将分组信息与read表进行合并</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>( <span class="string">"DESeq"</span> )</span><br><span class="line">&gt; cds = newCountDataSet( countTable, condition )</span><br></pre></td></tr></table></figure>

<h4 id="2-4对不同处理进行标准化"><a href="#2-4对不同处理进行标准化" class="headerlink" title="2.4对不同处理进行标准化"></a>2.4对不同处理进行标准化</h4><p>​    通过<code>estimateSizeFactors( cds )</code>函数来计算不同处理间测序深度是否存在较大的差异</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cds=estimateSizeFactors( cds )</span><br><span class="line">counts(cds, normalized = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-5估计离散度"><a href="#2-5估计离散度" class="headerlink" title="2.5估计离散度"></a>2.5估计离散度</h4><ul>
<li>这里由于没有重复需要使用<code>method= &quot;blind&quot;, sharingMode = &quot;fit-only&quot;</code>参数</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cds &lt;- estimateDispersions(cds, method = <span class="string">"blind"</span>, sharingMode = <span class="string">"fit-only"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-6差异分析"><a href="#2-6差异分析" class="headerlink" title="2.6差异分析"></a>2.6差异分析</h4><p>​    后两个参数是指定需要比较的样品</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">res = nbinomTest( cds, <span class="string">"untreated"</span>, <span class="string">"treated"</span> )</span><br><span class="line"><span class="comment">## 绘制数据的分布情况</span></span><br><span class="line">plotMA(res)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2020/03/17/8t6jXV.png" alt="数据分布"></p>
<h4 id="2-7输出结果"><a href="#2-7输出结果" class="headerlink" title="2.7输出结果"></a>2.7输出结果</h4><ul>
<li><code>id feature</code> identifier baseMean mean normalised counts, averaged over all samples from both conditions +</li>
<li><code>baseMeanA</code> mean normalised counts from condition A </li>
<li><code>baseMeanB</code>mean normalised counts from condition B foldChange </li>
<li><code>fold change</code> from condition A to B </li>
<li><code>log2FoldChange</code> the logarithm (to basis 2) of the fold change </li>
<li><code>pval</code>p value for the statistical significance of this change </li>
<li><code>padj</code>p value adjusted for multiple testing with the Benjamini-Hochberg procedure (see the R function p.adjust), which controls false discovery rate (FDR)  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">id baseMean baseMeanA baseMeanB foldChange log2FoldChange pval padj</span><br><span class="line">1 FBgn0000003 0.224 0.00 0.449 Inf Inf 1.000 1.000</span><br><span class="line">2 FBgn0000008 76.296 78.16 74.436 0.952 -0.0704 0.835 1.000</span><br><span class="line">3 FBgn0000014 0.000 0.00 0.000 NaN NaN NA NA</span><br><span class="line">4 FBgn0000015 0.781 1.56 0.000 0.000 -Inf 0.416 1.000</span><br><span class="line">5 FBgn0000017 3298.682 3599.47 2997.890 0.833 -0.2638 0.241 0.881</span><br><span class="line">6 FBgn0000018 289.031 293.68 284.385 0.968 -0.0464 0.757 1.000</span><br></pre></td></tr></table></figure>

<h4 id="2-8筛选差异表达基因"><a href="#2-8筛选差异表达基因" class="headerlink" title="2.8筛选差异表达基因"></a>2.8筛选差异表达基因</h4><p>​    没有重复的样根据p-value来筛选差异表达的基因意义不大，所以直接对输出的结果用awk进行筛选。筛选的时候有三种情况</p>
<ul>
<li>两个样都有read比对上</li>
<li>两个样中有一个样是没有read比对上，这种情况会使的log2foldcahnge为inf</li>
<li>两个样中比对到的read都为0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">"\t"</span> <span class="string">'NR&gt;=2&amp;&amp;$6!="Inf"&amp;&amp;$6!="NA"&amp;&amp;$6&gt;=1&#123;print $1"\tup"&#125;NR&gt;=2&amp;&amp;$6!="Inf"&amp;&amp;$6!="NA"&amp;&amp;$6&lt;=-1&#123;print $1"\tdown"&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 第三种情况相当于没有差异表达，不用考虑</span></span><br></pre></td></tr></table></figure>



<h3 id="3-样品有重复"><a href="#3-样品有重复" class="headerlink" title="3.样品有重复"></a>3.样品有重复</h3><p>​    推荐使用DESeq2包</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>HTSeq仓库  <a href="https://github.com/simon-anders/htseq" target="_blank" rel="noopener">https://github.com/simon-anders/htseq</a> </li>
<li>HTSeq使用文档  <a href="https://htseq.readthedocs.io/en/release_0.11.1/" target="_blank" rel="noopener">https://htseq.readthedocs.io/en/release_0.11.1/</a> </li>
<li>HTSeq使用文档  <a href="https://www.cnblogs.com/triple-y/p/9338890.html" target="_blank" rel="noopener">https://www.cnblogs.com/triple-y/p/9338890.html</a> </li>
<li>DESeq使用文档  <a href="https://bioconductor.org/packages/release/bioc/vignettes/DESeq/inst/doc/DESeq.pdf" target="_blank" rel="noopener">https://bioconductor.org/packages/release/bioc/vignettes/DESeq/inst/doc/DESeq.pdf</a> </li>
</ol>
]]></content>
      <categories>
        <category>RNA-seq</category>
      </categories>
  </entry>
  <entry>
    <title>hexo服务搭建</title>
    <url>/codeHub/2020/03/21/2020-06%E4%BB%A5%E5%89%8D/01hexo%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="hexo服务搭建"><a href="#hexo服务搭建" class="headerlink" title="hexo服务搭建"></a>hexo服务搭建</h1><span class="label success">Hexo</span>  一款简洁并且高效的博客框架，结合markdown语法，让你的想法展现的淋漓尽致。通过本地编译markdown文件生成html 静态文件，部署到云端；使得笔记得到永久保存。利用Github、腾讯云等免费代码仓库存储服务，让你能够随时随地编辑；不受设备影响。

<a id="more"></a>

<h3 id="1-初始化hexo"><a href="#1-初始化hexo" class="headerlink" title="1.初始化hexo"></a>1.初始化hexo</h3><p>​    在命令行中运行一下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#初始化hexo</span></span><br><span class="line">hexo init &lt;folder_name&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder_name&gt;</span><br><span class="line"><span class="comment">#下载相关依赖</span></span><br><span class="line">npm i</span><br></pre></td></tr></table></figure>

<p>​    hexo 初始化完成之后，在<code>folder_name</code>目录下将会产生一下文件和文件夹</p>
<p>​    hexo相关的命令均需要在bash中进入<code>folder_name</code>目录后运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动本地预览</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="comment">#将md文件编译为html</span></span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>​    启动本地预览后，访问网址可以查看到静态网页</p>
<blockquote>
<p> <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> </p>
</blockquote>
<h3 id="2-部署到云端"><a href="#2-部署到云端" class="headerlink" title="2.部署到云端"></a>2.部署到云端</h3><h4 id="2-1GithubPage进行部署"><a href="#2-1GithubPage进行部署" class="headerlink" title="2.1GithubPage进行部署"></a>2.1GithubPage进行部署</h4><ol>
<li><p>在github中创建一个仓库</p>
</li>
<li><p>将hexo push到github仓库中</p>
</li>
</ol>
<p>下载对应的插件</p>
<p><code>--save</code>参数会将插件信息保存在<code>package.json</code>文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>配置站点目录下<code>_config.yml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:zpliu1126/codeHub.git</span><br><span class="line">  branch: gh-pages</span><br></pre></td></tr></table></figure>

<p>部署实际上就是在将hexo编译生成的<code>public</code>目录下的所有文件推送到云端</p>
<p>部署完成后通过访问网址即可访问到hexo静态博客</p>
<blockquote>
<p> https://&lt;Github账号名称&gt;.github.io /仓库名</p>
</blockquote>
<h4 id="2-2部署到腾讯云"><a href="#2-2部署到腾讯云" class="headerlink" title="2.2部署到腾讯云"></a>2.2部署到腾讯云</h4><p>当有多个云端时，配置文件如下进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"> -  <span class="built_in">type</span>: git</span><br><span class="line">    repo: git@github.com:zpliu1126/codeHub.git</span><br><span class="line">    branch: gh-pages</span><br><span class="line"> -  <span class="built_in">type</span>: git</span><br><span class="line">    repo: git@e.coding.net:biocodehub/codeHub.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>



<h3 id="3-自定义主题"><a href="#3-自定义主题" class="headerlink" title="3.自定义主题"></a>3.自定义主题</h3><p>​    hexo中默认的主题是<code>landscape</code>，可以在github中搜索对应的主题选择下载</p>
<h4 id="3-1主题安装"><a href="#3-1主题安装" class="headerlink" title="3.1主题安装"></a>3.1主题安装</h4><p>我这里使用到的是<code>next</code>主题</p>
<ol>
<li>下载对应的主题文件</li>
<li>将主题整个文件夹粘贴到<code>themes</code>目录下</li>
<li>更改站点文件夹配置文件中theme字段为对应的主题名</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载对应的主题 </span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>



<h4 id="3-2主题优化"><a href="#3-2主题优化" class="headerlink" title="3.2主题优化"></a>3.2主题优化</h4><p><code>Next</code>主题优化官方文档</p>
<blockquote>
<p> <a href="https://theme-next.org/docs/theme-settings/" target="_blank" rel="noopener">https://theme-next.org/docs/theme-settings/</a> </p>
</blockquote>
<ul>
<li><p>自定义样式文件</p>
<p><code>Next</code>最新版主题支持将样式文件放置在主题文件夹之外，只需要在主题文件夹中进行配置</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">   style: <span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>

<ul>
<li><p>添加背景图片</p>
<p>添加主题自定义样式</p>
<p><strong><em>修改样式时，最后将public文件夹全部删除，然后<code>hexo g</code>重新编译生成css文件</em></strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background:url(/images/themeImg/splash.png);</span><br><span class="line">    background-size:cover;</span><br><span class="line">    background-repeat:no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>转载协议</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: <span class="literal">true</span></span><br><span class="line">  post: <span class="literal">true</span></span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义<code>logo</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Custom Logo (Do not support scheme Mist)</span></span><br><span class="line">custom_logo: /images/themeImg/logo.png</span><br></pre></td></tr></table></figure>

<ul>
<li>代码高亮显示和复制按钮</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  highlight_theme: night</span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  copy_button:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    show_result: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    style:</span><br></pre></td></tr></table></figure>

<ul>
<li>阅读进度条</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  color: <span class="string">"#37c6c0"</span></span><br><span class="line">  height: 2px</span><br></pre></td></tr></table></figure>

<ul>
<li><p>书签</p>
<p>当下次访问时自动滚动到对应位置</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bookmark:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.</span></span><br><span class="line">  color: <span class="string">"#222"</span></span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.</span></span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure>

<ul>
<li>Follow me 标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Follow me on GitHub banner in right-top corner.</span></span><br><span class="line">github_banner:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  permalink: https://github.com/yourname</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字体设置</p>
<p><code>Next</code>为5中类型提供字体设置</p>
<ul>
<li>全局字体设置</li>
<li>title字体设置</li>
<li>标题字体设置 h1 、h2</li>
<li>文章字体设置</li>
<li>代码字体设置</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  <span class="comment"># Use custom fonts families or not.</span></span><br><span class="line">  <span class="comment"># Depended options: `external` and `family`.</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. //fonts.googleapis.com (Default).</span></span><br><span class="line">  host:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  global:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family: Monda</span><br><span class="line">    size: 1.125</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  title:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family: Lobster Two</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  headings:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family: Amita</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  posts:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family: Roboto Slab</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  codes:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family: PT Mono</span><br></pre></td></tr></table></figure>



<ul>
<li><p>安装插件</p>
<p>支持两种安装方法</p>
<ol>
<li>本地安装</li>
<li>使用CDN links</li>
</ol>
<p>如果你的站点是部署在一些免费的云端，推荐使用CDN links，因为它加载起来更快</p>
<p><strong>本地安装</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在bash中安装下载对应插件</span></span><br><span class="line">$ <span class="built_in">cd</span> themes/next</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pjax <span class="built_in">source</span>/lib/pjax</span><br><span class="line"><span class="comment"># 启用pjax插件</span></span><br><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pjax</span></span><br><span class="line">pjax: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>CDN links 安装</p>
<blockquote>
<p> jsDelivr CDN is recommended to deliver our third-party plugins </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Script Vendors. Set a CDN address for the vendor you want to customize.</span></span><br><span class="line"><span class="comment"># Be aware that you would better use the same version as internal ones to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Remember to use the https protocol of CDN files when you enable https on your site.</span></span><br><span class="line">vendors:</span><br><span class="line">  <span class="comment"># Internal path prefix.</span></span><br><span class="line">  _internal: lib</span><br><span class="line">  pjax: https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js</span><br></pre></td></tr></table></figure>



<ul>
<li>设置整体布局</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<ul>
<li>配置菜单栏<ol>
<li>第一栏表示菜单名</li>
<li>第二栏表示相对url</li>
<li><code>||</code>后表示icon</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  archives: /archives/ || archiveasad</span><br></pre></td></tr></table></figure>

<ul>
<li>菜单栏的一些修饰<ul>
<li>显示icon</li>
<li>显示条目数</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable / Disable menu icons / item badges.</span></span><br><span class="line">menu_settings:</span><br><span class="line">  icons: <span class="literal">true</span></span><br><span class="line">  badges: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>条目数支持中文</p>
<p>修改<code>next\layout\_partials\header\menu-item.swig</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> theme.menu_settings.badges %&#125;</span><br><span class="line">  &#123;%- <span class="built_in">set</span> badges = &#123;</span><br><span class="line">    <span class="string">'文章'</span>  : site.posts.length,</span><br><span class="line">    <span class="string">'分类'</span>: site.categories.length,</span><br><span class="line">    <span class="string">'标签'</span>      : site.tags.length</span><br><span class="line">    &#125;</span><br><span class="line">  %&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>侧边栏显示头像</p>
<p>支持将图片放在<code>theme</code>文件夹之外，例如在  site directory <code>source/uploads/</code> 下</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line">avatar:</span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  url: /images/avatar.gif</span><br></pre></td></tr></table></figure>

<ul>
<li><p>编辑站点信息</p>
<ul>
<li>author</li>
<li>description</li>
</ul>
<p>配置<code>hexo/_config.yml</code>文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">author:</span><br><span class="line">description:</span><br></pre></td></tr></table></figure>



<h3 id="4-第三方评论系统"><a href="#4-第三方评论系统" class="headerlink" title="4.第三方评论系统"></a>4.第三方评论系统</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">推荐指数</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a></td>
<td align="left">4</td>
<td align="left">每天30000条评论，10GB的储存</td>
<td align="left">作者评论无标识</td>
</tr>
<tr>
<td align="left"><a href="https://livere.com/" target="_blank" rel="noopener">来必力/livere</a></td>
<td align="left">4</td>
<td align="left">多种账号登录</td>
<td align="left">评论无法导出</td>
</tr>
<tr>
<td align="left"><a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言</a></td>
<td align="left">3</td>
<td align="left">美观</td>
<td align="left">必须备案域名</td>
</tr>
<tr>
<td align="left"><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a></td>
<td align="left">3</td>
<td align="left">简洁</td>
<td align="left">只能登陆github评论</td>
</tr>
<tr>
<td align="left">Disqus</td>
<td align="left">1</td>
<td align="left"></td>
<td align="left">需要翻*墙</td>
</tr>
</tbody></table>
<h4 id="4-1Valine"><a href="#4-1Valine" class="headerlink" title="4.1Valine"></a>4.1Valine</h4><p>注册Valine账户</p>
<blockquote>
<p><a href="https://leancloud.cn/dashboard/applist.html" target="_blank" rel="noopener">https://leancloud.cn/dashboard/applist.html</a></p>
</blockquote>
<p>文章中添加字段</p>
<p><code>comments: true</code></p>
<p>主题文件中进行设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  appid:  <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  appkey:  <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  notify: <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line">  verify: <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  placeholder: Just go go <span class="comment"># Comment box placeholder</span></span><br><span class="line">  avatar: mm <span class="comment"># Gravatar style</span></span><br><span class="line">  guest_info: nick,mail,link <span class="comment"># Custom comment header</span></span><br><span class="line">  pageSize: 10 <span class="comment"># Pagination size</span></span><br><span class="line">  language: zh-cn <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  visitor: <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  comment_count: <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  recordIP: <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  serverURLs: <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>

<h3 id="5-搜索"><a href="#5-搜索" class="headerlink" title="5.搜索"></a>5.搜索</h3><p>使用本地插件配置搜索数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p><code>hexo/_config.yml</code>文件配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;search:  path: search.xml  field: post  format: html  limit: 10000&#96;</span><br></pre></td></tr></table></figure>

<p><code>next/_config.yml</code>文件中配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  preload: <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="6-自定义标签"><a href="#6-自定义标签" class="headerlink" title="6.自定义标签"></a>6.自定义标签</h3><p>hexo生成标签页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"新的标签"</span></span><br></pre></td></tr></table></figure>

<p>在标签页面md文件中指定类型为标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 新的标签</span><br><span class="line">date: 2020-03-22 08:39:29</span><br><span class="line"><span class="built_in">type</span>: tags</span><br></pre></td></tr></table></figure>

<p>在post文章中使用标签</p>
<ul>
<li>多个标签使用<code>-</code>进行区分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: hexo服务搭建</span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">author: zzz</span><br><span class="line">date: &#123;date&#125;</span><br><span class="line">categories: </span><br><span class="line">	- <span class="built_in">test</span></span><br><span class="line">tags:</span><br><span class="line">	- hexo</span><br></pre></td></tr></table></figure>



<h3 id="7-首页进行文章截取"><a href="#7-首页进行文章截取" class="headerlink" title="7.首页进行文章截取"></a>7.首页进行文章截取</h3><p>编辑<code>theme/_config.yml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">excerpt_description: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># If true, the read more button will be displayed in excerpt section.</span></span><br><span class="line">read_more_btn: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>下载对应插件</p>
<p><code>npm i hexo-excerpt</code></p>
<p>另外一种可以使用<code>&lt;!-- more --&gt;</code>在md文件中实现更加精准的控制</p>
<h3 id="8-静态资源压缩"><a href="#8-静态资源压缩" class="headerlink" title="8.静态资源压缩"></a>8.静态资源压缩</h3><p>一般将css和js文件中的空格和换行符进行压缩，一定程度上能减少网络延迟</p>
<ul>
<li><p>安装gulp 命令</p>
<p>站点根目录下运行</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp</span><br></pre></td></tr></table></figure>

<ul>
<li>安装gulp插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install gulp-minify-css --save</span><br><span class="line">npm install gulp-uglify --save</span><br><span class="line">npm install gulp-htmlmin --save</span><br><span class="line">npm install gulp-htmlclean --save</span><br><span class="line">npm install gulp-imagemin --save</span><br></pre></td></tr></table></figure>

<ul>
<li>压缩规则文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var gulp = require(<span class="string">'gulp'</span>);</span><br><span class="line">var minifycss = require(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line">var uglify = require(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">var htmlmin = require(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line">var htmlclean = require(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line">var imagemin = require(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line">// 压缩css文件</span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">  .pipe(minifycss())</span><br><span class="line">  .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩html文件</span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>,  gulp.series(<span class="string">'minify-css'</span>,<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">  .pipe(htmlclean())</span><br><span class="line">  .pipe(htmlmin(&#123;</span><br><span class="line">    removeComments: <span class="literal">true</span>,</span><br><span class="line">    minifyJS: <span class="literal">true</span>,</span><br><span class="line">    minifyCSS: <span class="literal">true</span>,</span><br><span class="line">    minifyURLs: <span class="literal">true</span>,</span><br><span class="line">  &#125;))</span><br><span class="line">  .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;));</span><br><span class="line">// 压缩js文件</span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, gulp.series(<span class="string">'minify-html'</span>,<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> gulp.src([<span class="string">'./public/**/.js'</span>,<span class="string">'!./public/js/**/*min.js'</span>])</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;));</span><br><span class="line">// 压缩 public/demo 目录内图片</span><br><span class="line">gulp.task(<span class="string">'minify-images'</span>, gulp.series(<span class="string">'minify-js'</span>,<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    gulp.src(<span class="string">'./public/demo/**/*.*'</span>)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">           optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）</span><br><span class="line">           progressive: <span class="literal">true</span>, //类型：Boolean 默认：<span class="literal">false</span> 无损压缩jpg图片</span><br><span class="line">           interlaced: <span class="literal">false</span>, //类型：Boolean 默认：<span class="literal">false</span> 隔行扫描gif进行渲染</span><br><span class="line">           multipass: <span class="literal">false</span>, //类型：Boolean 默认：<span class="literal">false</span> 多次优化svg直到完全优化</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public/uploads'</span>));</span><br><span class="line">&#125;));</span><br><span class="line">// 默认任务</span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.series(<span class="string">'minify-css'</span>,<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">  .pipe(minifycss())</span><br><span class="line">  .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<ul>
<li>在hexo 编译生成html文件后执行压缩即可</li>
</ul>
<p><code>hexo g &amp;&amp; gulp &amp;&amp; hexo d</code></p>
<p>​    </p>
<h3 id="9-保存原始post文件和主题配置文件"><a href="#9-保存原始post文件和主题配置文件" class="headerlink" title="9.保存原始post文件和主题配置文件"></a>9.保存原始post文件和主题配置文件</h3><h4 id="9-1新建空分支"><a href="#9-1新建空分支" class="headerlink" title="9.1新建空分支"></a>9.1新建空分支</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先克隆仓库</span></span><br><span class="line"> git <span class="built_in">clone</span> git@e.coding.net:biocodehub/codeHub.git</span><br><span class="line"><span class="comment"># 进入仓库</span></span><br><span class="line"><span class="built_in">cd</span> codeHub</span><br><span class="line"><span class="comment"># 创建新的分支</span></span><br><span class="line">git checkout --orphan <span class="built_in">source</span></span><br><span class="line"><span class="comment"># 删除当前分支所有文件</span></span><br><span class="line">git rm -rf .</span><br><span class="line"><span class="comment"># 创建一个文件并提交到当前分支</span></span><br><span class="line">$ <span class="built_in">echo</span> \"My GitHub Page\" &gt; index.html</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -a -m \"new branch <span class="built_in">source</span>\"</span><br><span class="line">$ git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>登录远程仓库，手动删除<code>index.html</code>就变成空的分支了</p>
<h4 id="9-2提交hexo源码"><a href="#9-2提交hexo源码" class="headerlink" title="9.2提交hexo源码"></a>9.2提交hexo源码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 站点初始化仓库</span></span><br><span class="line"><span class="built_in">cd</span> codeHub</span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 添加远程地址</span></span><br><span class="line">git remote add origin “仓库地址<span class="string">"</span></span><br><span class="line"><span class="string"># 编辑</span></span><br></pre></td></tr></table></figure>

<p><code>gitignore</code>文件 ,选择推送的文件</p>
<p>在添加要推送的文件之间，先将主题下的<code>\themes\next\.git</code>文件夹删除，git不允许一个仓库包含另外一个仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取远端分析</span></span><br><span class="line">git fetch</span><br><span class="line"><span class="comment">#切换到origin source分支</span></span><br><span class="line">git checkout origin/<span class="built_in">source</span></span><br><span class="line"><span class="comment">#新建本地分支</span></span><br><span class="line">git checkout -b <span class="built_in">source</span></span><br><span class="line"><span class="comment">#将本地分支与远端分支关联</span></span><br><span class="line">git branch -u origin/<span class="built_in">source</span> <span class="built_in">source</span></span><br><span class="line"><span class="comment">#开始上传文件</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"code Hub source code"</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<h4 id="9-3克隆远端源码"><a href="#9-3克隆远端源码" class="headerlink" title="9.3克隆远端源码"></a>9.3克隆远端源码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b <span class="built_in">source</span> git@e.coding.net:biocodehub/codeHub.git</span><br><span class="line">$ hexo s</span><br><span class="line">$ npm install hexo-deployer-git -save</span><br><span class="line"><span class="comment"># 推送到远端</span></span><br><span class="line">$ hexo g &amp;&amp; gulp hexo d</span><br></pre></td></tr></table></figure>

<h4 id="10文章访问统计"><a href="#10文章访问统计" class="headerlink" title="10文章访问统计"></a>10文章访问统计</h4><p>使用<code>LeanCloud (China)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> npm install hexo-leancloud-counter-security</span><br><span class="line"> <span class="comment">#hexo 站点进行配置</span></span><br><span class="line"> leancloud_counter_security:</span><br><span class="line">  enable_sync: <span class="literal">true</span></span><br><span class="line">  app_id: &lt;your app id&gt;</span><br><span class="line">  app_key: &lt;your app key&gt;</span><br><span class="line">  username: &lt;your username&gt; <span class="comment"># Will be asked while deploying if is left blank</span></span><br><span class="line">  password: &lt;your password&gt; <span class="comment"># Recommmended to be left blank. Will be asked while deploying if is left blank</span></span><br><span class="line"><span class="comment"># 主题配置文件</span></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  app_id: <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  app_key: <span class="comment">#&lt;app_key&gt;</span></span><br><span class="line">  <span class="comment"># Required for apps from CN region</span></span><br><span class="line">  server_url: <span class="comment"># &lt;your server url&gt;</span></span><br><span class="line">  <span class="comment"># Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span></span><br><span class="line">  <span class="comment"># If you don't care about security in lc counter and just want to use it directly</span></span><br><span class="line">  <span class="comment"># (without hexo-leancloud-counter-security plugin), set the `security` to `false`.</span></span><br><span class="line">  security: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Busuanzi</code></p>
<p>开启主题配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>

<p>修改主题文件中swig文件实现自定义</p>
<p><code>\themes\next\layout\_third-party\statistics\busuanzi-counter.swig</code></p>
<p>修改文章顶部栏目</p>
<p><code>\themes\next\layout\_macro\post.swig</code></p>
<h3 id="11-参考"><a href="#11-参考" class="headerlink" title="11.参考"></a>11.参考</h3><ol>
<li>遇见西门 <a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a> </li>
<li>Next  <a href="https://theme-next.org/docs/" target="_blank" rel="noopener">https://theme-next.org/docs/</a> </li>
<li>git仓库推送 <a href="https://blog.csdn.net/wankui/article/details/53328369" target="_blank" rel="noopener">https://blog.csdn.net/wankui/article/details/53328369</a> </li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
